<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>k3s集群使用本地DNS缓存（node local dns）</title>
    <link href="/2025/06/08/k3s-with-nodelocaldns/"/>
    <url>/2025/06/08/k3s-with-nodelocaldns/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>K3s集群内集成了CoreDNS作为kube-dns，默认IP为10.43.0.10。当Pod的dns类型为<code>ClusterFirst</code>&#x2F;<code>ClusterFirstWithHostNet</code>时，在容器内可以通过<code>&lt;service名&gt;.&lt;namespace名&gt;.svc.cluster.local</code>域名访问集群内的service（后面几段可以省略），而不再需要使用cluster ip或node port。</p><p>笔者的K3s集群有跨省份的多个节点，节点之间通过tailscale虚拟局域网通信。tailscale使用UDP协议传输数据，而运营商对跨省的UDP流量往往会采取QoS限流策略。</p><p>笔者观察到的现象是，当K3s的CoreDNS实例部署在省份A时，那么处于省份B的部分Pod在解析集群内service域名时，容易出现解析速度慢、甚至解析失败的情况，这点很是让笔者头疼。</p><p>和AI探讨方案后，AI提出可以使用K8s的<code>NodeLocal DNSCache</code>（以下简称localdns）来建立本地DNS缓存，保证域名解析的稳定性。但默认的localdns配置并不兼容K3s，笔者经过一番摸索得出了兼容k3s集群的localdns配置，用本文作为记录。</p><h1 id="localdns配置"><a href="#localdns配置" class="headerlink" title="localdns配置"></a>localdns配置</h1><p>K8s默认的localdns配置可在<a href="https://raw.githubusercontent.com/kubernetes/kubernetes/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml">Github</a>上查看。内容较多，但对于K3s场景来说只需要有两个关键配置。</p><h2 id="ConfigMap配置"><a href="#ConfigMap配置" class="headerlink" title="ConfigMap配置"></a>ConfigMap配置</h2><p>localdns使用的也是CoreDNS，所以在ConfigMap里编写Corefile即可。主体逻辑如下：</p><ul><li>监听169.254.20.10:53，处理发来的DNS请求，并开启日志&#x2F;缓存等功能</li><li>如果请求域名是<code>cluster.local.</code>结尾，则转发到K3s自身的CoreDNS<code>10.43.0.10</code></li><li>否则将请求转发到公共DNS<code>119.29.29.29</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">node-local-dns</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">data:</span><br>    <span class="hljs-attr">Corefile:</span> <span class="hljs-string">&quot;.:53 &#123;\n    bind 169.254.20.10\n\n\tforward cluster.local. 10.43.0.10 &#123;\n        force_tcp\n    &#125;\n    forward . 119.29.29.29\n\n    reload\n    log\n    loop\n    errors\n    cache 30\n    prometheus :9253\n&#125;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="DaemonSet配置"><a href="#DaemonSet配置" class="headerlink" title="DaemonSet配置"></a>DaemonSet配置</h2><p>要在每台机器上部署一个localdns实例，使用如下DaemonSet配置即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">node-local-dns</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">node-local-dns</span><br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">updateStrategy:</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">10</span><span class="hljs-string">%</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">node-local-dns</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">node-local-dns</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-attr">prometheus.io/port:</span> <span class="hljs-string">&quot;9253&quot;</span><br>        <span class="hljs-attr">prometheus.io/scrape:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">system-node-critical</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">node-local-dns</span><br>      <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">Default</span>  <span class="hljs-comment"># Don&#x27;t use cluster DNS.</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;CriticalAddonsOnly&quot;</span><br>        <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoExecute&quot;</span><br>        <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br>        <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Exists&quot;</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">node-cache</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.k8s.io/dns/k8s-dns-node-cache:1.26.4</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">25m</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">5Mi</span><br>        <span class="hljs-attr">args:</span> [ <span class="hljs-string">&quot;-localip&quot;</span>, <span class="hljs-string">&quot;169.254.20.10&quot;</span>, <span class="hljs-string">&quot;-conf&quot;</span>, <span class="hljs-string">&quot;/etc/Corefile&quot;</span> ]<br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">capabilities:</span><br>            <span class="hljs-attr">add:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">NET_ADMIN</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">53</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">dns</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">UDP</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">53</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">dns-tcp</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9253</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">metrics</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/run/xtables.lock</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">xtables-lock</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/coredns</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">xtables-lock</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/run/xtables.lock</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">FileOrCreate</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">node-local-dns</span><br>          <span class="hljs-attr">items:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">Corefile</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">Corefile.base</span><br></code></pre></td></tr></table></figure><h2 id="确认部署状态"><a href="#确认部署状态" class="headerlink" title="确认部署状态"></a>确认部署状态</h2><p>可通过<code>kubectl get pods -n kube-system</code>命令确认localdns部署状态</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">NAME                                      READY   STATUS    RESTARTS   AGE<br>...省略<br><span class="hljs-keyword">node</span><span class="hljs-title">-local-dns-56v44</span>                      <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">45s</span><br><span class="hljs-keyword">node</span><span class="hljs-title">-local-dns-7tnrs</span>                      <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">41s</span><br><span class="hljs-keyword">node</span><span class="hljs-title">-local-dns-j74kr</span>                      <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">45s</span><br><span class="hljs-keyword">node</span><span class="hljs-title">-local-dns-pk9kt</span>                      <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">45s</span><br><span class="hljs-keyword">node</span><span class="hljs-title">-local-dns-vghvz</span>                      <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     Running   <span class="hljs-number">0</span>          <span class="hljs-number">45s</span><br></code></pre></td></tr></table></figure><h1 id="K3s配置"><a href="#K3s配置" class="headerlink" title="K3s配置"></a>K3s配置</h1><p>修改文件<code>/etc/rancher/k3s/config.yaml</code>，在kubelet配置中设置<code>cluster-dns</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kubelet-arg:</span><br>  <span class="hljs-comment"># 省略其它   </span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--cluster-dns=169.254.20.10&quot;</span><br></code></pre></td></tr></table></figure><p>然后重启K3s服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart k3s <span class="hljs-comment"># 主节点</span><br>sudo systemctl restart k3s-agent <span class="hljs-comment"># 从节点</span><br></code></pre></td></tr></table></figure><p>接下来创建的Pod，当dns类型为<code>ClusterFirst</code>&#x2F;<code>ClusterFirstWithHostNet</code>时，就会使用本地的localdns解析service域名，而不是默认的<code>10.43.0.10</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年度总结</title>
    <link href="/2024/12/30/2024-summary/"/>
    <url>/2024/12/30/2024-summary/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2024年，我在长沙度过了完整的一年。即将28岁的关口，我回望过去的一年，发现自己似乎没怎么变，但好在更认清了自己一些。</p><h1 id="1-身体健康"><a href="#1-身体健康" class="headerlink" title="1. 身体健康"></a>1. 身体健康</h1><p>大概估算，今年我运动的次数超过了100次——相比去年没有出现大幅度下降；我在健康上投资的金钱相比去年也有小幅上涨。可惜的是最近我的身体状态实在糟糕：打鼾加重、睡眠质量差、视力下降等等。现在回想起来，我的惰性渐渐占了上风：运动不再那么规律和投入、懒于去做眼科等复查，甚至连应该要按时吃的药都没那么上心了。就像一直在推石头的西西弗斯一样，将身体维持在相对健康的情况是我丝毫不能懈怠的事情🥲</p><h1 id="2-精神生活"><a href="#2-精神生活" class="headerlink" title="2. 精神生活"></a>2. 精神生活</h1><p>今年我在豆瓣上标记看过了30部影视作品、20本书，参加了爬山、读书会、桌游、观影等等线下活动，很高兴看到自己对这个世界的好奇心和热爱还没有减退。年中自建的代码仓库更是催化了我对代码的热爱，半年内900多次提交，平均每天5次。当然代价是挤占了其它活动的时间，比如动漫&#x2F;游戏；而且沉迷代码也是造成视力下降的重要因素。但总体而言，今年在这方面过得挺开心😊</p><h1 id="3-人际交往"><a href="#3-人际交往" class="headerlink" title="3. 人际交往"></a>3. 人际交往</h1><p>人际关系是我去年选择从上海回到长沙的重要因素。在长沙的这一年里，我获得的东西和当初的设想比较接近：能很方便见到父母、找大学同学玩；心情更加安定；甚至还有了两段恋爱经历——即使时间都不算长。当我再回过头去看时，我想从中获得什么、其在“什么构成了我”里的比例，和之前的设想稍微有一些出入。年初我读的书《如何避免孤独终老》对我影响很大，现在我没那么害怕“孤独终老”这四个字了🤯</p><h1 id="4-职业和个人成就"><a href="#4-职业和个人成就" class="headerlink" title="4. 职业和个人成就"></a>4. 职业和个人成就</h1><p>从职业发展的角度来看，我在长沙的状态和之前在上海的状态有明显落差，不管是薪资回报、个人成长、还是发展空间都是如此，但我反而能坦然接受。一部分原因是今年开始的独立开发之路带给了我很多成就感：正式运营的两个互联网产品中，其中一个略有盈余，另一个边际成本低且即将开始商业化。另一部分原因是《重新定义公司》让我强烈感受到，我可能并不是那种乐于且善于团队协作的创意精英，寻找最适合自己的路未尝不可💪</p><h1 id="5-金钱和财务"><a href="#5-金钱和财务" class="headerlink" title="5. 金钱和财务"></a>5. 金钱和财务</h1><p>和去年相比，今年我的收入几乎腰斩，而支出只减少了25%，必须承认我的支出项目里还有不少可优化的空间。下半年我读了《聪明的投资者》和《金钱心理学》，它们指引了我未来的财务规划。金钱能给我带来的最大价值是时间自由，而我今年做的这些决策（定投指数基金、调高权益资产比例、增加港股&#x2F;美股投资渠道）让我有自信能越来越接近这个结果。接下来重视储蓄、优化开支，未来几年慢慢变富🤑</p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>理清过去一年自己的生活，也是在看清未来道路的方向。愿看到这里的你明年也能朝着自己认可的方向前行~</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大模型Tools(Function Calling)实用性分析 - 以媒体信息解析为例</title>
    <link href="/2024/09/21/parcticality-analysis-of-llm-tools/"/>
    <url>/2024/09/21/parcticality-analysis-of-llm-tools/</url>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>作为一个喜欢收集影视资源的人，笔者面临的一个任务是：从文件名中解析出格式化的媒体信息（信息源统一为<a href="https://www.themoviedb.org/?language=zh-CN">The Movie Database (TMDB)</a>），方便整理文件，如：</p><table><thead><tr><th>文件名</th><th>格式化信息</th></tr></thead><tbody><tr><td>Young.Woman.and.the.Sea.2024.2160p.DSNP.WEB-DL.H265.HDR.DDP5.1.Atmos-ADWeb.mkv</td><td><code>&#123;&#39;title&#39;: &#39;泳者之心&#39;, &#39;genre&#39;: &#39;movie&#39;, &#39;year&#39;: 2024&#125;</code></td></tr><tr><td>【動畫瘋】物語系列 第外季＆第怪季[9][1080P].mp4</td><td><code>&#123;&#39;title&#39;: &#39;物语系列&#39;, &#39;genre&#39;: &#39;tv(anime)&#39;, &#39;year&#39;: 2009, &#39;tv_season_num&#39;: 5, &#39;tv_episode&#39;: 9&#125;</code></td></tr></tbody></table><p>那么，在给定文件名的情况下，怎么用大语言模型（LLM，以下简称大模型） + TMDB API来完成媒体信息的解析工作呢？这篇文章应运而生。</p><blockquote><p>当然，解析媒体信息 + 整理媒体文件（或者说媒体文件刮削），已经有很多现成的解决方案，如<code>nas-tools</code>、<code>jellyfin</code>，笔者更多是想探索大模型的可能性。</p></blockquote><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">&quot;太长不看&quot;</span>的总结：<br>- qwen-plus-latest <span class="hljs-params">(qwen <span class="hljs-number">2.5</span>)</span> 强于 deepseek-chat <span class="hljs-params">(v2.<span class="hljs-number">5</span>)</span>，gpt-4o-mini/gemini-1.<span class="hljs-number">5</span>-flash落后<br>- Tools<span class="hljs-params">(Function Calling)</span>在机器间交互不好用，笔者的JSON调用模式效率&amp;效果更优。<br></code></pre></td></tr></table></figure><h1 id="二、方案选择"><a href="#二、方案选择" class="headerlink" title="二、方案选择"></a>二、方案选择</h1><p>从<code>文件名</code>到<code>媒体信息</code>，大致分为这几步：</p><ol><li><p>从文件名中解析关键字，去tmdb搜索，获得标题、分类信息；</p></li><li><p>如果是电视剧且标题里没有季度编号，则需要去tmdb查询季度信息，确定这是第几季；</p></li><li><p>如果是电视剧，还需要从标题里解析这是该季度的第几集。</p></li></ol><p>按这个思路，大概有3种解决方案：</p><h2 id="1-代码控制流程"><a href="#1-代码控制流程" class="headerlink" title="1. 代码控制流程"></a>1. 代码控制流程</h2><p>调用tmdb api等步骤由代码控制，大模型只负责</p><ul><li>从文件名中解析出标题、季度信息、集数信息；</li><li>当tmdb搜出多个结果时，选择最匹配的一个；</li><li>当tmdb查询到季度信息后，选择最匹配的一个。</li></ul><p>代码开发量较大，没有用到大模型的规划能力。不考虑该方案。</p><h2 id="2-定义函数-Tools调用"><a href="#2-定义函数-Tools调用" class="headerlink" title="2. 定义函数+Tools调用"></a>2. 定义函数+Tools调用</h2><p>我们可以定义一些函数：搜索tmdb的函数、查询tv季度信息的函数，传入文件名后让大模型判断需要调用哪些函数，最终得到媒体信息。</p><p>OpenAI在2023年6月发布了<a href="https://platform.openai.com/docs/guides/function-calling">Function Calling</a>，随后各家大模型厂商开始跟进。目前该功能逐渐改名为<code>Tools</code>。代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">tools = [<br>    &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>        <span class="hljs-string">&quot;function&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;get_delivery_date&quot;</span>,<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Get the delivery date for a customer&#x27;s order. Call this whenever you need to know the delivery date, for example when a customer asks &#x27;Where is my package&#x27;&quot;</span>,<br>            <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>                <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;order_id&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;The customer&#x27;s order ID.&quot;</span>,<br>                    &#125;,<br>                &#125;,<br>                <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;order_id&quot;</span>],<br>                <span class="hljs-string">&quot;additionalProperties&quot;</span>: <span class="hljs-literal">False</span>,<br>            &#125;,<br>        &#125;<br>    &#125;<br>]<br><br>messages = [<br>    &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;You are a helpful customer support assistant. Use the supplied tools to assist the user.&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;Hi, can you tell me the delivery date for my order?&quot;</span>&#125;<br>]<br><br>response = openai.chat.completions.create(<br>    model=<span class="hljs-string">&quot;gpt-4o&quot;</span>,<br>    messages=messages,<br>    tools=tools,<br>)<br></code></pre></td></tr></table></figure><h2 id="3-定义函数-JSON调用"><a href="#3-定义函数-JSON调用" class="headerlink" title="3. 定义函数+JSON调用"></a>3. 定义函数+JSON调用</h2><p>Tools的核心逻辑是将函数声明&#x2F;函数调用放到一个单独的字段来传递。优点是在人机对话时能隐藏函数调用的细节；缺点是对模型能力（更直接地说是训练&#x2F;微调的数据集）有更高要求。笔者主要是API场景，更喜欢将函数声明&#x2F;函数调用放到message记录内，对模型兼容性更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">functions = &#123;<br>    <span class="hljs-string">&quot;tmdb_search&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;keyword&quot;</span>: <span class="hljs-string">&quot;string, tmdb search keyword, not include year&quot;</span>,<br>    &#125;,<br>    <span class="hljs-string">&quot;tv_season_info&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;tmdb_id&quot;</span>: <span class="hljs-string">&quot;int, tmdb tv id&quot;</span>,<br>    &#125;,<br>    <span class="hljs-string">&quot;done&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;string, media title&quot;</span>,<br>        <span class="hljs-string">&quot;genre&quot;</span>: <span class="hljs-string">&quot;string, media genre&quot;</span>,<br>        <span class="hljs-string">&quot;year&quot;</span>: <span class="hljs-string">&quot;int, media year&quot;</span>,<br>        <span class="hljs-string">&quot;tv_season_num&quot;</span>: <span class="hljs-string">&quot;int, tv season number&quot;</span>,<br>        <span class="hljs-string">&quot;tv_episode&quot;</span>: <span class="hljs-string">&quot;int, tv episode number&quot;</span>,<br>    &#125;,<br>&#125;<br>payload = &#123;<br>    <span class="hljs-string">&quot;model&quot;</span>: llm_model,<br>    <span class="hljs-string">&quot;messages&quot;</span>: [<br>        &#123;<br>            <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&#x27;你是一个函数调用器，擅长基于上下文，返回JSON格式的调用信息：`&#123;&quot;function&quot;:&quot;xxx&quot;,&quot;arguments&quot;:&#123;&quot;key&quot;: &quot;value&quot;&#125;&#125;`。&#x27;</span><br>            + <span class="hljs-string">&quot;我会提供一个文件名，你的目标是获取媒体文件的title, genre, year, tv_season_num, tv_episode，并调用done函数。你可以调用tmdb_search和tv_season_info函数来获取tmdb信息。&quot;</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: json.dumps(functions, ensure_ascii=<span class="hljs-literal">False</span>),<br>        &#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: filename&#125;,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h1><h2 id="1-定义函数"><a href="#1-定义函数" class="headerlink" title="1. 定义函数"></a>1. 定义函数</h2><p>首先定义两个函数：搜索tmdb、查询季度信息。函数都很简单，调用tmdb API + 将API返回值转成想要的格式。</p><p>注意点：由于tmdb的search api，关键字参数不支持传入年份，所以在将函数定义传给大模型时需要强调这一点（见下文）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python">tmdb_api_key = os.environ[<span class="hljs-string">&quot;tmdb_api_key&quot;</span>]<br>tmdb_hds = &#123;<br>    <span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">&quot;Bearer &quot;</span> + tmdb_api_key,<br>&#125;<br>session = requests_cache.CachedSession()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tmdb_search</span>(<span class="hljs-params">keyword: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    url = <span class="hljs-string">&quot;https://api.themoviedb.org/3/search/multi&quot;</span><br>    params = &#123;<br>        <span class="hljs-string">&quot;query&quot;</span>: keyword,<br>        <span class="hljs-string">&quot;include_adult&quot;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;zh&quot;</span>,<br>    &#125;<br>    resp = session.get(url, headers=tmdb_hds, params=params, timeout=<span class="hljs-number">10</span>)<br>    resp.raise_for_status()<br>    jr = resp.json()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> jr[<span class="hljs-string">&quot;results&quot;</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;not found&quot;</span><br><br>    choices = []<br>    <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> jr[<span class="hljs-string">&quot;results&quot;</span>]:<br>        info = []<br>        release_year = res.get(<span class="hljs-string">&quot;release_date&quot;</span>, res.get(<span class="hljs-string">&quot;first_air_date&quot;</span>))[:<span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> release_year:<br>            <span class="hljs-keyword">continue</span><br>        media_type = res[<span class="hljs-string">&quot;media_type&quot;</span>]<br>        orig_lang = res.get(<span class="hljs-string">&quot;original_language&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        anime_genre = <span class="hljs-number">16</span><br>        <span class="hljs-keyword">if</span> media_type == <span class="hljs-string">&quot;tv&quot;</span> <span class="hljs-keyword">and</span> orig_lang == <span class="hljs-string">&quot;ja&quot;</span> <span class="hljs-keyword">and</span> anime_genre <span class="hljs-keyword">in</span> res[<span class="hljs-string">&quot;genre_ids&quot;</span>]:<br>            media_type = <span class="hljs-string">&quot;tv(anime)&quot;</span><br>        info.append(<span class="hljs-string">f&#x27;name: <span class="hljs-subst">&#123;res.get(<span class="hljs-string">&quot;name&quot;</span>, res.get(<span class="hljs-string">&quot;title&quot;</span>))&#125;</span>&#x27;</span>)<br>        info.append(<span class="hljs-string">f&quot;year: <span class="hljs-subst">&#123;release_year&#125;</span>&quot;</span>)<br>        info.append(<span class="hljs-string">f&quot;genre: <span class="hljs-subst">&#123;media_type&#125;</span>&quot;</span>)<br>        info.append(<span class="hljs-string">f&quot;id: <span class="hljs-subst">&#123;res[<span class="hljs-string">&#x27;id&#x27;</span>]&#125;</span>&quot;</span>)<br>        info.append(<span class="hljs-string">f&quot;popularity: <span class="hljs-subst">&#123;res[<span class="hljs-string">&#x27;popularity&#x27;</span>]&#125;</span>&quot;</span>)<br>        choices.append(<span class="hljs-string">&quot;\n&quot;</span>.join(info))<br>    choices_text = <span class="hljs-string">&quot;\n\n&quot;</span>.join(choices)<br>    <span class="hljs-keyword">return</span> choices_text<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tv_season_info</span>(<span class="hljs-params">tmdb_id: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    url = <span class="hljs-string">f&quot;https://api.themoviedb.org/3/tv/<span class="hljs-subst">&#123;tmdb_id&#125;</span>?language=zh&quot;</span><br>    resp = session.get(url, headers=tmdb_hds, timeout=<span class="hljs-number">10</span>)<br>    resp.raise_for_status()<br>    jr = resp.json()<br>    seasons = resp.json()[<span class="hljs-string">&quot;seasons&quot;</span>]<br>    choices = [<span class="hljs-string">f&quot;title: <span class="hljs-subst">&#123;jr[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>]<br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> seasons:<br>        info = []<br>        info.append(<span class="hljs-string">f&quot;tv_season_num: <span class="hljs-subst">&#123;s[<span class="hljs-string">&#x27;season_number&#x27;</span>]&#125;</span>&quot;</span>)<br>        info.append(<span class="hljs-string">f&quot;name: <span class="hljs-subst">&#123;s[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)<br>        choices.append(<span class="hljs-string">&quot;, &quot;</span>.join(info))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(choices)<br></code></pre></td></tr></table></figure><h2 id="2-Tools调用"><a href="#2-Tools调用" class="headerlink" title="2. Tools调用"></a>2. Tools调用</h2><p>Tools算是一个标准格式，笔者参考Deepseek的文档（<a href="https://platform.deepseek.com/api-docs/zh-cn/function_calling/">Function Calling | DeepSeek API Docs</a>）编写了如下代码。考虑到用JSON格式返回会降低大模型的推理能力，所以笔者这里先用自然语言和大模型交互，有结果后再调用一次大模型将媒体信息提取为JSON，用消耗更多token换取准确率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_tools</span>(<span class="hljs-params">filename: <span class="hljs-built_in">str</span></span>):<br>    token_usage = defaultdict(<span class="hljs-built_in">int</span>)<br>    payload = &#123;<br>        <span class="hljs-string">&quot;model&quot;</span>: llm_model,<br>        <span class="hljs-string">&quot;messages&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>                <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;你是一个敏锐的媒体文件整理员，能通过查询TMDB来获取媒体文件的详细信息，包括分类、标题、年份、tv季度、tv集数。&quot;</span>,<br>            &#125;,<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: filename&#125;,<br>        ],<br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>                <span class="hljs-string">&quot;function&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;tmdb_search&quot;</span>,<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;search media info from TMDB&quot;</span>,<br>                    <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>                        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>                            <span class="hljs-string">&quot;keyword&quot;</span>: &#123;<br>                                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                                <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;search keyword, not include year&quot;</span>,<br>                            &#125;<br>                        &#125;,<br>                        <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;keyword&quot;</span>],<br>                    &#125;,<br>                &#125;,<br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>                <span class="hljs-string">&quot;function&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;tv_season_info&quot;</span>,<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;get tv season info from TMDB&quot;</span>,<br>                    <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>                        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>                            <span class="hljs-string">&quot;tmdb_id&quot;</span>: &#123;<br>                                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                                <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;tmdb tv id&quot;</span>,<br>                            &#125;,<br>                        &#125;,<br>                        <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;tmdb_id&quot;</span>],<br>                    &#125;,<br>                &#125;,<br>            &#125;,<br>        ],<br>    &#125;<br>    results: t.<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = [filename]<br>    <span class="hljs-comment"># results: t.List[str] = []</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        resp = session.post(llm_url, json=payload, timeout=<span class="hljs-number">30</span>)<br>        resp.raise_for_status()<br>        jr = resp.json()<br>        message = jr[<span class="hljs-string">&quot;choices&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;message&quot;</span>]<br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> jr[<span class="hljs-string">&quot;usage&quot;</span>].items():<br>            token_usage[k] += v<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;message&quot;</span>, message)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message[<span class="hljs-string">&quot;tool_calls&quot;</span>]:<br>            results.append(message[<span class="hljs-string">&quot;content&quot;</span>])<br>            <span class="hljs-keyword">break</span><br>        payload[<span class="hljs-string">&quot;messages&quot;</span>].append(message)<br>        <span class="hljs-keyword">for</span> tool_call <span class="hljs-keyword">in</span> message[<span class="hljs-string">&quot;tool_calls&quot;</span>]:<br>            info = tool_call[<span class="hljs-string">&quot;function&quot;</span>]<br>            args = info[<span class="hljs-string">&quot;arguments&quot;</span>]<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(args, <span class="hljs-built_in">str</span>):<br>                args = json.loads(args)<br>            <span class="hljs-keyword">if</span> info[<span class="hljs-string">&quot;name&quot;</span>] == <span class="hljs-string">&quot;tmdb_search&quot;</span>:<br>                res = tmdb_search(**args)<br>            <span class="hljs-keyword">elif</span> info[<span class="hljs-string">&quot;name&quot;</span>] == <span class="hljs-string">&quot;tv_season_info&quot;</span>:<br>                res = tv_season_info(**args)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;unknown function: <span class="hljs-subst">&#123;info[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tool call&quot;</span>, info[<span class="hljs-string">&quot;name&quot;</span>], res)<br>            results.append(res)<br>            payload[<span class="hljs-string">&quot;messages&quot;</span>].append(<br>                &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;tool&quot;</span>, <span class="hljs-string">&quot;tool_call_id&quot;</span>: tool_call[<span class="hljs-string">&quot;id&quot;</span>], <span class="hljs-string">&quot;content&quot;</span>: res&#125;<br>            )<br><br>    payload = &#123;<br>        <span class="hljs-string">&quot;model&quot;</span>: llm_model,<br>        <span class="hljs-string">&quot;messages&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>                <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;你是一个文本解析器，擅长从文本中提取关键信息，并用JSON格式输出。你需要提取的信息为：title(str), genre(str), year(int), tv_season_num(int), tv_episode(int)&quot;</span>,<br>            &#125;,<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: json.dumps(results, ensure_ascii=<span class="hljs-literal">False</span>)&#125;,<br>        ],<br>    &#125;<br>    resp = session.post(llm_url, json=payload, timeout=<span class="hljs-number">30</span>)<br>    resp.raise_for_status()<br>    jr = resp.json()<br>    resp_text: <span class="hljs-built_in">str</span> = jr[<span class="hljs-string">&quot;choices&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;message&quot;</span>][<span class="hljs-string">&quot;content&quot;</span>]<br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> jr[<span class="hljs-string">&quot;usage&quot;</span>].items():<br>        token_usage[k] += v<br><br>    resp_text = resp_text[resp_text.find(<span class="hljs-string">&quot;&#123;&quot;</span>) :]<br>    resp_text = resp_text[: resp_text.rfind(<span class="hljs-string">&quot;&#125;&quot;</span>) + <span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(resp_text)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;usage&quot;</span>, token_usage)<br></code></pre></td></tr></table></figure><h2 id="3-JSON调用"><a href="#3-JSON调用" class="headerlink" title="3. JSON调用"></a>3. JSON调用</h2><p>JSON调用的版本相比Tools调用的版本更简洁，主要是：</p><ol><li>传给大模型的函数定义，从结构上来说更简洁</li><li>大模型直接返回JSON格式的函数调用，解析起来更简单</li><li>大模型始终输出JSON，不需要在结束后再解析一次。</li></ol><p>关键点：函数的返回值在传给大模型之前，最好加上前缀强调来提升准确率：<code>res = f&quot;调用&#123;jr[&#39;function&#39;]&#125;的返回值：\n&#123;res&#125;&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_clean_json</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    text = text[text.find(<span class="hljs-string">&quot;&#123;&quot;</span>) :]<br>    text = text[: text.rfind(<span class="hljs-string">&quot;&#125;&quot;</span>) + <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> text<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_fc</span>(<span class="hljs-params">filename: <span class="hljs-built_in">str</span></span>):<br>    usage = defaultdict(<span class="hljs-built_in">int</span>)<br>    functions = &#123;<br>        <span class="hljs-string">&quot;tmdb_search&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;keyword&quot;</span>: <span class="hljs-string">&quot;string, tmdb search keyword, not include year&quot;</span>,<br>        &#125;,<br>        <span class="hljs-string">&quot;tv_season_info&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;tmdb_id&quot;</span>: <span class="hljs-string">&quot;int, tmdb tv id&quot;</span>,<br>        &#125;,<br>        <span class="hljs-string">&quot;done&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;string, media title&quot;</span>,<br>            <span class="hljs-string">&quot;genre&quot;</span>: <span class="hljs-string">&quot;string, media genre&quot;</span>,<br>            <span class="hljs-string">&quot;year&quot;</span>: <span class="hljs-string">&quot;int, media year&quot;</span>,<br>            <span class="hljs-string">&quot;tv_season_num&quot;</span>: <span class="hljs-string">&quot;int, tv season number&quot;</span>,<br>            <span class="hljs-string">&quot;tv_episode&quot;</span>: <span class="hljs-string">&quot;int, tv episode number&quot;</span>,<br>        &#125;,<br>    &#125;<br>    payload = &#123;<br>        <span class="hljs-string">&quot;model&quot;</span>: llm_model,<br>        <span class="hljs-string">&quot;messages&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>                <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&#x27;你是一个函数调用器，擅长基于上下文，返回JSON格式的调用信息：`&#123;&quot;function&quot;:&quot;xxx&quot;,&quot;arguments&quot;:&#123;&quot;key&quot;: &quot;value&quot;&#125;&#125;`。&#x27;</span><br>                + <span class="hljs-string">&quot;我会提供一个文件名，你的目标是获取媒体文件的title, genre, year, tv_season_num, tv_episode，并调用done函数。你可以调用tmdb_search和tv_season_info函数来获取tmdb信息。&quot;</span>,<br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>                <span class="hljs-string">&quot;content&quot;</span>: json.dumps(functions, ensure_ascii=<span class="hljs-literal">False</span>),<br>            &#125;,<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: filename&#125;,<br>        ],<br>    &#125;<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        resp = session.post(llm_url, json=payload, timeout=<span class="hljs-number">30</span>)<br>        resp.raise_for_status()<br>        jr = resp.json()<br>        message = jr[<span class="hljs-string">&quot;choices&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;message&quot;</span>]<br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> jr[<span class="hljs-string">&quot;usage&quot;</span>].items():<br>            usage[k] += v<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;message&quot;</span>, message)<br>        jr = json.loads(get_clean_json(message[<span class="hljs-string">&quot;content&quot;</span>]))<br>        <span class="hljs-keyword">if</span> jr[<span class="hljs-string">&quot;function&quot;</span>] == <span class="hljs-string">&quot;tmdb_search&quot;</span>:<br>            res = tmdb_search(jr[<span class="hljs-string">&quot;arguments&quot;</span>][<span class="hljs-string">&quot;keyword&quot;</span>])<br>        <span class="hljs-keyword">elif</span> jr[<span class="hljs-string">&quot;function&quot;</span>] == <span class="hljs-string">&quot;tv_season_info&quot;</span>:<br>            res = tv_season_info(jr[<span class="hljs-string">&quot;arguments&quot;</span>][<span class="hljs-string">&quot;tmdb_id&quot;</span>])<br>        <span class="hljs-keyword">elif</span> jr[<span class="hljs-string">&quot;function&quot;</span>] == <span class="hljs-string">&quot;done&quot;</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;unknown function: <span class="hljs-subst">&#123;jr[<span class="hljs-string">&#x27;function&#x27;</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;function call&quot;</span>, jr[<span class="hljs-string">&quot;function&quot;</span>], res)<br>        res = <span class="hljs-string">f&quot;调用<span class="hljs-subst">&#123;jr[<span class="hljs-string">&#x27;function&#x27;</span>]&#125;</span>的返回值：\n<span class="hljs-subst">&#123;res&#125;</span>&quot;</span><br>        payload[<span class="hljs-string">&quot;messages&quot;</span>].append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: res&#125;)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;failed to get &quot;done&quot; function call&#x27;</span>)<br>        jr = &#123;&#125;<br><br>    <span class="hljs-keyword">if</span> jr:<br>        <span class="hljs-built_in">print</span>(jr[<span class="hljs-string">&quot;arguments&quot;</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;usage&quot;</span>, usage)<br></code></pre></td></tr></table></figure><h1 id="四、测试结果"><a href="#四、测试结果" class="headerlink" title="四、测试结果"></a>四、测试结果</h1><p>测试目标是让大模型输出格式化的媒体信息：</p><table><thead><tr><th>文件名</th><th>格式化信息</th></tr></thead><tbody><tr><td>Young.Woman.and.the.Sea.2024.2160p.DSNP.WEB-DL.H265.HDR.DDP5.1.Atmos-ADWeb.mkv</td><td><code>&#123;&#39;title&#39;: &#39;泳者之心&#39;, &#39;genre&#39;: &#39;movie&#39;, &#39;year&#39;: 2024&#125;</code></td></tr><tr><td>【動畫瘋】物語系列 第外季＆第怪季[9][1080P].mp4</td><td><code>&#123;&#39;title&#39;: &#39;物语系列&#39;, &#39;genre&#39;: &#39;tv(anime)&#39;, &#39;year&#39;: 2009, &#39;tv_season_num&#39;: 5, &#39;tv_episode&#39;: 9&#125;</code></td></tr></tbody></table><p>笔者选用了四个低价的大模型来测试，最贵是的gpt-4o-mini，输出$0.6&#x2F;1M tokens：</p><ul><li>deepseek-chat的api (v2.5 09&#x2F;05更新)，低价+开源</li><li>qwen-plus-latest的api (09&#x2F;19更新)，低价+基于开源的qwen 2.5 72B</li><li>gpt-4o-mini的api (07&#x2F;18更新)，低价+国际大厂</li><li>gemini-1.5-flash (04&#x2F;13更新)，低价+国际大厂</li></ul><table><thead><tr><th>文件名</th><th>方案</th><th>模型</th><th>token消耗</th><th>结果</th></tr></thead><tbody><tr><td>Young.Woman.and.the.Sea.2024.2160p.DSNP.WEB-DL.H265.HDR.DDP5.1.Atmos-ADWeb.mkv</td><td>Tools调用</td><td>deepseek-chat</td><td>1141</td><td>成功</td></tr><tr><td>同上</td><td>Tools调用</td><td>qwen-plus-latest</td><td>1481</td><td>部分成功，标题解析成了<code>泳者之心 (Young Woman and the Sea)</code></td></tr><tr><td>同上</td><td>Tools调用</td><td>gpt-4o-mini</td><td>747</td><td>成功</td></tr><tr><td>同上</td><td>Tools调用</td><td>gemini-1.5-flash</td><td>610</td><td>部分成功，标题解析成了<code>Young.Woman.and.the.Sea</code></td></tr><tr><td>【動畫瘋】物語系列 第外季＆第怪季[9][1080P].mp4</td><td>Tools调用</td><td>deepseek-chat</td><td>2821</td><td>成功，但不稳定（超时&#x2F;第二轮时无法触发tools调用等）</td></tr><tr><td>同上</td><td>Tools调用</td><td>qwen-plus-latest</td><td>1856</td><td>成功</td></tr><tr><td>同上</td><td>Tools调用</td><td>gpt-4o-mini</td><td>1667</td><td>部分成功，未解析出第几季&#x2F;第几集</td></tr><tr><td>同上</td><td>Tools调用</td><td>gemini-1.5-flash</td><td>1265</td><td>失败，tmdb api调用成功但结果解析很糟糕</td></tr><tr><td>Young.Woman.and.the.Sea.2024.2160p.DSNP.WEB-DL.H265.HDR.DDP5.1.Atmos-ADWeb.mkv</td><td>JSON调用</td><td>deepseek-chat</td><td>652</td><td>成功</td></tr><tr><td>同上</td><td>JSON调用</td><td>qwen-plus-latest</td><td>575</td><td>成功</td></tr><tr><td>同上</td><td>JSON调用</td><td>gpt-4o-mini</td><td>559</td><td>成功</td></tr><tr><td>同上</td><td>JSON调用</td><td>gemini-1.5-flash</td><td>587</td><td>成功</td></tr><tr><td>【動畫瘋】物語系列 第外季＆第怪季[9][1080P].mp4</td><td>JSON调用</td><td>deepseek-chat</td><td>1158</td><td>成功</td></tr><tr><td>同上</td><td>JSON调用</td><td>qwen-plus-latest</td><td>942</td><td>成功</td></tr><tr><td>同上</td><td>JSON调用</td><td>gpt-4o-mini</td><td>540</td><td>部分成功，未解析出第几季&#x2F;第几集</td></tr><tr><td>同上</td><td>JSON调用</td><td>gemini-1.5-flash</td><td>262</td><td>失败，直接没有调用tmdb api</td></tr></tbody></table><h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>从大模型对比的角度来看：</p><ul><li><p><code>qwen-plus-latest</code>表现最好。价格比<code>deepseek-chat</code>稍低，但速度更快、效果更好。充分体现了最新开源的qwen 2.5家族的实力。</p></li><li><p><code>deepseek-chat</code>在Tools调用场景发挥不稳定，比如解析<code>【動畫瘋】物語系列 第外季＆第怪季[9][1080P].mp4</code>时，虽然知道要调用函数获取季度信息，但却没有按Tools格式输出，导致后续无法衔接：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>&#x27;content&#x27;<span class="hljs-punctuation">:</span> &#x27;从搜索结果来看，有两个不同的条目：一个是“物語系列”（<span class="hljs-number">2009</span>年，TV动画），另一个是“春风物语”（<span class="hljs-number">2023</span>年， 电影）。我们需要的是“物語系列”的信息。\n\n接下来，我们需要获取“物語系列”的详细信息，特别是“第外季”和“第怪季”的相关信息。由于这些季数可能不是标准的季数，我们需要进一步查询以确认。\n\n请调用 `tv_season_info` 函数，传入 `tmdb_id` 为 `<span class="hljs-number">46195</span>`， 以获取“物語系列”的季数信息。&#x27;<span class="hljs-punctuation">,</span> &#x27;role&#x27;<span class="hljs-punctuation">:</span> &#x27;assistant&#x27;<span class="hljs-punctuation">,</span> &#x27;tool_calls&#x27;<span class="hljs-punctuation">:</span> None<span class="hljs-punctuation">,</span> &#x27;function_call&#x27;<span class="hljs-punctuation">:</span> None<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>gpt-4o-mini</code>表现一般，价格最贵，但容易忽略TV作品的第几季&#x2F;第几集。</p></li><li><p><code>gemini-1.5-flash</code>价格最低，表现也最差。</p></li></ul><p>从Tools使用的角度来看：</p><ul><li>Tools诞生的场景是：在聊天机器人对话过程中，兼顾用户体验和外部函数调用。但在API场景中，“兼顾用户体验”的部分成了累赘。</li><li>笔者设计的JSON调用模式，对机器间交互设计，在外部函数调用方面比Tools方式效率更高、准确度更高。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>大模型</tag>
      
      <tag>媒体刮削</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自建Docker Hub镜像服务</title>
    <link href="/2024/06/08/self-host-docker-hub-mirror/"/>
    <url>/2024/06/08/self-host-docker-hub-mirror/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com//picgo/image-20240608093740935.png"></p><p>最近在某些神秘力量的影响下，SJTUG&#x2F;USTC等知名Docker Hub镜像站陆续停止服务。</p><p>文本使用<a href="https://distribution.github.io/distribution">CNCF Distribution</a>的registry项目，只需要运行一个Docker容器，就可以自建Docker Hub镜像服务。</p><h1 id="2-所需条件"><a href="#2-所需条件" class="headerlink" title="2. 所需条件"></a>2. 所需条件</h1><ul><li>可运行Docker容器的服务器</li><li>可以访问docker.io的HTTP代理（如果服务器无法直接访问的话）</li></ul><h1 id="3-生成SSL证书"><a href="#3-生成SSL证书" class="headerlink" title="3. 生成SSL证书"></a>3. 生成SSL证书</h1><p>registry默认使用HTTP协议对外提供服务，使用HTTPS更安全&amp;更通用。笔者生成自签名证书的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 \<br>  -nodes -keyout example.com.key -out example.com.crt -subj &quot;/CN=example.com&quot; \<br>  -addext &quot;subjectAltName=DNS:example.com,DNS:*.example.com,IP:100.x.x.x,IP:192.168.1.30&quot;<br></code></pre></td></tr></table></figure><h1 id="4-启动registry服务"><a href="#4-启动registry服务" class="headerlink" title="4. 启动registry服务"></a>4. 启动registry服务</h1><p>准备好registry的存储目录，放入上一步生成的证书文件。然后编写如下docker-compose文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry:2</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;host&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">REGISTRY_HTTP_ADDR:</span> <span class="hljs-string">&quot;0.0.0.0:5000&quot;</span><br>      <span class="hljs-attr">REGISTRY_HTTP_TLS_KEY:</span> <span class="hljs-string">&quot;/var/lib/registry/example.com.key&quot;</span><br>      <span class="hljs-attr">REGISTRY_HTTP_TLS_CERTIFICATE:</span> <span class="hljs-string">&quot;/var/lib/registry/example.com.crt&quot;</span><br>      <span class="hljs-attr">REGISTRY_PROXY_REMOTEURL:</span> <span class="hljs-string">&quot;https://registry-1.docker.io&quot;</span> <span class="hljs-comment"># 指定上游仓库地址</span><br>      <span class="hljs-attr">HTTPS_PROXY:</span> <span class="hljs-string">&quot;&#123;HTTP代理地址&#125;&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/&#123;你的路径&#125;/registry:/var/lib/registry&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/&#123;你的路径&#125;/registry_config.yml:/etc/docker/registry/config.yml&quot;</span><br></code></pre></td></tr></table></figure><p>用docker-compose运行容器即可启动服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose -f registry.yml up -d<br></code></pre></td></tr></table></figure><p>此时registry会在笔者的服务器上，也就是<code>https://192.168.1.30:5000</code>提供服务。</p><h1 id="5-客户端使用"><a href="#5-客户端使用" class="headerlink" title="5. 客户端使用"></a>5. 客户端使用</h1><h2 id="5-1-信任SSL证书"><a href="#5-1-信任SSL证书" class="headerlink" title="5.1 信任SSL证书"></a>5.1 信任SSL证书</h2><p>由于registry使用的是自签名SSL证书，客户端要想成功拉取镜像需要先信任该证书。方式有两种，第一种是将证书加入客户端的的系统信任列表（推荐）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /$&#123;你的路径&#125;/example.com.crt /usr/share/ca-certificates<br>sudo dpkg-reconfigure ca-certificates<br></code></pre></td></tr></table></figure><p>然后重启Docker&#x2F;K3S等需要拉取镜像的服务；第二种是让Docker拉取镜像时跳过证书校验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><br><span class="hljs-punctuation">&#123;</span><br>  ...<br>  <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;192.168.1.30:5000&quot;</span><span class="hljs-punctuation">]</span><br>  ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后重启docker服务。</p><p>信任完证书后，此时就可以拉取Docker Hub上的镜像看到效果了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 192.168.1.30:5000/grafana/grafana:main<br></code></pre></td></tr></table></figure><h2 id="5-2-设置Docker镜像源"><a href="#5-2-设置Docker镜像源" class="headerlink" title="5.2 设置Docker镜像源"></a>5.2 设置Docker镜像源</h2><p>同样是编辑<code>/etc/docker/daemon.json</code>，将上述registry服务作为Docker镜像源：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  ...<br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://192.168.1.30:5000&quot;</span><br>  <span class="hljs-punctuation">]</span><br>  ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后重启Docker服务，此时就可以快速拉取镜像了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull grafana/grafana:main<br></code></pre></td></tr></table></figure><p>enjoy!</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多机K3S集群搭建踩坑记</title>
    <link href="/2024/06/07/multi-node-k3s-cluster/"/>
    <url>/2024/06/07/multi-node-k3s-cluster/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>由于笔者需要部署一些计算服务并实现扩展灵活、可用性高，所以决定用K8S体系来代替原有的Docker部署。K8S对于个人来说维护成本太高了，所以笔者选用了更轻量的K3S。</p><p>本篇文章记录的是笔者搭建这个K3S集群的过程。</p><h1 id="2-离线安装K3S服务"><a href="#2-离线安装K3S服务" class="headerlink" title="2. 离线安装K3S服务"></a>2. 离线安装K3S服务</h1><p>K3S的<a href="https://docs.k3s.io/zh/quick-start">快速入门指南</a>给出了简洁的安装脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sfL https://get.k3s.io | sh -<br><span class="hljs-meta prompt_"># </span><span class="language-bash">国内加速脚本👇</span><br>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -<br></code></pre></td></tr></table></figure><p>但由于国内愈加恶劣的网络环境，即使这个脚本成功安装了K3S服务，也无法成功启动：K3S所需的pause镜像无法从docker.io上拉取下来。所以笔者选择离线安装K3S。</p><p>参考文档：<a href="https://docs.k3s.io/zh/installation/airgap">Air-Gap Install | K3s</a></p><h2 id="2-1-下载所需文件"><a href="#2-1-下载所需文件" class="headerlink" title="2.1 下载所需文件"></a>2.1 下载所需文件</h2><p>在K3S的<a href="https://github.com/k3s-io/k3s/releases">Releases</a>页可以下载到我们所需的文件：k3s和k3s-airgap-images-amd64.tar.gz。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com//picgo/image-20240607082747333.png" alt="image-20240607082747333"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget &lt;k3s链接&gt;<br>wget &lt;k3s镜像链接&gt;<br>chmod +x k3s<br></code></pre></td></tr></table></figure><p>本来还需要下载<code>k3s-install.sh</code>，但由于笔者的安装环境可以顺畅从rancher.cn获取该文件，所以笔者没有下载。</p><h2 id="2-2-K3S主节点安装服务"><a href="#2-2-K3S主节点安装服务" class="headerlink" title="2.2 K3S主节点安装服务"></a>2.2 K3S主节点安装服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">准备文件</span><br>sudo mkdir -p /var/lib/rancher/k3s/agent/images<br>sudo cp ./k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images<br>sudo cp ./k3s /usr/local/bin/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开始安装</span><br>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_SKIP_DOWNLOAD=true sh -<br></code></pre></td></tr></table></figure><h2 id="2-3-K3S从节点安装服务"><a href="#2-3-K3S从节点安装服务" class="headerlink" title="2.3 K3S从节点安装服务"></a>2.3 K3S从节点安装服务</h2><p>流程和主节点相同，只是需要先从主节点上获取K3S TOKEN：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cat /var/lib/rancher/k3s/server/token<br></code></pre></td></tr></table></figure><p>然后在从节点安装是加入环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">准备文件</span><br>sudo mkdir -p /var/lib/rancher/k3s/agent/images<br>sudo cp ./k3s-airgap-images-amd64.tar.gz /var/lib/rancher/k3s/agent/images<br>sudo cp ./k3s /usr/local/bin/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开始安装</span><br>export K3S_URL=&quot;https://&lt;主节点IP&gt;:6443&quot;<br>export K3S_TOKEN=&quot;&lt;上一步获取到的K3S TOKEN&gt;&quot;<br>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_SKIP_DOWNLOAD=true sh -<br></code></pre></td></tr></table></figure><h1 id="3-配置K3S服务"><a href="#3-配置K3S服务" class="headerlink" title="3. 配置K3S服务"></a>3. 配置K3S服务</h1><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com//picgo/image-20240607085753410.png" alt="image-20240607085753410"></p><p>上图是笔者的网络环境，每个节点有两张网卡，通过网段为<code>100.x.x.x</code>的网卡互相联通。</p><p>在主节点和从节点安装完K3S服务后，笔者发现从节点无法成功启动K3S服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo journalctl -u k3s-agent.service</span><br>...<br>Starting k3s agent v1.29.5+k3s1 (4e53a323)<br>Adding server to load balancer k3s-agent-load-balancer: 100.x.x.x:6443<br>Running load balancer k3s-agent-load-balancer 127.0.0.1:6444 -&gt; [100.x.x.x:6443] [default: 100.x.x.x:6443]<br>...<br>Getting list of apiserver endpoints from server<br>Updated load balancer k3s-agent-load-balancer default server address -&gt; 192.x.x.x:6443<br>Adding server to load balancer k3s-agent-load-balancer: 192.x.x.x:6443<br>Removing server from load balancer k3s-agent-load-balancer: 100.x.x.x:6443<br>...<br>error=&quot;dial tcp 192.x.x.x:6443: connect: connection timed out&quot;<br></code></pre></td></tr></table></figure><p>原来，即使在从节点安装K3S时已经指定了K3S_URL为<code>100.x.x.x</code>，但K3S Agent在连接上主节点后依然选择连接<code>192.x.x.x</code>，但从节点实际上无法连接这个IP。为此，我们需要强制指定节点IP。</p><p>参考：<a href="https://docs.k3s.io/zh/cli/server">server | K3s</a>、<a href="https://docs.k3s.io/zh/cli/agent">agent | K3s</a></p><h2 id="3-1-修改K3S服务文件"><a href="#3-1-修改K3S服务文件" class="headerlink" title="3.1 修改K3S服务文件"></a>3.1 修改K3S服务文件</h2><p>在主节点上修改配置<code>/etc/systemd/system/k3s.service</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">...<br><span class="hljs-attr">ExecStart</span>=/usr/local/bin/k3s \<br>    server --node-ip &quot;100.x.x.x&quot; --node-external-ip &quot;100.x.x.x&quot; \<br></code></pre></td></tr></table></figure><p>在从节点上修改配置<code>/etc/systemd/system/k3s-agent.service</code>:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ExecStart</span>=/usr/local/bin/k3s \<br>    agent --node-ip &quot;100.x.x.x&quot; --node-external-ip &quot;100.x.x.x&quot; \<br></code></pre></td></tr></table></figure><p>然后各自重启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl daemon-reload<br>sudo systemctl restart k3s # 主节点<br>sudo systemctl restart k3s-agent # 从节点<br></code></pre></td></tr></table></figure><p>现在从节点正常加入集群了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo kubectl get nodes<br>NAME      STATUS   ROLES                  AGE   VERSION<br>xxxxxxx   Ready    &lt;none&gt;                 10m   v1.30.1+k3s1<br>xxxxx     Ready    control-plane,master   32m   v1.30.1+k3s1<br></code></pre></td></tr></table></figure><h2 id="3-2-查看Node信息"><a href="#3-2-查看Node信息" class="headerlink" title="3.2 查看Node信息"></a>3.2 查看Node信息</h2><p>此时如果我们查看节点信息（<code>sudo kubectl describe node xxx</code>），会发现注解<code>flannel.alpha.coreos.com/public-ip</code>依然是节点另一张网卡的IP。目前影响未知。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Annotations:        alpha<span class="hljs-selector-class">.kubernetes</span>.io/provided-node-ip: <span class="hljs-number">100</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><br>                    flannel<span class="hljs-selector-class">.alpha</span><span class="hljs-selector-class">.coreos</span>.com/backend-data: &#123;<span class="hljs-string">&quot;VNI&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;VtepMAC&quot;</span>:<span class="hljs-string">&quot;xx&quot;</span>&#125;<br>                    flannel<span class="hljs-selector-class">.alpha</span><span class="hljs-selector-class">.coreos</span>.com/backend-type: vxlan<br>                    flannel<span class="hljs-selector-class">.alpha</span><span class="hljs-selector-class">.coreos</span>.com/kube-subnet-manager: true<br>                    flannel<span class="hljs-selector-class">.alpha</span><span class="hljs-selector-class">.coreos</span>.com/public-ip: <span class="hljs-number">10</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><br>                    k3s.io/external-ip: <span class="hljs-number">100</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><br>                    k3s.io/hostname: xx<br>                    k3s.io/internal-ip: <span class="hljs-number">100</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span>.x<br></code></pre></td></tr></table></figure><h1 id="4-设置静态CPU调度策略"><a href="#4-设置静态CPU调度策略" class="headerlink" title="4. 设置静态CPU调度策略"></a>4. 设置静态CPU调度策略</h1><p>Docker&#x2F;K8S体系下，CPU默认是按时间片调度的。容器获取到CPU时间片后，可以在不同的CPU核心中切换。这在IO密集型场景中可以提升资源利用率。</p><p>但笔者的场景是计算密集型，切换CPU核心会导致性能下降，所以需要将容器和CPU进行绑定。</p><h2 id="4-1-Docker实现"><a href="#4-1-Docker实现" class="headerlink" title="4.1 Docker实现"></a>4.1 Docker实现</h2><p>用docker命令运行容器时，可以用<code>--cpuset-cpus</code>等参数绑定CPU核心（<a href="https://docs.docker.com/config/containers/resource_constraints/#cpu">Runtime options with Memory, CPUs, and GPUs | Docker Docs</a>），或者用docker-compose配置实现类似效果（<a href="https://docs.docker.com/compose/compose-file/05-services/#cpuset">Services top-level elements | Docker Docs</a>）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.4&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">xxx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxx</span><br><br>    <span class="hljs-comment"># 绑定cpu核心</span><br>    <span class="hljs-attr">cpuset:</span> <span class="hljs-string">&quot;0-3&quot;</span><br>    <span class="hljs-attr">cpu_count:</span> <span class="hljs-number">4</span><br>    <span class="hljs-comment"># 预留内存</span><br>    <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">&#x27;4g&#x27;</span><br>    <span class="hljs-attr">memswap_limit:</span> <span class="hljs-string">&#x27;4g&#x27;</span><br>    <span class="hljs-attr">mem_reservation:</span> <span class="hljs-string">&#x27;2g&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="4-2-K3S实现"><a href="#4-2-K3S实现" class="headerlink" title="4.2 K3S实现"></a>4.2 K3S实现</h2><p>kubelet也可以设置类似的调度策略：static 策略（<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/cpu-management-policies/">控制节点上的 CPU 管理策略 | Kubernetes</a>）。但由于K3S已经将kubelet集成到了二进制内容里，所以无法单独配置kubelet。编辑K3S的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /etc/rancher/k3s/<br>sudo vim /etc/rancher/k3s/config.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kubelet-arg:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--cpu-manager-policy=static&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--system-reserved=cpu=1,memory=1Gi&quot;</span><br></code></pre></td></tr></table></figure><p>删除已有CPU调度策略并重启K3S服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rm /var/lib/kubelet/cpu_manager_state<br>sudo systemctl restart k3s # 主节点<br>sudo systemctl restart k3s-agent # 从节点<br></code></pre></td></tr></table></figure><p>此时可以看到配置生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo kubectl describe node xxx</span><br>...<br>Annotations:        alpha.kubernetes.io/provided-node-ip: 100.x.x.x<br>                    k3s.io/node-args:<br>                      [&quot;agent&quot;,&quot;--kubelet-arg&quot;,&quot;--cpu-manager-policy=static&quot;,&quot;--kubelet-arg&quot;,&quot;--system-reserved=cpu=1,memory=1Gi&quot;,&quot;--node-ip&quot;,&quot;10<br>...<br>Capacity:<br>  cpu:                16<br>  ...<br>Allocatable:<br>  cpu:                15<br>  ...<br></code></pre></td></tr></table></figure><p>大功告成，愉快享受K3S了~</p>]]></content>
    
    
    
    <tags>
      
      <tag>云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年度总结</title>
    <link href="/2024/01/01/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/01/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2023年对我影响最大的一本书是《纳瓦尔宝典》，书里对“智慧”的定义是“知道个人行为的长期后果”。对于我而言，这个定义有时候还要加上“我为什么会这么做”。于是，这次的年度总结，就让我好好盘点下2023年做过的重要决策吧。</p><h1 id="身体状况"><a href="#身体状况" class="headerlink" title="身体状况"></a>身体状况</h1><ul><li>4月底搬到上海后，我频繁去住处附近的健身房上私教课。价格不便宜，但成果显著：深蹲突破100kg、发力姿势优化了不少，而且还强化了坚持锻炼的习惯（感谢教练）。</li><li>10月初搬到长沙后，我频繁久坐+面对电脑：研究3d打印，娱乐，写代码，等等。户外活动也少了很多，结果是视力明显下降。还好健身房没落下，不然身体也得出问题。只能说长时间蜗居确实对健康有害，所以经过一番努力，我很快就要脱离蜗居状态了。</li><li>口腔、甲状腺等方面关注度不高，但每天会关注。目前整体情况还算稳定。</li></ul><p>总体而言身体状况是最重要也是最值得投入的：正面效果明显，投入不足的负面效果也很明显。</p><h1 id="心理状况与人际关系"><a href="#心理状况与人际关系" class="headerlink" title="心理状况与人际关系"></a>心理状况与人际关系</h1><ul><li>下半年我参加了多次心理咨询。心理咨询减少了我的迷茫和痛苦，效果出乎意料的好（感谢咨询师）。</li><li>搬到上海给我带来的心理负面影响比想象中的要大一些，但方向上略有不同。上海丰富的文娱活动带来了不少宝贵回忆，也覆盖了人际关系重置等方面的负面影响。但对城市缺少归属感+加班依然是挥之不去的阴影，为了高工资和职业前景而说服自己暂时停留在上海的底气也越来不足。从结果看，搬到上海短期内降低了我的幸福感，但也同时更让我认清了自己。</li><li>回长沙后蜗居了三个月，充分的自由带来的幸福感很明显。但孤独感，以及对社交、稳定收入、社会身份的需求随着时间的推移在逐渐变明显。</li></ul><p>今年我在这方面今年绝不能称之为保守。相比去年，我觉得我更能认清自己和接纳自己了，我想这是好事。当然，今后可以选择一些更合适的途径😂</p><h1 id="财务状况"><a href="#财务状况" class="headerlink" title="财务状况"></a>财务状况</h1><ul><li>今年我通过一些不可持续的选择，让财富总量继续有令人满意的增长。或许我在潜意识里知道，传统路径下我已经触达极限了？</li><li>下半年裸辞的决定给我的财务状况带来了一些压力。虽然基于前几年的积累，我在未来数年内不需要担心生活开支，但基于对稳定收入的渴求，我还是在辞职一个半月后开始找工作。</li><li>今年我在A股基金上的投资几乎没有调整，结果是亏损数万。损失尚能接受，但投资逻辑需要发生变更：单一走向分散、用底层逻辑取代历史业绩作为判断依据。</li></ul><p>即使知道自己（暂时）不用为金钱烦恼，但我还是在渴求稳定的收入来源。或许后者才更容易取得生活的平衡？</p><h1 id="热情"><a href="#热情" class="headerlink" title="热情"></a>热情</h1><ul><li>搬到上海后我参加了很多二次元&#x2F;影视相关的活动，搬到长沙后我也在继续参加。很高兴看到我对热情没有消退。</li><li>“回到长沙专心做自己有热情的东西”是我裸辞的一大原因。但基于对稳定收入的渴求，我往这个”热情“里注入了不少商业化因素。而当这个”热情“无法快速带来预期收益，我也没有找到强力的正反馈途径时，这个”热情“也就慢慢消亡了。幸运的是，我的热情不止这一个，接下来要做的，可能是减少商业化的干扰，再搭配一个小小的正反馈循环。</li></ul><p>健康的身体、良好的心理状态和人际关系、不需要为财务状况发愁，在这种情况下，追求自己的热情变成为了一件人生中最重要的事情（没有之一）。我想，这是2023年我给自己的一个注解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将txt格式电子书转换为kindle格式</title>
    <link href="/2023/12/27/txt-to-kindle/"/>
    <url>/2023/12/27/txt-to-kindle/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>笔者有时候会阅读一些txt格式的电子书；同时为了护眼，笔者倾向于在kindle上阅读电子书。但作为纯文本格式，txt在kindle上的阅读体验比较一般：字体无法随意调节、缺少目录。为了解决这个问题，笔者研究了一套转换流程，用于将txt格式的电子书转换为kindle的azw3格式（也适用于其它电子书格式），以获得更好的阅读体验。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227103239489.webp" alt="转换前"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227103414900.webp" alt="转换后"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227103329881.webp" alt="转换后"></th></tr></thead><tbody><tr><td>转换前</td><td>转换后</td><td>转换后</td></tr></tbody></table><h1 id="处理txt文件"><a href="#处理txt文件" class="headerlink" title="处理txt文件"></a>处理txt文件</h1><p>这部分处理的核心是将txt文件转换为带格式的html文件。为此，我们需要准备一个带正则表达式替换功能的文本编辑器，如<a href="https://notepad-plus-plus.org/">Notepad++</a>。</p><h2 id="转换二级标题"><a href="#转换二级标题" class="headerlink" title="转换二级标题"></a>转换二级标题</h2><p>首先将“第XX章”转换为二级标题，使用正则替换：</p><ul><li>查找目标：<code>^(第[一二三四五六七八九十百千0-9]+章.*)</code></li><li>替换为：<code>&lt;h2&gt;$1&lt;/h2&gt;</code></li></ul><p>点击“全部替换”按钮即可看到效果。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227102627720.webp" alt="image-20231227102627720"></p><h2 id="转换一级标题"><a href="#转换一级标题" class="headerlink" title="转换一级标题"></a>转换一级标题</h2><p>然后将“第XX卷”转换为一级标题，使用正则替换：</p><ul><li>查找目标：<code>^(第[一二三四五六七八九十百千0-9]+卷.*)</code></li><li>替换为：<code>&lt;h1&gt;$1&lt;/h1&gt;</code></li></ul><p>点击“全部替换”按钮即可看到效果。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227102642685.webp" alt="image-20231227102642685"></p><h2 id="转换换行"><a href="#转换换行" class="headerlink" title="转换换行"></a>转换换行</h2><p>然后将“换行”转换为html标签，使用正则替换：</p><ul><li>查找目标：<code>\r?\n</code></li><li>替换为：<code>&lt;/br&gt;\n</code></li></ul><p>点击“全部替换”按钮即可看到效果。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227102724977.webp" alt="image-20231227102724977"></p><h2 id="修改文件后缀为-html"><a href="#修改文件后缀为-html" class="headerlink" title="修改文件后缀为.html"></a>修改文件后缀为.html</h2><p>将文件的<code>.txt</code>后缀修改为<code>.html</code>，之后将文件用浏览器打开即可观察到效果。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227102734359.webp" alt="image-20231227102734359"></p><h1 id="转换电子书"><a href="#转换电子书" class="headerlink" title="转换电子书"></a>转换电子书</h1><p>这部分处理的核心是将html格式的电子书转换为azw3等格式。为此，我们需要准备一个功能完善的电子书管理软件，比如<a href="https://calibre-ebook.com/">calibre - E-book management</a>。</p><h2 id="加入calibre书库"><a href="#加入calibre书库" class="headerlink" title="加入calibre书库"></a>加入calibre书库</h2><p>将html文件拖入calibre，即可加入书库</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227105124993.webp" alt="image-20231227105124993"></p><h2 id="完善书籍元数据"><a href="#完善书籍元数据" class="headerlink" title="完善书籍元数据"></a>完善书籍元数据</h2><p>编辑书籍元数据，可完善书籍的书名&#x2F;作者等信息。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227102833783.webp" alt="image-20231227102833783"></p><h2 id="转换书籍格式"><a href="#转换书籍格式" class="headerlink" title="转换书籍格式"></a>转换书籍格式</h2><p>转换书籍为azw3，注意指定输出格式和目录结构：</p><ul><li>1级目录为<code>//h:h1</code></li><li>2级目录为<code>//h:h2</code></li></ul><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227103132931.webp" alt="image-20231227103132931"><br><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227102951708.webp" alt="image-20231227102951708"></p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>最后将书籍导入kindle即可，享受阅读吧~</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231227105812486.webp" alt="image-20231227105812486"></p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>多媒体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易Docker日志持久化&amp;中心化方案 Loki</title>
    <link href="/2023/12/26/docker-log-center/"/>
    <url>/2023/12/26/docker-log-center/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者在家庭服务器上运行了一组业务Docker容器，有查看容器日志的需求。<code>docker logs</code>只能查看单个容器的日志，且在容器被删除、需要指定时间范围查询等情况下表现不是很好，所以笔者开始寻找一种简单易用的日志集中管理方案。</p><p>Docker提供了<code>logging drivers</code>的配置项<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Configure logging drivers | Docker Docs](https://docs.docker.com/config/containers/logging/configure/)">[1]</span></a></sup>来管理日志，可以将日志发送到<code>Logstash</code>或<code>fluentd</code>。经过笔者的了解，发现这种方案是比较耳熟的ELK&#x2F;FEK方案：</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231226154837554.webp" alt="elk"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231226154510340.webp" alt="fek"></th></tr></thead></table><p>虽然这套方案比较成熟，应用案例也很多，但对于笔者的个人简单使用场景来说太麻烦了。由于笔者已经部署了Grafana看板，所有笔者最后选择了Grafana生态下的Loki来管理日志。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231226155206048.webp" alt="Loki架构图"></p><p>最终效果如下图所示，笔者可以在Grafana看板上通过时间范围、关键字、容器名称等参数来查看日志，简单易用且符合笔者需求。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231226155545733.webp" alt="grafana看板"></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="promtail"><a href="#promtail" class="headerlink" title="promtail"></a>promtail</h2><p>promtail用于转发容器产生的日志。从<a href="https://github.com/grafana/loki/releases">Github releases</a>页可以下载到最新版本的二进制文件。虽然promtail也提供官方镜像，但对于promtail这种静态编译的单个执行文件，笔者更喜欢用<a href="http://supervisord.org/">Supervisor</a>管理。更详细的安装流程参考官方文档<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Install Promtail | Grafana Loki documentation](https://grafana.com/docs/loki/latest/send-data/promtail/installation/)">[3]</span></a></sup>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget https://github.com/grafana/loki/releases/download/v2.9.3/promtail-linux-amd64.zip<br>$ unzip promtail-linux-amd64.zip &amp;&amp; <span class="hljs-built_in">rm</span> promtail-linux-amd64.zip<br>$ <span class="hljs-comment"># 下载默认配置文件</span><br>$ wget https://raw.githubusercontent.com/grafana/loki/main/clients/cmd/promtail/promtail-local-config.yaml<br></code></pre></td></tr></table></figure><p>配置文件很简单：连上Docker daemon，将标签中带有<code>logging=promtail</code>的容器输出发送给<code>localhost:3100</code>处的loki服务器。因为要区分容器，所以这里还用容器名和<code>jobname</code>标签值来区分。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">http_listen_port:</span> <span class="hljs-number">9080</span><br>  <span class="hljs-attr">grpc_listen_port:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">positions:</span><br>  <span class="hljs-attr">filename:</span> <span class="hljs-string">/tmp/positions.yaml</span><br><br><span class="hljs-attr">clients:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:3100/loki/api/v1/push</span><br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">docker_containers</span><br>    <span class="hljs-attr">docker_sd_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">unix:///var/run/docker.sock</span><br>        <span class="hljs-attr">refresh_interval:</span> <span class="hljs-string">5s</span><br>        <span class="hljs-attr">filters:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">label</span><br>            <span class="hljs-attr">values:</span> [<span class="hljs-string">&quot;logging=promtail&quot;</span>]<br>    <span class="hljs-attr">relabel_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">&#x27;__meta_docker_container_name&#x27;</span>]<br>        <span class="hljs-attr">regex:</span> <span class="hljs-string">&#x27;/(.*)&#x27;</span><br>        <span class="hljs-attr">target_label:</span> <span class="hljs-string">&#x27;container&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">&#x27;__meta_docker_container_log_stream&#x27;</span>]<br>        <span class="hljs-attr">target_label:</span> <span class="hljs-string">&#x27;logstream&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">&#x27;__meta_docker_container_label_logging_jobname&#x27;</span>]<br>        <span class="hljs-attr">target_label:</span> <span class="hljs-string">&#x27;job&#x27;</span><br></code></pre></td></tr></table></figure><p>启动也很简单，运行（或在 supervisor配置文件中输入）如下命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./promtail-linux-amd64 -config.file promtail-local-config.yaml.yaml<br></code></pre></td></tr></table></figure><p>启动后就可以用curl或浏览器访问9080端口进行验证了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl 127.0.0.1:9080<br>&lt;a href=<span class="hljs-string">&quot;/targets&quot;</span>&gt;See Other&lt;/a&gt;.<br></code></pre></td></tr></table></figure><h2 id="容器配置"><a href="#容器配置" class="headerlink" title="容器配置"></a>容器配置</h2><p>上面的配置文件会让promtail只抓取特定容器的日志，所以我们需要在启动业务容器时写入标签。以docker-compose文件为例，在配置文件中写入两个标签即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.4&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">xxx-service:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxx-image:latest</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">logging:</span> <span class="hljs-string">&quot;promtail&quot;</span> <span class="hljs-comment"># 表明日志需要被promtail抓取</span><br>      <span class="hljs-attr">logging_jobname:</span> <span class="hljs-string">&quot;xxx-service&quot;</span> <span class="hljs-comment"># 将该值加入日志标签，方便后续查看和筛选日志</span><br></code></pre></td></tr></table></figure><p>这也是Loki方案相比ELK&#x2F;FEK方案的一个优点：只需要重启容器就可以抓取日志，不需要重启Docker服务本身。</p><h2 id="Loki"><a href="#Loki" class="headerlink" title="Loki"></a>Loki</h2><p>Loki用于接收容器产生的日志。从<a href="https://github.com/grafana/loki/releases">Github releases</a>页可以下载到最新版本的二进制文件。更详细的安装流程参考官方文档<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Installation | Grafana Loki documentation](https://grafana.com/docs/loki/latest/setup/install/)">[4]</span></a></sup>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget https://github.com/grafana/loki/releases/download/v2.8.7/loki-linux-amd64.zip<br>$ unzip loki-linux-amd64.zip &amp;&amp; <span class="hljs-built_in">rm</span> loki-linux-amd64.zip<br>$ <span class="hljs-comment"># 下载默认配置文件</span><br>$ wget https://raw.githubusercontent.com/grafana/loki/main/cmd/loki/loki-local-config.yaml<br></code></pre></td></tr></table></figure><p>配置文件很简单：监听本机3100端口，将接收到的日志存储在<code>/tmp/loki/chunks/</code>里。笔者用的就是默认配置（更详细的配置说明参考官方文档<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Grafana Loki configuration parameters | Grafana Loki documentation](https://grafana.com/docs/loki/latest/configure/)">[5]</span></a></sup>），直接启动即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./loki-linux-amd64 -config.file loki-local-config.yaml<br></code></pre></td></tr></table></figure><p>启动后就可以用curl或浏览器访问3100端口进行验证了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl 127.0.0.1:3100<br>404 page not found<br></code></pre></td></tr></table></figure><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana的配置更简单。较新版本的Grafana内置了对Loki的支持，在网页中的Data sources配置页面增加一个Loki数据源，输入Loki的HTTP地址，就可以像文章开头那样在Grafana面板的Explore页面里查询日志了。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20231226162613619.webp" alt="data sources配置界面"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://docs.docker.com/config/containers/logging/configure/">Configure logging drivers | Docker Docs</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.atatus.com/blog/a-beginners-guide-for-grafana-loki/">A Beginner’s Guide for Grafana Loki (Open-source Log Aggregation by Prometheus)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://grafana.com/docs/loki/latest/send-data/promtail/installation/">Install Promtail | Grafana Loki documentation</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://grafana.com/docs/loki/latest/setup/install/">Installation | Grafana Loki documentation</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://grafana.com/docs/loki/latest/configure/">Grafana Loki configuration parameters | Grafana Loki documentation</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>grafana</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北京到上海搬家小记</title>
    <link href="/2023/04/22/beijing-to-shanghai/"/>
    <url>/2023/04/22/beijing-to-shanghai/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>经过一番慎重考虑，笔者最终选择上海作为未来一段时间工作和生活的地方。</p><p>接下来最大的挑战来自于搬家：上千公里的距离、繁多的行李（升降椅、升降桌桌腿、哑铃、ITX主机、NAS、空气净化器、床上用品、衣物、书籍等等）。</p><p>同时，为了减少来回奔波，笔者想在上海租好公司附近的房子后直接住下，<strong>不再返回北京</strong>。也就是说，整个搬家过程需要为： </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">行李发往上海 -&gt; 人前往上海 -&gt; 租好房子 -&gt; 接收行李<br></code></pre></td></tr></table></figure><p>这篇文章，便是应对这个艰巨任务的简单记录。</p><h1 id="2-方案选择"><a href="#2-方案选择" class="headerlink" title="2. 方案选择"></a>2. 方案选择</h1><blockquote><p><a href="https://v2ex.com/t/925040">跨省搬家有什么靠谱的方案的吗？ - V2EX</a></p><p><a href="https://v2ex.com/t/534112">求推荐搬家公司：上海到杭州 - V2EX</a></p><p><a href="https://www.v2ex.com/t/765610?p=1">结束北漂，搬家东西太多，长途物流哪家强？ - V2EX</a></p><p><a href="https://www.v2ex.com/t/892974">跨城搬家大家有操作过，求支招 - V2EX</a></p></blockquote><p>按笔者的调查，跨城搬家主要有两种方案：整车搬家、发物流。</p><h2 id="2-1-整车搬家"><a href="#2-1-整车搬家" class="headerlink" title="2.1 整车搬家"></a>2.1 整车搬家</h2><p>该方案的意思是包下一辆箱式货车，往往会搭配上搬家公司周到的装卸服务。这个方案的优点是是省力省心、时效性高；缺点是费用较高。</p><p>有朋友在从珠三角搬到上海时采用了该方案，他的情况是需要发运电视、升降椅等大件，且没有原包装，所以只能使用这种方案。他选择的搬家公司是蓝犀牛，总花费10000+。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230423084142995.webp"></p><p>由于费用对于笔者来说过于高昂，而且高时效性也让笔者很难在行李到达上海前租到合适的房子，所以笔者不考虑该方案。</p><h2 id="2-2-发物流"><a href="#2-2-发物流" class="headerlink" title="2.2 发物流"></a>2.2 发物流</h2><p>该方案的意思是自行打包行李，然后交给物流公司（德邦物流&#x2F;顺丰物流等）或者个体货车主进行运送，行李到达目标城市后再由物流方上门&#x2F;上楼送货、或者自提。优点是省钱，缺点是劳心劳力、时效性较低。</p><p>经过物流公司提供的工具预估，笔者的行李总运费约为1000元。同时通过咨询快递员，笔者确定可以先在收件地址上写上某个模糊地址（如地铁站附近），再在物流派送时和快递员协商具体收件地址。</p><p>由于笔者的大件物品都带有原包装，且需要在行李运输过程中在上海找房子，所以笔者决定压榨下自己的劳动力，采用该方案搬家。</p><h1 id="3-打包行李"><a href="#3-打包行李" class="headerlink" title="3. 打包行李"></a>3. 打包行李</h1><p>除了大件物品自带的包装盒外，笔者还额外购入了5个规格比较常见（60cm*40cm*50cm）的搬家打包盒。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230422165220093.webp"></p><p>之后便是辛苦的打包过程。有的大件物品比较容易放入原包装，但升降椅则需要经过相对暴力的拆卸过程（如下图中被锤得坑坑洼洼的底座和气柱，参考视频<a href="https://www.bilibili.com/video/BV1mA411L7Hj/">一锤子拆掉转椅气杆 怎样拆升降杆&#x2F;液压杆 拆电脑椅底盘椅脚_哔哩哔哩_bilibili</a>）</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230422155135469.webp"></p><p>考虑到行李有可能丢失、以及可能的紧急情况，笔者将重要文件放入了随时的行李箱中；同时为了规避可能的风险，笔者没有在打包的行李中放入干电池、刀具、压缩瓶罐。最后，笔者共打包出14个箱子（包括淘宝购买的5个纸箱）。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230422155648567.webp"></p><h1 id="4-物流发出"><a href="#4-物流发出" class="headerlink" title="4. 物流发出"></a>4. 物流发出</h1><p>笔者安排的时间表是上午寄出行李，接着对北京的住处进行退租，然后下午2点搭乘高铁前往上海。</p><p>笔者在前一天晚上预约了顺丰物流，收件地址为<strong>上海XX地铁站附近</strong>，第二天9点到10点上门取件。但到了第二天早上，分配的快递员联系我说因为车上没有足够空间容纳这么箱子，所以下午才能过来取件。笔者转而预约了德邦物流，得到了相同的答复。</p><p>懵逼的笔者只好再次预约了京东快递，京东快递小哥听闻后立即火速上门进行取件。由于小哥的三轮车也没有足够空间容纳所有箱子，所以取件中途小哥还回了一趟快递网点（还好笔者的住处离网点不远），然后继续取件，最终在11点出头将所有箱子取走，总耗时半个多小时。</p><p>和中介商量好退租事宜后，笔者踏上了前往上海的高铁。随后快递员发来的揽收账单显示，行李总体积1.57立方米，总重量255千克，运费1700+元。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230422170759849.webp"></p><h1 id="5-物流接收"><a href="#5-物流接收" class="headerlink" title="5. 物流接收"></a>5. 物流接收</h1><p>笔者在发出行李当天抵达上海后，立即和中介开始了看房之旅。在实地看了9套房后，笔者在第二天签下了租房合同并入住（中介大姐甚至给笔者借了毛毯和床单应急使用）。</p><p>确定了住址后，笔者尝试在京东小程序上修改行李包裹的收件地址：从<strong>上海XX地铁站附近</strong>改为<strong>XX小区XX号XXX</strong>。但支付的5元服务费貌似并没有起到效果，因为数天后快递小哥上门送货时并不清楚我修改后的地址，而是在沟通电话里口头约定了具体地址。由于寄件下单时没看到“送货上楼”的服务选项（顺丰和德邦有），所以上门时临时让快递小哥增加了上楼的服务，并转帐了100元作为报酬。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230423082456690.webp"></p><p>淘宝买的5个搬家箱子状态比较良好，但被子&#x2F;枕头&#x2F;显示器的原包装盒出现了不同程度的变形。显示器出现了好几个不可恢复的紫色斑点，虽然只有在黑色背景下才比较明显，但也说明原包装盒并不是100%可靠。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230423082713935.webp"></p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>整个搬家的时间线为：</p><ul><li>周日：打包行李</li><li>周一：寄出行李、退租、前往上海、看房</li><li>周二：看房、签租房合同</li><li>周四：收到行李</li></ul><p>虽然总体而言还算顺利，但依然得到了不少经验教训：</p><ul><li>打包盒子多过，平均每个盒子运费100+元，部分盒子本身价值有限。</li><li>周一时间安排过于紧张，对意外情况容忍能力较差。</li><li>过度依赖原包装，增加物品损坏风险。</li></ul><p>最后，期待在上海的新生活！</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>偷天换日2.0：篡改光猫的IPv6地址自动分配</title>
    <link href="/2023/02/17/modify-slaac/"/>
    <url>/2023/02/17/modify-slaac/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><blockquote><p>这是一篇神奇的文章。在这篇文章里，你将会看到：</p><ul><li>如何将一台双口linux设备变成一台交换机</li><li>如何修改ICMPv6数据包中的DNS信息并发送IPv6数据包</li><li>如何修改IPv6数据包中的来源IP地址并发送以太网帧</li></ul></blockquote><p>下图是笔者的网络架构（部分）。PC自动从光猫处获取IPv6地址，并将其网关&#x2F;DNS指向光猫：</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20230217.slaac-default.svg" alt="笔者家庭网络架构"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230217094605079.webp" style="zoom:33%;" /></th></tr></thead></table><p>但光猫的DNS存在DNS污染、无法自定义解析规则等问题，且安卓设备无法手动设置IPv6的DNS，所以笔者在之前的文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[安卓对指定WiFi禁用IPv6](/2022/12/17/%E5%AE%89%E5%8D%93%E5%AF%B9%E6%8C%87%E5%AE%9AWiFi%E7%A6%81%E7%94%A8IPv6/)">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[偷天换日：屏蔽光猫的IP地址自动分配](/2022/12/28/%E5%81%B7%E5%A4%A9%E6%8D%A2%E6%97%A5%EF%BC%9A%E5%B1%8F%E8%94%BD%E5%85%89%E7%8C%AB%E7%9A%84IP%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D/)">[2]</span></a></sup>里直接禁用了光猫的IPv6地址自动分配，家庭局域网内基本只使用IPv4。</p><p>但禁用IPv6始终是个缺憾。有没有可能实现，<strong>在保留光猫IPv6地址自动分配的基础上，实现自定义DNS</strong>呢？这是本文想要讨论的问题。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20230217.slaac-expect.svg" alt="预期网络架构"></p><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h1><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/ipv6-stateless-address-autoconfiguration.gif"></p><p>基于上面的动图回顾一下IPv6 SLAAC地址自动分配的原理：</p><ul><li>PC1向局域网广播ICMPv6 <strong>Router Solicitation</strong>（RS）数据包</li><li>路由器收到RS包后广播ICMPv6 <strong>Router Advertisement</strong> (RA)数据包</li><li>PC1收到RA数据包后得知IPv6网段前缀，并生成自己的IPv6地址</li></ul><p>具体到笔者的环境，光猫发出的RA包里还携带了附加的DNS服务器地址信息：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221228232047709.webp"></p><p>那么实现自定义DNS的思路就比较明确了：</p><ul><li>PC正常向局域网广播RS数据包</li><li>增加一台软交换机，让PC无法直接收到光猫广播的RA数据包</li><li>软交换机收到光猫广播的RA数据包后，修改其中的DNS信息，并重新进行广播</li><li>PC收到修改后的RA数据包，生成自己的IPv6地址</li></ul><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20230218.slaac-plan.svg" alt="改造思路"></p><h1 id="3-设置软交换机"><a href="#3-设置软交换机" class="headerlink" title="3. 设置软交换机"></a>3. 设置软交换机</h1><p>笔者使用广受好评的友善NanoPi R2S作为这里的软交换机，系统则使用的是友善Ubuntu Core 20.04改版。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230218111856330.webp" alt="友善R2S"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20230218.network_arch.svg"></th></tr></thead></table><p>将光猫和PC分别连接至R2S的两个网口后，在Ubuntu上配置一个连接两个网口的网桥，即可让R2S化身一台软交换机（详细说明见Ubuntu社区文档：<a href="https://help.ubuntu.com/community/NetworkConnectionBridge">NetworkConnectionBridge - Community Help Wiki</a>）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install bridge-utils<br>sudo vim /etc/network/interfaces.d/br0<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">auto</span> <span class="hljs-string">br0</span><br><span class="hljs-string">iface</span> <span class="hljs-string">br0</span> <span class="hljs-string">inet</span> <span class="hljs-string">static</span><br>   <span class="hljs-string">address</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span><br>   <span class="hljs-string">netmask</span> <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br>   <span class="hljs-string">gateway</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>   <span class="hljs-comment"># dns-nameservers 192.168.1.1</span><br>   <span class="hljs-string">bridge_ports</span> <span class="hljs-string">eth0</span> <span class="hljs-string">eth1</span><br>   <span class="hljs-string">bridge_stp</span> <span class="hljs-string">off</span><br>   <span class="hljs-string">bridge_fd</span> <span class="hljs-number">0</span><br>   <span class="hljs-string">bridge_maxwait</span> <span class="hljs-number">0</span><br><span class="hljs-string">iface</span> <span class="hljs-string">br0</span> <span class="hljs-string">inet6</span> <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /etc/init.d/networking restart<br></code></pre></td></tr></table></figure><p>配置好后可通过<code>brctl</code>命令可以看到效果：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230218113942408.webp"></p><p>同时，我们还可以通过<code>ebtables</code>禁止来自光猫的RA包广播到网桥上的其它设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ebtables -A FORWARD -p IPv6 -s &#123;光猫MAC地址&#125; --ip6-proto ipv6-icmp --ip6-icmp-type router-advertisement -j DROP<br></code></pre></td></tr></table></figure><h1 id="4-修改ICMPv6数据包"><a href="#4-修改ICMPv6数据包" class="headerlink" title="4. 修改ICMPv6数据包"></a>4. 修改ICMPv6数据包</h1><p>接着我们需要在这台软交换机上对ICMPv6 RA数据包进行加工。整体逻辑并不复杂：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">for &#123;<br>监听ICMPv6数据包<br>过滤RA数据包<br>修改其中的DNS信息<br>广播修改后的RA数据包<br>&#125;<br></code></pre></td></tr></table></figure><p>Golang的官方包<a href="https://pkg.go.dev/golang.org/x/net/icmp">golang.org&#x2F;x&#x2F;net&#x2F;icmp</a>能很方便做到这一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    mcastIP = net.ParseIP(<span class="hljs-string">&quot;ff02::1&quot;</span>) <span class="hljs-comment">// 组播ip</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <br>    c, err := icmp.ListenPacket(<span class="hljs-string">&quot;ip6:ipv6-icmp&quot;</span>, <span class="hljs-string">&quot;::&quot;</span>) <span class="hljs-comment">// 监听ICMPv6数据包</span><br>    ...<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 监听ICMPv6数据包</span><br>        rb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1500</span>)<br>n, peer, err := c.ReadFrom(rb)<br>        ...<br>        <span class="hljs-keyword">var</span> zone <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> parts := strings.SplitN(peer.String(), <span class="hljs-string">&quot;%&quot;</span>, <span class="hljs-number">2</span>); <span class="hljs-built_in">len</span>(parts) == <span class="hljs-number">2</span> &#123;<br>zone = parts[<span class="hljs-number">1</span>]<br>&#125;<br>        ...<br>        <span class="hljs-comment">// 过滤RA数据包</span><br>        <span class="hljs-keyword">const</span> ProtocolIPv6ICMP = <span class="hljs-number">58</span><br>        rm, err := icmp.ParseMessage(ProtocolIPv6ICMP, rb[:n])<br>        ...<br>        <span class="hljs-keyword">if</span> rm.Type != ipv6.ICMPTypeRouterAdvertisement &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>        body, err = rm.Body.Marshal(<span class="hljs-type">int</span>(ipv6.ICMPTypeRouterAdvertisement))<br>        ...<br>        <span class="hljs-comment">// 修改其中的DNS信息</span><br>        err = replaceDNS(body)<br>        ...<br>        rm.Body = &amp;icmp.RawBody&#123;Data: body&#125;<br>        <br>        <span class="hljs-comment">// 广播修改后的RA数据包</span><br>        wb, err := rm.Marshal(<span class="hljs-literal">nil</span>)<br>...<br>_, err = c.WriteTo(wb, &amp;net.IPAddr&#123;IP: mcastIP, Zone: zone&#125;)<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题的关键在于如何修改RA数据包中的DNS。虽然通过分析Wireshark抓包，我们可以获得DNS在RA数据包中的具体位置（数组下标），但这种依赖Magic Number的代码显然缺少通用性。</p><p>维基百科<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[ICMPv6 - Wikipedia](https://en.wikipedia.org/wiki/ICMPv6)">[4]</span></a></sup>和RFC6106<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[RFC 6106: IPv6 Router Advertisement Options for DNS Configuration](https://www.rfc-editor.org/rfc/rfc6106)">[5]</span></a></sup>介绍了RA数据包、DNS Option的具体格式：</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230219103231373.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230219102422222.webp"></th></tr></thead></table><p>于是我们知道，RA数据包的16字节后是Options区域（<code>icmp</code>库已去除了前4个字节）、Option的前两个字节分别是类型和Option长度（以8字节为单位）。所以，我们可以通过下列代码查找并替换RA包中的DNS地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    routerIP = net.ParseIP(<span class="hljs-string">&quot;fe80::1&quot;</span>) <span class="hljs-comment">// 光猫ip</span><br>    dnsIP = net.ParseIP(<span class="hljs-string">&quot;fe80::xx&quot;</span>) <span class="hljs-comment">// 自定义dns服务器ip</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replaceDNS</span><span class="hljs-params">(body []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">for</span> idx := <span class="hljs-number">12</span>; idx &lt; <span class="hljs-built_in">len</span>(body)<span class="hljs-number">-1</span>; idx += <span class="hljs-type">int</span>(body[idx+<span class="hljs-number">1</span>]) * <span class="hljs-number">8</span> &#123; <span class="hljs-comment">// 遍历所有option</span><br><span class="hljs-keyword">const</span> optTypeDNS = <span class="hljs-number">25</span><br><span class="hljs-keyword">if</span> optType := body[idx]; optType == optTypeDNS &#123; <span class="hljs-comment">// 定位dns option</span><br>ipL, ipR := idx+<span class="hljs-number">8</span>, idx+<span class="hljs-number">8</span>+<span class="hljs-number">16</span><br><span class="hljs-keyword">if</span> oldDNS := body[ipL:ipR]; !reflect.DeepEqual(oldDNS, []<span class="hljs-type">byte</span>(routerIP)) &#123; <span class="hljs-comment">// 防止递归替换</span><br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;dns in RA (%s) not equal %s&quot;</span>, net.IP(oldDNS), routerIP)<br>&#125;<br>_ = <span class="hljs-built_in">append</span>(body[ipL:ipL], dnsIP...) <span class="hljs-comment">// 原地替换dns ip</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;dns option not found&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-修改IPv6数据包"><a href="#5-修改IPv6数据包" class="headerlink" title="5. 修改IPv6数据包"></a>5. 修改IPv6数据包</h1><p>Wireshark抓包的结果显示PC确实收到了修改后的RA数据包，但PC却并没有像预想的那样正常获取到IPv6地址。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230219201849810.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230219202107580.webp"></th></tr></thead></table><p>由于PC收到的是软交换机重新广播的RA包，所以其IPv6数据包首部的来源IP地址变成了软交换机的IPv6地址（<code>fe80::1c:xx</code>），而不是原始RA包中的光猫IPv6地址（<code>fe80::1</code>）。此时笔者有了一个大胆的猜想，是不是这个来源IP地址的问题呢？如果是的话，我们只要能再修改这个值，就能让PC正常获取到IPv6地址了。</p><p>要修改这个地址，我们需要做两件事情：</p><ol><li><p>重新计算ICMPv6包的校验和。维基<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[ICMPv6 - Wikipedia](https://en.wikipedia.org/wiki/ICMPv6)">[4]</span></a></sup>上介绍校验和需要构造包含来源&#x2F;目标IP地址的<code>pseudo-header</code>，还好上文提到的<code>icmp</code>库已经封装了这个功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>    routerIP = net.ParseIP(<span class="hljs-string">&quot;fe80::1&quot;</span>) <span class="hljs-comment">// 光猫ip</span><br>    mcastIP = net.ParseIP(<span class="hljs-string">&quot;ff02::1&quot;</span>) <span class="hljs-comment">// 组播ip</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br>    <span class="hljs-keyword">for</span> &#123;<br>       ...<br>        <span class="hljs-comment">// 修改其中的DNS信息</span><br>        err = replaceDNS(body)<br>        ...<br>        rm.Body = &amp;icmp.RawBody&#123;Data: body&#125;<br>        <br>        <span class="hljs-comment">// 自定义pseudo-header，重计算校验和</span><br>        head := icmp.IPv6PseudoHeader(routerIP, mcastIP)<br>        wb, err := rm.Marshal(head)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-comment">// 广播修改后的RA数据包</span><br>        err = sendMsg(zone, wb)<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>避免系统自动设置来源IP地址，比如直接发送构造好的以太网数据帧。经过一番搜寻，笔者发现stackoverflow上<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[IPv6 - Wikipedia](https://en.wikipedia.org/wiki/IPv6)">[7]</span></a></sup>已经有人提供了类似的demo，笔者只需要参考IPv6数据包的格式<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="[go - Send custom ethernet packet using raw socket - Stack Overflow](https://stackoverflow.com/questions/70655602/send-custom-ethernet-packet-using-raw-socket)">[8]</span></a></sup>组装IPv6数据即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(zone <span class="hljs-type">string</span>, icmpBody []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 指定来源mac地址&amp;目标mac地址</span><br>iface, err := net.InterfaceByName(zone)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;get link by name failed: %w&quot;</span>, err)<br>&#125;<br>srcMac := iface.HardwareAddr<br>dstMac := []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0x33</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>&#125; <span class="hljs-comment">// IPv6mcast_01</span><br><span class="hljs-comment">// 组装以太网帧头部</span><br>data := []<span class="hljs-type">byte</span>&#123;<br>dstMac[<span class="hljs-number">0</span>], dstMac[<span class="hljs-number">1</span>], dstMac[<span class="hljs-number">2</span>], dstMac[<span class="hljs-number">3</span>], dstMac[<span class="hljs-number">4</span>], dstMac[<span class="hljs-number">5</span>],<br>srcMac[<span class="hljs-number">0</span>], srcMac[<span class="hljs-number">1</span>], srcMac[<span class="hljs-number">2</span>], srcMac[<span class="hljs-number">3</span>], srcMac[<span class="hljs-number">4</span>], srcMac[<span class="hljs-number">5</span>],<br><span class="hljs-number">0x86</span>, <span class="hljs-number">0xdd</span>, <span class="hljs-comment">// Type: IPv6</span><br>&#125;<br><span class="hljs-comment">// 组装IPv6头部</span><br>length := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">2</span>)<br>binary.BigEndian.PutUint16(length, <span class="hljs-type">uint16</span>(<span class="hljs-built_in">len</span>(icmpBody)))<br>data = <span class="hljs-built_in">append</span>(data, []<span class="hljs-type">byte</span>&#123;<br><span class="hljs-number">0x60</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-comment">// ipv6.version</span><br>length[<span class="hljs-number">0</span>], length[<span class="hljs-number">1</span>], <span class="hljs-comment">// Payload Length</span><br><span class="hljs-number">0x3a</span>, <span class="hljs-comment">// Next Header: ICMPv6 (58)</span><br><span class="hljs-number">0xff</span>, <span class="hljs-comment">// Hop Limit: 255</span><br>&#125;...)<br>data = <span class="hljs-built_in">append</span>(data, routerIP...) <span class="hljs-comment">// 来源ip地址</span><br>data = <span class="hljs-built_in">append</span>(data, mcastIP...) <span class="hljs-comment">// 目标ip地址</span><br>    <span class="hljs-comment">// 组装ICMPv6数据</span><br>data = <span class="hljs-built_in">append</span>(data, icmpBody...)<br><br><span class="hljs-comment">// 发送以太网帧</span><br>fd, err := syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW, <span class="hljs-type">int</span>(htons(syscall.ETH_P_ALL)))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;call socket failed: %w&quot;</span>, err)<br>&#125;<br>addr := syscall.SockaddrLinklayer&#123;<br>Ifindex: iface.Index,<br>Halen:   <span class="hljs-number">6</span>, <span class="hljs-comment">// Ethernet address length is 6 bytes</span><br>Addr:    [<span class="hljs-number">8</span>]<span class="hljs-type">byte</span>&#123;dstMac[<span class="hljs-number">0</span>], dstMac[<span class="hljs-number">1</span>], dstMac[<span class="hljs-number">2</span>], dstMac[<span class="hljs-number">3</span>], dstMac[<span class="hljs-number">4</span>], dstMac[<span class="hljs-number">5</span>]&#125;,<br>&#125;<br>err = syscall.Sendto(fd, data, <span class="hljs-number">0</span>, &amp;addr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;call sendto failed: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="6-效果"><a href="#6-效果" class="headerlink" title="6. 效果"></a>6. 效果</h1><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230219210347954.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20230219210512956.webp"></th></tr></thead></table><p>最后的效果证明笔者的猜想没错。在手动将IPv6数据包的来源IP地址设置为<code>fe80::1</code>后，PC正常获取到了IPv6地址，并设置了自定义DNS。唯一美中不足的是，PC的首选DNS地址地址还是光猫。不过我们还可以在软交换机上打个补丁，禁止向光猫发送DNS请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ebtables -A FORWARD -p IPv6 -d &#123;光猫MAC地址&#125; --ip6-protocol udp --ip6-destination-port 53 -j DROP<br></code></pre></td></tr></table></figure><p>这样，PC就只能使用备用DNS，也就是我们自定义的DNS了。</p><p>尽管最终效果并不完美，这篇文章的解决方案也并不实用（软路由+桥接才是终极解决方案），但相比于结果，笔者更享受的是发现问题、解决问题的过程。能写出这篇文章真是太棒了！</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="/2022/12/17/%E5%AE%89%E5%8D%93%E5%AF%B9%E6%8C%87%E5%AE%9AWiFi%E7%A6%81%E7%94%A8IPv6/">安卓对指定WiFi禁用IPv6</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="/2022/12/28/%E5%81%B7%E5%A4%A9%E6%8D%A2%E6%97%A5%EF%BC%9A%E5%B1%8F%E8%94%BD%E5%85%89%E7%8C%AB%E7%9A%84IP%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D/">偷天换日：屏蔽光猫的IP地址自动分配</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://help.ubuntu.com/community/NetworkConnectionBridge">NetworkConnectionBridge - Community Help Wiki</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/ICMPv6">ICMPv6 - Wikipedia</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.rfc-editor.org/rfc/rfc6106">RFC 6106: IPv6 Router Advertisement Options for DNS Configuration</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/IPv6">IPv6 - Wikipedia</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://stackoverflow.com/questions/70655602/send-custom-ethernet-packet-using-raw-socket">go - Send custom ethernet packet using raw socket - Stack Overflow</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>IPv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS安装lxml报错&#39;Python.h&#39; file not found</title>
    <link href="/2023/01/16/install-lxml-on-mac/"/>
    <url>/2023/01/16/install-lxml-on-mac/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>macOS环境：Ventura 13.0 (Apple Silicon)</p><p>Python版本：3.9.6</p></blockquote><p>lxml是笔者常用的html内容解析库。但笔者在macOS上安装lxml时碰到了如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install lxml<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">...<br>src/lxml/etree.c:96:10: fatal error: &#x27;Python.h&#x27; file not found<br>      #include &quot;Python.h&quot;<br>               ^~~~~~~~~~<br>...<br></code></pre></td></tr></table></figure><p>这篇文章简单记录下解决方案。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li><p>找到<code>Python.h</code>文件所处位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo find / -iname &quot;Python.h&quot;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">...<br>/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Headers/Python.h<br>/Library/umad/Python.framework/Versions/3.8/include/python3.8/Python.h<br>/Library/Crypt/Python.framework/Versions/3.8/include/python3.8/Python.h<br>...<br></code></pre></td></tr></table></figure></li><li><p>笔者使用的Python版本为3.9，将对应版本的文件夹设置到环境变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> C_INCLUDE_PATH=/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/Headers/<br></code></pre></td></tr></table></figure></li><li><p>重新安装，搞定</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">...<br>Successfully built lxml<br>Installing collected packages: lxml<br>Successfully installed lxml-4.9.2<br></code></pre></td></tr></table></figure></li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://stackoverflow.com/questions/35778495/fatal-error-python-h-file-not-found-while-installing-opencv">macos - fatal error: ‘Python.h’ file not found while installing opencv - Stack Overflow</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年度总结</title>
    <link href="/2022/12/31/2022-annual-summary/"/>
    <url>/2022/12/31/2022-annual-summary/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知不觉中又过了一年。2022年，我在那些对自己最重要的事情上有什么进展呢？我是否依然坚定地走在我自己的那条路上？</p><p>或许，这篇文章能让问题的答案更加清晰。</p><h1 id="1-身体健康"><a href="#1-身体健康" class="headerlink" title="1. 身体健康"></a>1. 身体健康</h1><ul><li>今年去了约100次健身房（公司总打卡305次、私教30+次），深蹲做组突破1倍体重；疫情宅家期间使用跳绳、哑铃锻炼。</li><li>4月份首次尝试参加爬山活动，之后陆续去了三次，第四次爬上了北京最高峰。</li><li>购置电动升降桌、升降台避免久坐；拔掉智齿应对龋齿；使用药物对抗脱发；进行果酸治疗改善皮肤状况。</li></ul><p>总体而言我的健康状况比较稳定。近视、甲亢没有恶化；平时很少感冒，疫情管控放开后也没有感染。身材没有变好有点可惜，希望明年能继续健身、爬山、关注各部位情况。</p><h1 id="2-心理健康"><a href="#2-心理健康" class="headerlink" title="2. 心理健康"></a>2. 心理健康</h1><ul><li>阅读了5本心理学相关的书籍，在日记中持续给自己积极的心理暗示，参加了公司的积极心理训练营。</li><li>在日常生活中增加了和他人的沟通和互动，提高了参加集体活动、寻找恋爱机会的频率。</li><li>开始尝试在工作之外寻求更多成就感&#x2F;认同感&#x2F;归属感。</li></ul><p>总体而言我的心理健康程度、人际关系都有改善。但孤独感始终困扰着我，希望明年能进一步增强自我认知、保持轻松愉快的心情。</p><h1 id="3-财务状况"><a href="#3-财务状况" class="headerlink" title="3. 财务状况"></a>3. 财务状况</h1><ul><li>收入相比超出预期的去年来说略有下降；支出略有上升，主要集中于住房&#x2F;饮食&#x2F;体验方面。</li><li>投资策略保持跟随+低调仓频率，基金账户亏损8%+，表现好于市场均值。</li><li>净资产增幅令人满意，流动资产充裕。</li></ul><p>总体而言我的财务状况健康程度、抗风险能力依然比较强。收入依赖工资目前来看不是问题，但随着我对净资产的增长越来越不敏感，或许我需要重新考虑金钱在我人生中的定位。</p><h1 id="4-职业发展"><a href="#4-职业发展" class="headerlink" title="4. 职业发展"></a>4. 职业发展</h1><ul><li>较长的居家办公经历让我意识到，是否在现场办公并不是影响我工作效率的关键因素。</li><li>工作上遇到了瓶颈和危机，取得了少量突破。</li><li>短期目标摇摆不定，缺少长期发展规划。</li></ul><p>总体而言我的职业发展在今年陷入了低潮。希望明年能更多地思考自己的定位、明确未来的发展规划。</p><h1 id="5-个人爱好"><a href="#5-个人爱好" class="headerlink" title="5. 个人爱好"></a>5. 个人爱好</h1><ul><li>阅读了28本书籍，观看了24部电影、20部左右动漫。和以往相比，将更多的精力放在了阅读、总结和思考上。</li><li>下半年重新开始对开源社区作贡献，并尝试用博客分享自己的生活。</li><li>扩展了爬山活动，体验了声乐训练、攀岩、线下交友等一系列活动，在研究改善室内环境、HomeLab等方面收获了很多乐趣。</li></ul><p>总体而言今年凭兴趣做了很多事情，周末过得都比较开心。希望能明年能继续发掘生活中的乐趣。</p><table><thead><tr><th>博文</th><th>Github</th></tr></thead><tbody><tr><td><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20221231191016046.webp"></td><td><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20221231191102003.webp"></td></tr></tbody></table><table><thead><tr><th>书籍</th><th>电影</th><th>动漫</th></tr></thead><tbody><tr><td><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20221231162010125.webp"></td><td><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20221231162038502.webp"></td><td><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20221231185802364.webp"></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H2-2光猫配置IPv6防火墙</title>
    <link href="/2022/12/31/h2-2-modem-ip6tables/"/>
    <url>/2022/12/31/h2-2-modem-ip6tables/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>IPv6相比IPv4的一大优势是IP地址空间充足。以笔者的中国移动宽带为例，光猫可以从运营商处获得2409开头的<code>/64</code>公网网段，连接至光猫的设备可自动获得公网IPv6地址：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20221228.home_network.svg" alt="笔者家庭网络架构"></p><p>但处于安全考虑，光猫的IPv6防火墙会默认禁用所有入站连接，导致其它公网设备无法直连光猫防火墙内部的设备：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20221231.home_network.svg" alt="光猫入站防火墙"></p><p>幸运的是，笔者使用的中国移动H2-2光猫在网上有大量使用教程，可以通过配置IPv6防火墙的方式解决这个问题。</p><h1 id="2-开启光猫telnet功能"><a href="#2-开启光猫telnet功能" class="headerlink" title="2. 开启光猫telnet功能"></a>2. 开启光猫telnet功能</h1><ul><li><p>用普通账号登录光猫管理后台（<a href="http://192.168.1.1/">http://192.168.1.1/</a>），可以看到非常简陋的配置界面。</p><p> <img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgoimage-20221231122943385.webp"></p></li><li><p>此时可以手动跳转至telnet设置界面（<a href="http://192.168.1.1/getpage.gch?pid=1002&nextpage=tele_sec_tserver_t.gch">http://192.168.1.1/getpage.gch?pid=1002&nextpage=tele_sec_tserver_t.gch</a>），开启光猫的telnet功能。</p><ul><li><p>勾选“启用Telnet”，点击确定保存</p></li><li><p>然后勾选“启用LAN侧Telnet”，再次点击确定保存</p></li></ul><p> <img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221229214607170.webp"></p></li><li><p>在Chrome浏览器控制台中运行<code>document.getElementById(&quot;Frm_TSPassword&quot;).type = &quot;text&quot;</code>命令可显示telnet密码。</p><ul><li>不过好像所有的H2-2光猫telnet密码都是<code>aDm8H%MdA</code>，且无法通过这个页面更改</li></ul><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/picgo/image-20221231123702628.webp"></p></li><li><p>在本机命令行中运行telnet命令即可登录至光猫，并通过su命令获取root权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">~ telnet 192.168.1.1<br>Trying 192.168.1.1...<br>Connected to 192.168.1.1.<br>Escape character is &#x27;^]&#x27;.<br><br>Login: CMCCAdmin<br>Password:<br>~ $ su<br>Password:<br>/ #<br></code></pre></td></tr></table></figure></li></ul><h1 id="3-自动登录telnet脚本"><a href="#3-自动登录telnet脚本" class="headerlink" title="3. 自动登录telnet脚本"></a>3. 自动登录telnet脚本</h1><p>考虑到telnet登录比较繁琐，所以笔者编写了一个<code>expect</code><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://linux.die.net/man/1/expect">[1]</span></a></sup>脚本，用于自动登录光猫：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"> ~ cat ~/scripts/telnet_modem<br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/usr/bin/env expect</span><br>set timeout 5<br>set host &quot;192.168.1.1&quot;<br>set user &quot;CMCCAdmin&quot;<br>set pwd &quot;aDm8H%MdA&quot;<br><br>spawn telnet $host<br>expect &quot;Login: &quot;<br>send &quot;$user\n&quot;<br>sleep 0.1<br>expect &quot;Password: &quot;<br>send &quot;$pwd\n&quot;<br>sleep 0.1<br>expect &quot;~ $ &quot;<br>send &quot;su\n&quot;<br>sleep 0.1<br>expect &quot;Password: &quot;<br>send &quot;$pwd\n&quot;<br>sleep 0.1<br>interact<br></code></pre></td></tr></table></figure><p>运行该脚本后即可登录光猫并获取root权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"> ~ ~/scripts/telnet_modem<br>spawn telnet 192.168.1.1<br>Trying 192.168.1.1...<br>Connected to 192.168.1.1.<br>Escape character is &#x27;^]&#x27;.<br><br>Login: CMCCAdmin<br>Password:<br>~ $ su<br>Password:<br>/ #<br></code></pre></td></tr></table></figure><h1 id="4-配置IPv6防火墙"><a href="#4-配置IPv6防火墙" class="headerlink" title="4. 配置IPv6防火墙"></a>4. 配置IPv6防火墙</h1><p>光猫的IPv6防火墙可通过<code>ip6tables</code>命令直接配置。登录光猫后运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip6tables -I FORWARD -p tcp -m multiport --dports 10000:10009,12345 -j ACCEPT<br>ip6tables -I FORWARD -p udp -m multiport --dports 10000:10009,12345 -j ACCEPT<br></code></pre></td></tr></table></figure><p>即可让光猫转发目标端口为10000~10009、12345的tcp&#x2F;udp流量。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20221231.home_network_ip6tables.svg" alt="光猫入站防火墙"></p><h1 id="5-持久化IPv6防火墙"><a href="#5-持久化IPv6防火墙" class="headerlink" title="5. 持久化IPv6防火墙"></a>5. 持久化IPv6防火墙</h1><p>光猫重启后以上设置的防火墙规则会被清除，其它文章<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[【移动光猫H2-2的完全破解心路历程及配置】\_zsuroy的博客-CSDN博客\_h2-2光猫](https://blog.csdn.net/zsuroy/article/details/127002555#t7)">[2]</span></a></sup>提到的持久化方式笔者没能复现。所以笔者编写了一个Python脚本用于配置防火墙端口，并通过crontab定期执行来实现持久化地效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">import</span> telnetlib<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>need_forward = &#123;<span class="hljs-string">&#x27;10000:10009&#x27;</span>, <span class="hljs-string">&#x27;12345&#x27;</span>&#125;  <span class="hljs-comment"># 需开放端口</span><br>host, timeout = <span class="hljs-string">&#x27;192.168.1.1&#x27;</span>, <span class="hljs-number">3</span><br>user, pwd = <span class="hljs-string">&#x27;CMCCAdmin&#x27;</span>, <span class="hljs-string">&#x27;aDm8H%MdA&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(datetime.now())[:<span class="hljs-number">19</span>])<br><span class="hljs-comment"># 登录路由器</span><br>tn = telnetlib.Telnet(host, timeout=timeout)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exec</span>(<span class="hljs-params">expect: <span class="hljs-built_in">str</span>, command: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    expectBytes = expect.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    content = tn.read_until(expectBytes, timeout=timeout)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> content.endswith(expectBytes):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;expect &#123;&#125;, got &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">repr</span>(expect), <span class="hljs-built_in">repr</span>(content.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))))<br>    tn.write(command.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>) + <span class="hljs-string">b&#x27;\n&#x27;</span>)<br>    <span class="hljs-comment"># print(repr(content.decode(&#x27;utf-8&#x27;)))</span><br>    <span class="hljs-keyword">return</span> content.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;Login: &#x27;</span>, user)<br><span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;Password: &#x27;</span>, pwd)<br><span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;~ $ &#x27;</span>, <span class="hljs-string">&#x27;su&#x27;</span>)<br><span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;Password: &#x27;</span>, pwd)<br><br><span class="hljs-comment"># 查询已开放端口</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">forwarded_ports</span>() -&gt; <span class="hljs-built_in">set</span>:<br>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;/ # &#x27;</span>, <span class="hljs-string">&#x27;ip6tables -L FORWARD&#x27;</span>)<br>    forwarded = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;/ # &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).split(<span class="hljs-string">&#x27;\n&#x27;</span>):<br>        line = line.strip()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line.startswith(<span class="hljs-string">&#x27;ACCEPT&#x27;</span>):<br>            <span class="hljs-keyword">continue</span><br>        forwarded.update(line.split()[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>))<br>    <span class="hljs-keyword">return</span> forwarded<br>forwarded = forwarded_ports()<br><span class="hljs-comment"># print(&#x27;forwarded: &#x27;, forwarded)</span><br><br><span class="hljs-comment"># 新增未开放端口</span><br>new_ports = need_forward - forwarded<br><span class="hljs-keyword">if</span> new_ports:<br>    ports_str = <span class="hljs-string">&#x27;,&#x27;</span>.join(new_ports)<br>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;/ # &#x27;</span>, <span class="hljs-string">&#x27;ip6tables -I FORWARD -p tcp -m multiport --dports &#123;&#125; -j ACCEPT&#x27;</span>.<span class="hljs-built_in">format</span>(ports_str))<br>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">&#x27;/ # &#x27;</span>, <span class="hljs-string">&#x27;ip6tables -I FORWARD -p udp -m multiport --dports &#123;&#125; -j ACCEPT&#x27;</span>.<span class="hljs-built_in">format</span>(ports_str))<br>    forwarded = forwarded_ports()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;forwarded: &#x27;</span>, forwarded)<br><br>tn.close()<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crontab">*/1 * * * * /home/worker/scripts/cron/router_ip6tables.py &gt;&gt; ~/ram/router_ip6tables.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h1 id="6-后记"><a href="#6-后记" class="headerlink" title="6. 后记"></a>6. 后记</h1><p>网上其它文章<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[彻底玩转移动H2-2光猫——移动光猫中的五五开，不论路由还是桥接它都行-光猫/adsl/cable无线一体机-恩山无线论坛](https://www.right.com.cn/forum/thread-6054306-1-1.html)">[3]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[【求助】解密中国移动H2-3E配置文件-光猫/adsl/cable无线一体机-恩山无线论坛](https://www.right.com.cn/FORUM/thread-5569630-1-1.html)">[4]</span></a></sup>详细介绍了如何获取光猫宽带拨号&#x2F;超级管理员账号密码、如何桥接路由器。但对于可以屏蔽光猫IP地址自动分配<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[偷天换日：屏蔽光猫的IP地址自动分配](/2022/12/28/偷天换日：屏蔽光猫的IP地址自动分配/)">[5]</span></a></sup>、配置光猫防火墙的笔者来说，桥接已经没有什么吸引力了。另外笔者发现，即使通过超级管理员登录光猫后台，在网页上配置DMZ&#x2F;虚拟主机配置等防火墙规则也不会实际生效，实在离谱。</p><p>不可否认的是，桥接在绝大多数场景都是一步到位的便捷选择。但对于不方便进行桥接的笔者来说，<code>iptables</code>真香。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><a href="https://www.v2ex.com/t/844130">打通移动宽带 IPv6 的公网访问 - V2EX</a></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://linux.die.net/man/1/expect">https://linux.die.net/man/1/expect</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/zsuroy/article/details/127002555#t7">【移动光猫H2-2的完全破解心路历程及配置】_zsuroy的博客-CSDN博客_h2-2光猫</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.right.com.cn/forum/thread-6054306-1-1.html">彻底玩转移动H2-2光猫——移动光猫中的五五开，不论路由还是桥接它都行-光猫&#x2F;adsl&#x2F;cable无线一体机-恩山无线论坛</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.right.com.cn/FORUM/thread-5569630-1-1.html">【求助】解密中国移动H2-3E配置文件-光猫&#x2F;adsl&#x2F;cable无线一体机-恩山无线论坛</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="/2022/12/28/%E5%81%B7%E5%A4%A9%E6%8D%A2%E6%97%A5%EF%BC%9A%E5%B1%8F%E8%94%BD%E5%85%89%E7%8C%AB%E7%9A%84IP%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D/">偷天换日：屏蔽光猫的IP地址自动分配</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>IPv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>偷天换日：屏蔽光猫的IP地址自动分配</title>
    <link href="/2022/12/28/%E5%81%B7%E5%A4%A9%E6%8D%A2%E6%97%A5%EF%BC%9A%E5%B1%8F%E8%94%BD%E5%85%89%E7%8C%AB%E7%9A%84IP%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D/"/>
    <url>/2022/12/28/%E5%81%B7%E5%A4%A9%E6%8D%A2%E6%97%A5%EF%BC%9A%E5%B1%8F%E8%94%BD%E5%85%89%E7%8C%AB%E7%9A%84IP%E5%9C%B0%E5%9D%80%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20221228.home_network.svg" alt="笔者家庭网络架构"></p><p>在之前的文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[2022-12-17-安卓对指定WiFi禁用IPv6](/2022/12/17/安卓对指定WiFi禁用IPv6/)">[1]</span></a></sup>中，笔者苦于安卓对IPv6的支持不佳，所以在手机已root的情况下使用tasker应用+命令行让安卓设备连接指定wifi后禁用IPv6。但这种方案并不完美：</p><ul><li>首先需要保证tasker应用始终在后台运行（笔者会定时进入清空后台的深度省电模式）</li><li>其次tasker并不能保证每次都禁用IPv6成功（可能和笔者选择只运行一条命令有关）</li></ul><p>所以笔者的目光还是转向了更为彻底的解决思路：屏蔽光猫的IP地址自动分配功能，从而让安卓不使用IPv6网络。考虑到笔者并不对光猫有完全的控制权，所以笔者主要从无线AP上入手。</p><h1 id="2-IP地址自动分配原理"><a href="#2-IP地址自动分配原理" class="headerlink" title="2. IP地址自动分配原理"></a>2. IP地址自动分配原理</h1><h2 id="2-1-IPv4"><a href="#2-1-IPv4" class="headerlink" title="2.1 IPv4"></a>2.1 IPv4</h2><p>局域网内的IPv4地址普遍使用DHCP协议来进行自动分配。按照维基百科<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[动态主机设置协议 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE)">[2]</span></a></sup>的描述，DHCP是一个使用UDP协议的应用层协议，其使用端口为67&#x2F;68的UDP协议。通过wireshark抓包，我们可以很容易发现它的存在：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221228225910186.webp" alt="DHCP抓包"></p><h2 id="2-2-IPv6"><a href="#2-2-IPv6" class="headerlink" title="2.2 IPv6"></a>2.2 IPv6</h2><p>局域网内的IPv6地址可以通过两种方式自动分配：有状态的DHCPv6<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[DHCPv6 - Wikipedia](https://en.wikipedia.org/wiki/DHCPv6#cite_note-rfc4339-1)">[3]</span></a></sup>、无状态的SLAAC<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[IPv6 - Wikipedia](https://en.wikipedia.org/wiki/IPv6#Stateless_address_autoconfiguration_(SLAAC))">[4]</span></a></sup><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[IPv6 address - Wikipedia](https://en.wikipedia.org/wiki/IPv6_address#Stateless_address_autoconfiguration)">[5]</span></a></sup>。出于配置的便捷性考虑，目前使用后者的设备更为常见，包括笔者的光猫。除了上一篇文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[2022-12-17-安卓对指定WiFi禁用IPv6](/2022/12/17/安卓对指定WiFi禁用IPv6/)">[1]</span></a></sup>引用的资料<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[IPv6系列基础篇（下）—邻居发现协议NDP - 锐捷网络](https://www.ruijie.com.cn/jszl/83220/)">[6]</span></a></sup>，另一篇文章也<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[IPv6 Stateless Address Auto-configuration (SLAAC) | NetworkAcademy.io](https://www.networkacademy.io/ccna/ipv6/stateless-address-autoconfiguration-slaac)">[7]</span></a></sup>用动图很好地描述了SLAAC分配地址的过程。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/ipv6-stateless-address-autoconfiguration.gif"></p><p>SLAAC使用的是网络层的ICMPv6协议，同样，我们可以用Wireshark来发现它的存在：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221228232047709.webp" alt="SLAAC抓包"></p><h1 id="3-施工"><a href="#3-施工" class="headerlink" title="3. 施工"></a>3. 施工</h1><h2 id="3-1-替换IPv4-DHCP"><a href="#3-1-替换IPv4-DHCP" class="headerlink" title="3.1 替换IPv4 DHCP"></a>3.1 替换IPv4 DHCP</h2><p>笔者通过搜寻得知，部分可配置交换机上有一个叫DHCP snooping<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="[DHCP snooping - 維基百科，自由的百科全書](https://zh.wikipedia.org/zh-tw/DHCP_snooping)">[8]</span></a></sup>的功能，可以屏蔽恶意DHCP服务器。继续搜寻得知，Linux上可以使用<code>ebtables</code>实现类似的效果<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="[linux - iptables dhcp snooping - Unix & Linux Stack Exchange](https://unix.stackexchange.com/questions/352231/iptables-dhcp-snooping)">[9]</span></a></sup>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ebtables -A FORWARD --protocol ipv4 --ip-proto udp --ip-dport 67:68 -j DROP<br></code></pre></td></tr></table></figure><p><code>ebtables</code><sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="[ebtables(8) - Linux man page](https://linux.die.net/man/8/ebtables)">[10]</span></a></sup>是一个能控制网桥中以太网帧流量的工具。刚好笔者的无线AP是一个运行着Padavan（嵌入式linux系统）的路由器，也可以使用该工具。于是笔者在无线AP上运行如下命令，即可屏蔽来自光猫的IPv4 DHCP服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ebtables -A FORWARD -p IPv4 -s $&#123;光猫的MAC地址&#125; --ip-proto udp --ip-dport 67:68 -j DROP<br></code></pre></td></tr></table></figure><p>在无线AP上启用DHCP服务器后，网络架构变成了下面的形式，这样笔者就不需要手动设置透明代理网关了：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221228234014958.webp" alt="无线AP设置"></p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20221228.home_network_replace_dhcp.svg"></p><h2 id="3-2-屏蔽IPv6-SLAAC"><a href="#3-2-屏蔽IPv6-SLAAC" class="headerlink" title="3.2 屏蔽IPv6 SLAAC"></a>3.2 屏蔽IPv6 SLAAC</h2><p>屏蔽SLAAC协议的核心是屏蔽ICMPv6协议，而<code>ebtables</code>作为能控制以太网帧的工具应该也能做到。虽然<code>ebtables</code>的man page<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="[ebtables(8) - Linux man page](https://linux.die.net/man/8/ebtables)">[10]</span></a></sup>页面没有说明如何屏蔽该协议，但神奇的是笔者在Azure的代码仓库内<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="[azure-container-networking/ebtables.go at v1.4.39 · Azure/azure-container-networking](https://github.com/Azure/azure-container-networking/blob/v1.4.39/ebtables/ebtables.go#L111)">[11]</span></a></sup>找到了对应的使用例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Drop Icmpv6 discovery messages going out of interface</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DropICMPv6Solicitation</span><span class="hljs-params">(interfaceName <span class="hljs-type">string</span>, action <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>table := Filter<br>chain := Forward<br><br>rule := fmt.Sprintf(<span class="hljs-string">&quot;-p IPv6 --ip6-proto ipv6-icmp --ip6-icmp-type neighbour-solicitation -o %s -j DROP&quot;</span>,<br>interfaceName)<br><br><span class="hljs-keyword">return</span> runEbCmd(table, action, chain, rule)<br>&#125;<br></code></pre></td></tr></table></figure><p>于是笔者在无线AP上运行如下命令，即可屏蔽来自光猫的ICMPv6数据包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ebtables -A FORWARD -p IPv6 -s $&#123;光猫的MAC地址&#125; --ip6-proto ipv6-icmp -j DROP<br></code></pre></td></tr></table></figure><p>不过虽然此时安卓设备无法通过光猫获取到IPv6地址，但有线连接无线AP的AIO主机依然能正常获取IPv6地址，笔者推测这和无线AP的特殊软硬件设置有关。至此，笔者的改造完美达到目标，家庭网络架构变成了这种形式：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/svg/20221229.home_network_block_icmp.svg"></p><p>无IPv6、自动设置透明代理网关，笔者又能顺畅地使用安卓设备了。</p><h1 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h1><p>如果对光猫拥有完全的控制权，在光猫上开启桥接模式、让个人的路由设备进行拨号可能才是最完善的解决方案。特别是如今家用宽带已经开始分配公网IPv6网段，如果能用合理设置防火墙，笔者的AIO主机就能直接在公网提供服务。希望这一天能早日到来。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="/2022/12/17/%E5%AE%89%E5%8D%93%E5%AF%B9%E6%8C%87%E5%AE%9AWiFi%E7%A6%81%E7%94%A8IPv6/">2022-12-17-安卓对指定WiFi禁用IPv6</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE">动态主机设置协议 - 维基百科，自由的百科全书</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/DHCPv6#cite_note-rfc4339-1">DHCPv6 - Wikipedia</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/IPv6#Stateless_address_autoconfiguration_(SLAAC)">IPv6 - Wikipedia</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/IPv6_address#Stateless_address_autoconfiguration">IPv6 address - Wikipedia</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://www.ruijie.com.cn/jszl/83220/">IPv6系列基础篇（下）—邻居发现协议NDP - 锐捷网络</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://www.networkacademy.io/ccna/ipv6/stateless-address-autoconfiguration-slaac">IPv6 Stateless Address Auto-configuration (SLAAC) | NetworkAcademy.io</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://zh.wikipedia.org/zh-tw/DHCP_snooping">DHCP snooping - 維基百科，自由的百科全書</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://unix.stackexchange.com/questions/352231/iptables-dhcp-snooping">linux - iptables dhcp snooping - Unix &amp; Linux Stack Exchange</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span><a href="https://linux.die.net/man/8/ebtables">ebtables(8) - Linux man page</a><a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:11" class="footnote-text"><span><a href="https://github.com/Azure/azure-container-networking/blob/v1.4.39/ebtables/ebtables.go#L111">azure-container-networking&#x2F;ebtables.go at v1.4.39 · Azure&#x2F;azure-container-networking</a><a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>IPv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Prometheus监控硬盘SMART信息</title>
    <link href="/2022/12/23/%E7%94%A8Prometheus%E7%9B%91%E6%8E%A7%E7%A1%AC%E7%9B%98SMART%E4%BF%A1%E6%81%AF/"/>
    <url>/2022/12/23/%E7%94%A8Prometheus%E7%9B%91%E6%8E%A7%E7%A1%AC%E7%9B%98SMART%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>笔者的NAS（或者说ALL IN ONE主机）内有两块3.5寸的机械硬盘。群晖、TrueNAS等系统内置了比较完善的监控，可通过SMART信息（参数、温度、通电时长等）观察硬盘健康状况。可惜笔者使用的是Ubuntu系统，只能定期通过命令行进行检查。为了更方便地掌握硬盘的健康状况，笔者决定搭建一套关于硬盘的监控解决方案。</p><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h1><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221223093351427.webp" alt="Prometheus架构图"></p><p>由于笔者已经搭建了一套Prometheus监控套件，所以该解决方案也会基于Prometheus搭建。我们可以像之前的文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[监控室内空气质量](/2022/12/05/监控室内空气质量/)">[1]</span></a></sup>一样通过代码上报SMART信息，但监控硬盘作为比较通用的需求，应该已经有成熟方案了。果不其然，<a href="https://github.com/prometheus-community/node-exporter-textfile-collector-scripts">node-exporter-textfile-collector-scripts</a>仓库提供了SMART信息抓取脚本，可通过node_exporter的<code>textfile-collector</code>提供给Promethues。整体的流程如下所示：</p><pre><code class=" mermaid">flowchart LR    A[数据抓取脚本]--sponge--&gt;B[.prom文件]    C[node_exporter]--读取--&gt;B    D[Promethues]--pull--&gt;C    D--&gt;E[Alertmanager]    E--&gt;G[Telegram告警]    F[Grafana监控]--&gt;D    style A stroke-dasharray:5    style B stroke-dasharray:5</code></pre><h1 id="3-施工"><a href="#3-施工" class="headerlink" title="3. 施工"></a>3. 施工</h1><ol><li><p>下载抓取脚本。克隆仓库后，使用root权限命令执行<code>smartmon.sh</code>即可看到SMART输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:prometheus-community/node-exporter-textfile-collector-scripts.git<br>cd node-exporter-textfile-collector-scripts<br>sudo ./smartmon.sh<br></code></pre></td></tr></table></figure><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221223095133005.webp"></p><p>同时按照仓库的推荐，安装sponge用于输出重定向：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install moreutils<br></code></pre></td></tr></table></figure></li><li><p>定时运行脚本并保存结果。由于获取SMART信息需要root权限，所以笔者使用root用户的crontab，每分钟运行一次抓取脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo crontab -e<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crontab">* * * * * /home/worker/git/prometheus-community/node-exporter-textfile-collector-scripts/smartmon.sh | sponge /home/worker/log/smartmon.prom 2&gt;/home/worker/log/smartmon.stderr<br></code></pre></td></tr></table></figure><p>之所以使用sponge而不是管道进行输出重定向，是因为shell在进行输出重定向时会先清空原文件，导致node_exporter在读取时有机率读取到空数据。验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">head</span> ~/log/smartmon.prom</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">HELP smartmon_smartctl_version SMART metric smartctl_version</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">TYPE smartmon_smartctl_version gauge</span><br>smartmon_smartctl_version&#123;version=&quot;7.1&quot;&#125; 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br></code></pre></td></tr></table></figure></li><li><p>配置node_exporter。在运行node_exporter时指定<code>textfile-collector</code>目录，然后可通过curl验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shel">node_exporter --collector.textfile.directory=&#x27;/home/worker/log/&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:9100/metrics</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">HELP smartmon_smartctl_version SMART metric smartctl_version</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">TYPE smartmon_smartctl_version gauge</span><br>smartmon_smartctl_version&#123;version=&quot;7.1&quot;&#125; 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br></code></pre></td></tr></table></figure></li><li><p>配置监控。有国外网友针对上述脚本配置了精美的Grafana面板并分享在了GrafanaLabs上<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[S.M.A.R.T Dashboard | Grafana Labs](https://grafana.com/grafana/dashboards/13654-s-m-a-r-t-dashboard/)">[2]</span></a></sup>，在Grafana上输入其ID<code>13654</code>即可导入：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221224091210859.webp"></p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221224091333135.webp"></p></li><li><p>修复面板。左上角<code>Unhealthy Disks</code>的原查询语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">sum</span>(smartmon_device_smart_healthy&#123;instance<span class="hljs-operator">=</span><span class="hljs-operator">~</span>&quot;$instance&quot;&#125;)<span class="hljs-operator">-</span><span class="hljs-built_in">sum</span>(smartmon_device_smart_healthy&#123;instance<span class="hljs-operator">=</span><span class="hljs-operator">~</span>&quot;$instance&quot;&#125;)<br></code></pre></td></tr></table></figure><p>由于减号两边相等，所以看起来这个查询结果永远为0。笔者发邮件询问了原作者，不过还没有得到回复。改动为如下查询语句应该应该能修复这个问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">count</span>(smartmon_device_smart_healthy&#123;instance<span class="hljs-operator">=</span><span class="hljs-operator">~</span>&quot;$instance&quot;&#125;)<span class="hljs-operator">-</span><span class="hljs-built_in">sum</span>(smartmon_device_smart_healthy&#123;instance<span class="hljs-operator">=</span><span class="hljs-operator">~</span>&quot;$instance&quot;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>设置告警。在alert配置文件（细节见之前的文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[监控室内空气质量](/2022/12/05/监控室内空气质量/)">[1]</span></a></sup>）中增加如下内容，promethues会在出现硬盘smart异常后对笔者进行告警：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">smart</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">unhealthy_disks</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">count(smartmon_device_smart_healthy)-sum(smartmon_device_smart_healthy)</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">10m</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;有不健康的硬盘&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="4-效果"><a href="#4-效果" class="headerlink" title="4. 效果"></a>4. 效果</h1><p>最终效果如下：</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221224091333135.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221224093415453.webp"></th></tr></thead><tbody><tr><td>Grafana看板</td><td>Telegram通知</td></tr></tbody></table><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="/2022/12/05/%E7%9B%91%E6%8E%A7%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F/">监控室内空气质量</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://grafana.com/grafana/dashboards/13654-s-m-a-r-t-dashboard/">S.M.A.R.T Dashboard | Grafana Labs</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓对指定WiFi禁用IPv6</title>
    <link href="/2022/12/17/%E5%AE%89%E5%8D%93%E5%AF%B9%E6%8C%87%E5%AE%9AWiFi%E7%A6%81%E7%94%A8IPv6/"/>
    <url>/2022/12/17/%E5%AE%89%E5%8D%93%E5%AF%B9%E6%8C%87%E5%AE%9AWiFi%E7%A6%81%E7%94%A8IPv6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>这是笔者之前的家庭网络架构，所有设备集中在宽带网关的二级 NAT 下，同时有一台旁路由设备用于透明代理：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/home_net_arch_old.drawio.svg"></p><p>后来由于某些设备有连接公网 IPv6 地址的需求，所以笔者将二级 NAT 改成了无线 AP ，所有设备直连宽带网关以拿到 IPv6 地址：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/home_net_arch_new.drawio.svg"></p><p>OP 的安卓设备在之前的网络架构中将旁路由作为网关。但在新的网络架构中，由于安卓设备无法设置静态 IPv6 ，所以 IPv6 流量无法经过旁路由；而且即使 OP 将安卓设备的 DNS 和 IPv4 网关设置为旁路由，但其 DNS 请求还是<strong>有可能</strong>直接发送到宽带网关上。</p><p>由于笔者对基于旁路由的透明代理和自定义DNS有较强需求，所以笔者决定让安卓设备在家庭网络中不使用IPv6（且不影响在其它网络环境中使用IPv6）。</p><h1 id="2-远程端控制（失败）"><a href="#2-远程端控制（失败）" class="headerlink" title="2. 远程端控制（失败）"></a>2. 远程端控制（失败）</h1><p>安卓设备通过无线AP接入网路，笔者首先想到的解决方案是在无线AP处进行控制。只要避免安卓设备获取到IPv6地址，问题就解决了。按照锐捷的文章介绍<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[IPv6系列基础篇（下）—邻居发现协议NDP - 锐捷网络](https://www.ruijie.com.cn/jszl/83220/)">[1]</span></a></sup>，主机无状态配置IPv6是通过 ICMPv6协议进行的：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221217114114257.webp" alt="IPv6主机无状态自动配置的过程"></p><p>但笔者在无线AP（运行着padavan系统的路由器）上用<code>tcpdump</code>探测安卓设备相关的网络流量，只发现了邻居请求（NS）的流量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcpdump -i br0 ether src $&#123;安卓mac&#125; or ether dst  $&#123;安卓mac&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">10:56:16.700518 IP6 :: &gt; ff02::1:ff48:xxx: ICMP6, neighbor solicitation, who has fe80::xxx, length 32<br>10:56:16.705741 IP6 :: &gt; ff02::16: HBH ICMP6, multicast listener report v2, 2 group record(s), length 48<br></code></pre></td></tr></table></figure><p>再考虑到ICMP是网络层协议，无法通过<code>iptables</code>等工具进行过滤，故笔者选择放弃。</p><h1 id="3-安卓端控制（成功）"><a href="#3-安卓端控制（成功）" class="headerlink" title="3. 安卓端控制（成功）"></a>3. 安卓端控制（成功）</h1><p>虽然不能阻止安卓设备获取IPv6地址，但我们依然可以直接在安卓端禁用IPv6功能。Reddit<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Disable IPv6 over wifi? : androiddev](https://www.reddit.com/r/androiddev/comments/k15y0a/disable_ipv6_over_wifi/)">[2]</span></a></sup>论坛有人指出，安卓在root后可以通过如下命令禁用WiFi的IPv6功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 0 | tee /proc/sys/net/ipv6/conf/wlan0/accept_ra<br>echo 1 | tee /proc/sys/net/ipv6/conf/all/disable_ipv6<br></code></pre></td></tr></table></figure><p>笔者通过JuiceSSH验证后确认有效，但重连WiFi后IPv6地址会恢复。再加上笔者只想在家庭网络禁用安卓的IPv6，所以笔者使用Tasker软件进行了额外配置：</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221217123841698.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221217123710721.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221217123755563.webp"></th></tr></thead><tbody><tr><td>在Tasker内创建一个配置</td><td>当WiFi连接到指定SSID</td><td>使用root执行对应命令</td></tr></tbody></table><p>配置完成后，保持Tasker运行，就可以让笔者的安卓设备在接入家庭网络时不使用IPv6了。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.ruijie.com.cn/jszl/83220/">IPv6系列基础篇（下）—邻居发现协议NDP - 锐捷网络</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.reddit.com/r/androiddev/comments/k15y0a/disable_ipv6_over_wifi/">Disable IPv6 over wifi? : androiddev</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>数码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>改善室内空气质量-加湿篇</title>
    <link href="/2022/12/10/%E6%94%B9%E5%96%84%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F-%E5%8A%A0%E6%B9%BF%E7%AF%87/"/>
    <url>/2022/12/10/%E6%94%B9%E5%96%84%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F-%E5%8A%A0%E6%B9%BF%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>在前一篇文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[改善室内空气质量-新风篇](/2022/12/09/改善室内空气质量-新风篇)">[1]</span></a></sup>中，笔者通过新风大幅优化了室内PM2.5和CO2指标。冬季的北京空气十分干燥，室外空气湿度可能低至20%。而低湿度的空气被新风源源不断送入室内，让室内空气湿度始终维持在较低的水平。考虑到舒适的室内湿度为40%~60%<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[房间湿度40%，不爱得病（家居健康）--科技--人民网](http://scitech.people.com.cn/n/2013/0702/c1007-22041057.html)">[2]</span></a></sup>，同时也为了解决低湿度带来的皮肤容易干燥、起床后口鼻不舒服等问题，笔者决定采取手段提升室内湿度。</p><h1 id="2-方案选择"><a href="#2-方案选择" class="headerlink" title="2. 方案选择"></a>2. 方案选择</h1><p>室内加湿器是比较直接的选择。笔者了解后发现市面上主要有两类加湿器：超声波加湿器、蒸发型加湿器。</p><table><thead><tr><th>品类</th><th>原理</th><th>加湿效果</th><th>价格</th><th>使用水质</th><th>清洗频率</th><th>安全性</th></tr></thead><tbody><tr><td>超声波加湿器</td><td>将水打碎成小水滴</td><td>强</td><td>低</td><td>纯净水</td><td>高</td><td>低<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[超声波加湿器，到底能不能用？\_科普中国网](https://www.kepuchina.cn/yc/202201/t20220107_3114895.shtml)">[3]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[韩国加湿器“杀人”事件最新调查：至少1.4万人死亡 加湿器还能用吗？\_新闻\_央视网(cctv.com)](http://m.news.cctv.com/2020/07/29/ARTITgCagrGFrX6jBuDWdLSn200729.shtml)">[4]</span></a></sup></td></tr><tr><td>蒸发型加湿器</td><td>让水蒸发</td><td>弱</td><td>高</td><td>无特殊要求</td><td>低</td><td>高</td></tr></tbody></table><p>由于原理限制，超声波加湿器会无差别地将水中杂质（细菌&#x2F;化学物质等）扩散到空气中。所以在使用超声波加湿器中，不仅要保证水质干净、还要频繁清洁加湿器，否则容易有安全风险。笔者并不想在使用加湿器时花费太多精力，所以选择了价格更贵、但更使用起来更便捷的蒸发型加湿器。具体型号的选择可以参考先看评测的视频<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[认真测了一个月！告诉你 2022 年哪款加湿器值得买\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1KD4y1e7nA/)">[5]</span></a></sup>。</p><p>影响蒸发型加湿器加湿效果的要素主要有三点：</p><ul><li><strong>温度</strong>。水的温度越高，加湿效果越好。</li><li><strong>蒸发面积</strong>。蒸发面积越大，加湿效果越好。</li><li><strong>风量</strong>。风量越大，加湿效果越好。</li></ul><h1 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h1><h2 id="3-1-改造空气净化器"><a href="#3-1-改造空气净化器" class="headerlink" title="3.1 改造空气净化器"></a>3.1 改造空气净化器</h2><p>在前一篇文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[改善室内空气质量-新风篇](/2022/12/09/改善室内空气质量-新风篇)">[1]</span></a></sup>中，笔者通过改造空气净化器实现了新风的效果。同商家还有将空气净化器改造成加湿器的套件，复用组件+价格低廉（￥200）两大优势让笔者立刻下了单。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210182921083.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210183141611.webp"></th></tr></thead></table><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210184130772.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210183820899.webp"></th></tr></thead></table><p>然而实际体验后，笔者发现这个加湿方案效果非常一般。中午开始加湿后，室内湿度从25%缓慢提升至30%，之后就停滞在30%左右。从耗水速度推测，这个加湿方案的实际加湿能力约为100ml&#x2F;h，而市面上常见的蒸发型加湿器加湿能力普遍能达到600ml&#x2F;h。</p><p>笔者分析之后，发现这个加湿方案在上文提到的加湿三要素上都做得较差：</p><ul><li><strong>温度</strong>。由于空气净化器接的是室外空气，而北京冬季室外温度往往在零下，所以空气净化器吹出的风温度也很低。</li><li><strong>蒸发面积</strong>。这个改装套件用了吸水网提升蒸发面积。水箱里水位较高时吸水网透风的部分较少、水位较低时高处的吸水网很难吸到水分。所以这个方案的蒸发面积始终比较低。</li><li><strong>风量</strong>。由于新风不需要太大风量，所以笔者一直让空气净化器保持在比较低的风量。</li></ul><h2 id="3-2-换用加湿器"><a href="#3-2-换用加湿器" class="headerlink" title="3.2 换用加湿器"></a>3.2 换用加湿器</h2><p>发现改造净化器的方案行不通后，笔者很快选择了一款“正经”的加湿器（￥600）。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210190138737.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210190514003.webp"></th></tr></thead></table><p>相比上一个加湿方案，这款加湿器在加湿三要素上都有改进：</p><ul><li><strong>温度</strong>。由于是直接放在室内，环境温度更高。</li><li><strong>蒸发面积</strong>。这款加湿器使用的滤芯（上图3号）位于水箱（上图8号）之上，水通过一个小管道提升到滤芯顶部，始终保证蒸发面积最大。</li><li><strong>风量</strong>。由于不和室外空气交换，所以调整加湿器风量时只需考虑噪音。</li></ul><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210191018549.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210191135433.webp"></th></tr></thead><tbody><tr><td><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210191233201.webp"></td><td><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210191440960.webp"></td></tr></tbody></table><p>笔者放置加湿器的房间面积约为17平米，温度约为25°。收到加湿器后，笔者在14:30用最大风量（比较吵）开始加湿，此时湿度不到30%；傍晚时室内湿度升高至50%。到了晚上23:30，笔者将加湿器调整为睡眠模式，室内湿度逐渐从50%下降到43%。从耗水速度来看，这款加湿器的实际能力是接近其宣传值（最大600ml&#x2F;h、睡眠模式260ml&#x2F;h）的。</p><p>虽然在日常使用时不能始终只开启睡眠模式，但考虑到其加水较为方便（将水箱拆除后可直接用水龙头加满5升水），所以总体而言笔者对这款加湿器的表现十分满意。</p><h1 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h1><p>相比其它效果更好（当然价格也更贵）的蒸发型加湿器，笔者选择的这款加湿器只适用于面积不大的房间。想要加湿更大的房价、甚至是全屋加湿，蒸发型加湿器就得考虑用电辅热提高效率了，可能这也是为什么许多工业级加湿器会选择超声波加湿的方案。加湿器的选择，更多也得结合具体的需求来看吧。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210200802577.webp"><br /><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[352 H300加湿净化一体机评测\_使用效果怎么样\_智能家](https://m.znj.com/news/120978.html)">[6]</span></a></sup></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221210200033630.webp"><br /><sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="[超声波加湿器除湿产品-加湿产品-防爆空调-恒温恒湿机-精密空调-转轮除湿机-湿美电气](http://m.msshimei.com/product.html?type1=2&type2=14)">[7]</span></a></sup></th></tr></thead><tbody><tr><td>加湿量2500ml&#x2F;h</td><td>加湿量3000ml&#x2F;h</td></tr></tbody></table><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="/2022/12/09/%E6%94%B9%E5%96%84%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F-%E6%96%B0%E9%A3%8E%E7%AF%87">改善室内空气质量-新风篇</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://scitech.people.com.cn/n/2013/0702/c1007-22041057.html">房间湿度40%，不爱得病（家居健康）–科技–人民网</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.kepuchina.cn/yc/202201/t20220107_3114895.shtml">超声波加湿器，到底能不能用？_科普中国网</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="http://m.news.cctv.com/2020/07/29/ARTITgCagrGFrX6jBuDWdLSn200729.shtml">韩国加湿器“杀人”事件最新调查：至少1.4万人死亡 加湿器还能用吗？_新闻_央视网(cctv.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1KD4y1e7nA/">认真测了一个月！告诉你 2022 年哪款加湿器值得买_哔哩哔哩_bilibili</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://m.znj.com/news/120978.html">352 H300加湿净化一体机评测_使用效果怎么样_智能家</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="http://m.msshimei.com/product.html?type1=2&type2=14">超声波加湿器除湿产品-加湿产品-防爆空调-恒温恒湿机-精密空调-转轮除湿机-湿美电气</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>监控</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>改善室内空气质量-新风篇</title>
    <link href="/2022/12/09/%E6%94%B9%E5%96%84%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F-%E6%96%B0%E9%A3%8E%E7%AF%87/"/>
    <url>/2022/12/09/%E6%94%B9%E5%96%84%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F-%E6%96%B0%E9%A3%8E%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>在上一篇文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[监控室内空气质量](/2022/12/05/监控室内空气质量/)">[1]</span></a></sup>中，笔者搭建了一套空气质量监控方案。但随之而来的是持续的告警以及糟糕的空气。最极端的时候，笔者能从监控上观察到超过100的室内PM2.5浓度。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209201254014.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209203204756.webp" alt="image-20221209203204756"></th></tr></thead></table><p>在下决心改善室内空气质量后，摆在笔者面前的有两个选择：<code>空气净化器</code>和<code>新风</code>。两者都可以降低室内PM2.5，但前者只能被动净化流入室内的室外空气（<del>先污染后治理</del>），而后者能主动净化室外空气并送入屋内，除了能降低室内PM2.5，还能保证低CO2浓度、避免室内积灰。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[新风系统VS空气净化器，它完美胜出！-苏州米亚智能科技有限公司MIAVENTILATION-新风系统-家用新风系统-新风系统OEM-全热交换器-新风换气机-新风机](http://www.miachina.net/MIANews?id=684)">[2]</span></a></sup></p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/20190724150419_3180.webp"></p><p>虽然新风会导致室内温湿度容易受室外影响，但在一众视频的诱惑下<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[新风消费者报告 | 爱否出品\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1A4411u7gg/?vd_source=834a38204871938e13afaddb910f3b67)">[3]</span></a></sup><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[25岁自装修｜新风最强「避坑指南」吐血整理！\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV18R4y1V7DV/?spm_id_from=333.337.search-card.all.click&vd_source=834a38204871938e13afaddb910f3b67)">[4]</span></a></sup>，笔者最终还是将目光锁定在了新风上。</p><h1 id="2-新风产品选择"><a href="#2-新风产品选择" class="headerlink" title="2. 新风产品选择"></a>2. 新风产品选择</h1><p>新风的形态多种多样，笔者了解到有如下几种。</p><h2 id="2-1-中央新风"><a href="#2-1-中央新风" class="headerlink" title="2.1 中央新风"></a>2.1 中央新风</h2><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209205604949.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209205820116.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209210021944.webp"></th></tr></thead></table><p>中央新风系统作为新风产品的顶级形态，被广泛运用于商场、写字楼等场合。虽然中央新风换气效果强大、还可以使用热交换来减少室外温度对室内的影响，但由于价格昂贵、且需要在装修房屋之前提前规划，所以在家庭场合较为少见。</p><h2 id="2-2-壁挂新风机"><a href="#2-2-壁挂新风机" class="headerlink" title="2.2  壁挂新风机"></a>2.2  壁挂新风机</h2><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/biguashi-xinfengqi.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209211336151.webp"></th></tr></thead></table><p>相比中央新风系统，壁挂式新风的安装灵活性就要强不少，一般只需要在墙上打出大小合适的洞作为进风口即可。</p><h2 id="2-3-新风空调"><a href="#2-3-新风空调" class="headerlink" title="2.3 新风空调"></a>2.3 新风空调</h2><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209212241148.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209212709055.webp"></th></tr></thead></table><p>新风空调作为结合空调和新风的新品类，先看评测对相关产品进行过详细的评测<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[空调新物种？米家新风空调体验 | 先睹为快\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1dy4y1t7E8/?vd_source=834a38204871938e13afaddb910f3b67)">[5]</span></a></sup>。新风空调相比新风机来说安装灵活性更强，但非专用的进风口也会影响新风空调的换气能力。</p><h2 id="2-4-米皮新风"><a href="#2-4-米皮新风" class="headerlink" title="2.4 米皮新风"></a>2.4 米皮新风</h2><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209214635749.webp" alt="image-20221209214635749"></p><p>虽然新风空调的安装灵活性已经足够高，但对于租房一族的笔者来说买一个新风空调还是有点过于奢侈。万幸的是市面上还有终极廉价解决方案：空气净化器+导风管，或者简称为米皮新风。空气净化器不再净化室内空气，而是经由可灵活安装的导风管净化室外空气，再将新鲜空气输出到室内（<del>充分体现了管道和分而治之的思想</del>）。笔者在研究了室内的导风条件后，立即在淘宝上购入了相关套件。</p><h1 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h1><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209220045066.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209220229005.webp" alt="image-20221209220229005"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209215915645.webp"></th></tr></thead></table><p>安装过程比较简单。将空气净化器的下半部分替换为导风底座，并在其中放入滤芯；将净化器主体用导风管和挡风板相连后，再用推拉窗紧紧夹住挡风板即可。</p><h1 id="4-效果"><a href="#4-效果" class="headerlink" title="4. 效果"></a>4. 效果</h1><p>笔者在安装完这套新风取得了立竿见影的效果：数小时内室内PM2.5浓度就从100+下降至了0。可惜默认保留15天数据的Prometheus已经丢失了当时的监控记录，无法以图片形式展示。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209221136039.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209221543799.webp"></th></tr></thead></table><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221209221252008.webp"></p><p>笔者在写这篇文章时，北京的PM2.5浓度已经接近100<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[北京空气质量指数（AQI）和中国 空气污染| IQAir](https://www.iqair.cn/cn/china/beijing)">[6]</span></a></sup>，但即使是一个相当低的换气速度（笔者卧室约17平米），这套新风系统依然能将室内PM2.5浓度控制在20以下，室内二氧化碳浓度在经过了连续几天的在家办公后也依然足够低。笔者对此表示很满意！</p><p>PS：从空气净化器的湿度传感器来看，笔者的室内空气已经远不像北京冬天的室外空气那样干燥。这是因为笔者已经采取措施改善了室内湿度，预计会在下篇文章分享。</p><h1 id="5-优化风道"><a href="#5-优化风道" class="headerlink" title="5. 优化风道"></a>5. 优化风道</h1><p>使用一段时间后笔者通过监控发现，虽然室内空气质量相比室外好上不少，但在室外空气污染比较严重、或者风比较大时，室内PM2.5等指标依然会上升。分析室内进出风口后笔者发现，由于使用米皮新风后推拉窗处于半开状态，所以室外空气容易从两层推拉窗中间的缝隙中进入室内。</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221229125233049.webp"></p><p>在购买了厚度合适的海绵挡风条，并将其塞入推拉窗中间的缝隙后，室内空气质量进一步改善，PM2.5值长期趋近于0。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221229125454887.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221229130138001.webp"></th></tr></thead></table><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="/2022/12/05/%E7%9B%91%E6%8E%A7%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F/">监控室内空气质量</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://www.miachina.net/MIANews?id=684">新风系统VS空气净化器，它完美胜出！-苏州米亚智能科技有限公司MIAVENTILATION-新风系统-家用新风系统-新风系统OEM-全热交换器-新风换气机-新风机</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1A4411u7gg/?vd_source=834a38204871938e13afaddb910f3b67">新风消费者报告 | 爱否出品_哔哩哔哩_bilibili</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV18R4y1V7DV/?spm_id_from=333.337.search-card.all.click&vd_source=834a38204871938e13afaddb910f3b67">25岁自装修｜新风最强「避坑指南」吐血整理！_哔哩哔哩_bilibili</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1dy4y1t7E8/?vd_source=834a38204871938e13afaddb910f3b67">空调新物种？米家新风空调体验 | 先睹为快_哔哩哔哩_bilibili</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://www.iqair.cn/cn/china/beijing">北京空气质量指数（AQI）和中国 空气污染| IQAir</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>监控</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监控室内空气质量</title>
    <link href="/2022/12/05/%E7%9B%91%E6%8E%A7%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F/"/>
    <url>/2022/12/05/%E7%9B%91%E6%8E%A7%E5%AE%A4%E5%86%85%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>爱否出品的新风消费报告<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[新风消费者报告 | 爱否出品\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1A4411u7gg/)">[1]</span></a></sup>里提到了一个概念：室内空气的四个终极目标是恒温、恒湿、恒净、恒氧。笔者对此深感认同，可惜笔者生活的北京并没有足够宜人的气候<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[模板:北京市气候数据 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/Template:%E5%8C%97%E4%BA%AC%E5%B8%82%E6%B0%94%E5%80%99%E6%95%B0%E6%8D%AE)">[2]</span></a></sup>：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221205220501060.webp"></p><p>空气质量指数<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[北京空气质量指数AQI\_PM2.5月统计历史数据\_中国空气质量在线监测分析平台历史数据](https://www.aqistudy.cn/historydata/monthdata.php?city=%E5%8C%97%E4%BA%AC)">[3]</span></a></sup>也堪忧：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221205215834953.webp"></p><p>更糟糕的是，为了保证室内空气含氧量，笔者的窗户常年是半开的。这就导致室内空气很容易受室外影响，不仅容易积灰，而且往往要等空气质量显著糟糕时笔者才会想到要关窗。</p><p>为了能更好地评估室内空气质量，并指导改进的方向，笔者决定搭建一套监控室内空气质量的解决方案。需要监控的指标包括：温度&#x2F;湿度&#x2F;二氧化碳&#x2F;PM2.5。</p><h1 id="2-硬件部分"><a href="#2-硬件部分" class="headerlink" title="2. 硬件部分"></a>2. 硬件部分</h1><p>首先是物美价廉的米家蓝牙温湿度计2，只要29即可实现温湿度测量，并可在APP端查看历史数据。然而实际体验并不好，打开APP后很难直接加载成功数据（笔者甚至要重启蓝牙才行），查看历史数据功能也不能自定义时间范围。不清楚使用蓝牙网关后体验能否得到提升。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/c44018f98ca3bc62.webp"></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221206092203598.webp" alt="image-20221206092203598" style="zoom:50%;" /></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221206092129994.webp" alt="image-20221206092129994" style="zoom:50%;" /></th></tr></thead></table><p>然后是功能相对完善的青萍空气检测仪Lite、淘宝某品牌空气检测仪，在500元的价位上都能做到温度&#x2F;湿度&#x2F;二氧化碳&#x2F;PM2.5的检测。</p><table><thead><tr><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/O1CN017VZrO42DFEU0obiX7_!!2201232258579.webp" alt="img" style="zoom:50%;" /></th><th><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221206093206207.webp" alt="image-20221206093206207" style="zoom:50%;" /></th></tr></thead></table><p>青萍这款接入了米家生态，能很好和其余设备联动，外形也更为简约。某品牌这款优点是自定义程度高，和店家咨询后得知其能通过USB将监控数据发送主机，并提供了一份源码<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[JoeyZheng/Lewei365B35：一个简单的应用程序，从365 B35获取数据，然后发送到Lewei50平台，用于网页和微信的数据监控和跟踪。](https://github.com/JoeyZheng/Lewei365B35)">[4]</span></a></sup>作为参考。笔者考虑到使用米家APP的体验不佳，且有较多自定义需求，所以购入了后者。</p><p>后者到手后笔者发现了一些小问题：</p><ul><li>由于需要通过USB发送检测数据，所以检测仪不能离主机太远，而摆放的位置可能会影响检测准确性</li><li>由于需要始终连接USB，各部件的发热（包括内置电池）会影响温度检测准确性</li><li>USB发送的检测数据中不包括PM10，商家解释这是因为国内的PM10传感器普遍不准确</li></ul><p>好在这些问题笔者都能接受。有了数据源后，下面就开始正式施工。</p><h1 id="3-软件部分"><a href="#3-软件部分" class="headerlink" title="3. 软件部分"></a>3. 软件部分</h1><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/architecture.webp" alt="prometheus架构图"></p><p>参考Prometheus的架构图，笔者列出了自己这套监控方案的架构图：定期抓取空气检测数据并上报、Grafana做展示、告警则用Telegram触达。</p><pre><code class=" mermaid">flowchart LR    A[空气检测仪]--USB--&gt;B[PC]    B-.push.-&gt;C[Pushgateway]    D[Promethues]-.pull.-&gt;C    D--&gt;E[Alertmanager]    E--&gt;G[Telegram]    F[Grafana]--&gt;D    style C stroke-dasharray:5    style E stroke-dasharray:5</code></pre><h2 id="3-1-上报检测数据"><a href="#3-1-上报检测数据" class="headerlink" title="3.1 上报检测数据"></a>3.1 上报检测数据</h2><p>在<a href="https://github.com/prometheus/pushgateway/releases">releases页</a>下载最新Pushgateway后用<a href="http://supervisord.org/index.html">Supervisor</a>等工具运行，即可在9091端口上提供API服务。</p><p>将检测仪连接到PC后，PC会自动识别到该设备（win10&#x2F;ubuntu20.04都无需额外安装驱动，好评）。用波特率57600连接后，笔者发现检测仪将PM2.5&#x2F;CO2&#x2F;温度&#x2F;湿度等数据以CSV格式周期性发送至PC。</p><p>于是可以编写如下脚本，用于解析检测仪提供的数据并将其发送至Pushgateway：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> serial<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> requests<br><br>PORT = <span class="hljs-string">&#x27;/dev/ttyUSB0&#x27;</span><br>BRATE = <span class="hljs-number">57600</span><br>HOST = socket.gethostname()<br>alias = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;0.3um&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;pm2.5&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;hcho&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;co2&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;temp&#x27;</span>, <span class="hljs-number">5</span>: <span class="hljs-string">&#x27;humidity&#x27;</span>&#125;<br><br>session = requests.Session()<br>device = serial.Serial(port=PORT, baudrate=BRATE, timeout=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    time.sleep(<span class="hljs-number">0.1</span>)<br>    <span class="hljs-keyword">if</span> device.in_waiting &gt; <span class="hljs-number">0</span>:<br>        text = device.readline().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).strip()  <span class="hljs-comment"># type: <span class="hljs-built_in">str</span></span><br>        lines = [<span class="hljs-string">&#x27;# TYPE b36_air_monitor gauge&#x27;</span>]<br>        <span class="hljs-keyword">for</span> i, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(text.split(<span class="hljs-string">&#x27;,&#x27;</span>)):<br>            name = alias.get(i)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name:<br>                <span class="hljs-keyword">continue</span><br>            lines.append(<br>                <span class="hljs-string">f&#x27;b36_air_monitor&#123;&#123;instance=&quot;<span class="hljs-subst">&#123;PORT&#125;</span>&quot;,alias=&quot;<span class="hljs-subst">&#123;name&#125;</span>&quot;,index=&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;&#125;&#125; <span class="hljs-subst">&#123;val&#125;</span>&#x27;</span>)<br>        lines.append(<span class="hljs-string">&#x27;&#x27;</span>)<br>        url = <span class="hljs-string">f&#x27;http://127.0.0.1:9091/metrics/job/<span class="hljs-subst">&#123;HOST&#125;</span>&#x27;</span>  <span class="hljs-comment"># Pushgateway地址</span><br>        <span class="hljs-keyword">try</span>:<br>            session.post(url, data=<span class="hljs-string">&#x27;\n&#x27;</span>.join(lines))<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:<br>            <span class="hljs-built_in">print</span>(datetime.now())<br>            <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(ex))<br></code></pre></td></tr></table></figure><p>运行后可读取Pushgateway的输出进行验证（由于笔者购买的检测仪没有搭配甲醛模块，所以hcho的值始终为0）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:9091/metrics</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">TYPE b36_air_monitor gauge</span><br>b36_air_monitor&#123;alias=&quot;0.3um&quot;,index=&quot;0&quot;,instance=&quot;/dev/ttyUSB0&quot;,job=&quot;nas&quot;&#125; 250<br>b36_air_monitor&#123;alias=&quot;co2&quot;,index=&quot;3&quot;,instance=&quot;/dev/ttyUSB0&quot;,job=&quot;nas&quot;&#125; 687<br>b36_air_monitor&#123;alias=&quot;hcho&quot;,index=&quot;2&quot;,instance=&quot;/dev/ttyUSB0&quot;,job=&quot;nas&quot;&#125; 0<br>b36_air_monitor&#123;alias=&quot;humidity&quot;,index=&quot;5&quot;,instance=&quot;/dev/ttyUSB0&quot;,job=&quot;nas&quot;&#125; 28<br>b36_air_monitor&#123;alias=&quot;pm2.5&quot;,index=&quot;1&quot;,instance=&quot;/dev/ttyUSB0&quot;,job=&quot;nas&quot;&#125; 1<br>b36_air_monitor&#123;alias=&quot;temp&quot;,index=&quot;4&quot;,instance=&quot;/dev/ttyUSB0&quot;,job=&quot;nas&quot;&#125; 26<br></code></pre></td></tr></table></figure><h2 id="3-2-接入Prometheus"><a href="#3-2-接入Prometheus" class="headerlink" title="3.2 接入Prometheus"></a>3.2 接入Prometheus</h2><p>数据上报到Pushgateway后，下一步是由Prometheus进行抓取。在<code>scrape_configs</code>下增加配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;pushgateway&quot;</span><br>    <span class="hljs-attr">honor_labels:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9091&quot;</span>]<br></code></pre></td></tr></table></figure><p>重启Prometheus后可在Web页面验证：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221206184333163.webp"></p><h2 id="3-3-配置告警"><a href="#3-3-配置告警" class="headerlink" title="3.3 配置告警"></a>3.3 配置告警</h2><p>从笔者查阅的资料来看，PM2.5浓度小于35μg&#x2F;m3、CO2浓度小于1000ppm是比较舒适的室内空气标准<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[室內空氣品質標準 – 浦羅特官方討論區](https://purotechbogger.wordpress.com/air/)">[5]</span></a></sup>：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221206190207027.webp"></p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/e59c96e789873737381.webp"></p><p>于是笔者基于这两个数值为抓取到的数据配置了告警。首先是在<a href="https://github.com/prometheus/alertmanager/releases">releases页</a>下载最新Alertmanager并用<a href="http://supervisord.org/index.html">Supervisor</a>工具运行，配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">group_by:</span> [<span class="hljs-string">&#x27;alertname&#x27;</span>]<br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">&#x27;tg&#x27;</span><br><span class="hljs-attr">receivers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;tg&#x27;</span><br>    <span class="hljs-attr">telegram_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">api_url:</span> <span class="hljs-string">&quot;https://api.telegram.org&quot;</span><br>      <span class="hljs-attr">bot_token:</span> <span class="hljs-string">&quot;xx:xx&quot;</span><br>      <span class="hljs-attr">chat_id:</span> <span class="hljs-string">xxx</span><br>      <span class="hljs-attr">parse_mode:</span> <span class="hljs-string">&quot;HTML&quot;</span><br>      <span class="hljs-attr">http_config:</span><br>        <span class="hljs-attr">proxy_url:</span> <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><p>然后是在Promethues的配置中加入告警规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># prometheus.yml</span><br><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;prometheus_alert.yml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># prometheus_alert.yml</span><br><span class="hljs-attr">groups:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">air_monitor</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">HighCO2</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">avg(b36_air_monitor&#123;job=&quot;nas&quot;,instance=&quot;/dev/ttyUSB0&quot;,alias=&quot;co2&quot;&#125;)</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">1000</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">10m</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;室内CO2浓度超过1000&quot;</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">HighPM2.5</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">avg(b36_air_monitor&#123;job=&quot;nas&quot;,instance=&quot;/dev/ttyUSB0&quot;,alias=&quot;pm2.5&quot;&#125;)</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">35</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">10m</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;室内PM2.5浓度超过35&quot;</span><br></code></pre></td></tr></table></figure><p>当过去10分钟PM2.5浓度&#x2F;CO2浓度超过设定值时，Promethues会通过Alertmanager向笔者的Telegram发送告警。</p><h1 id="4-效果展示"><a href="#4-效果展示" class="headerlink" title="4. 效果展示"></a>4. 效果展示</h1><p>最后来看看效果：</p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221206191154479.webp" alt="Grafana监控看板"></p><p><img src="https://picutres-1251933829.cos.ap-beijing.myqcloud.com/image-20221206191249249.webp" alt="Telegram告警"></p><p>笔者表示很满意！</p><p>PS：其实从上图的监控可以看出，笔者的室内PM2.5&#x2F;CO2浓度都比较低，这是因为笔者在写下这篇文章时已经通过一些手段大幅改善空气状况了，笔者会在后续的文章进行分享~</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1A4411u7gg/">新风消费者报告 | 爱否出品_哔哩哔哩_bilibili</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://zh.wikipedia.org/wiki/Template:%E5%8C%97%E4%BA%AC%E5%B8%82%E6%B0%94%E5%80%99%E6%95%B0%E6%8D%AE">模板:北京市气候数据 - 维基百科，自由的百科全书</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.aqistudy.cn/historydata/monthdata.php?city=%E5%8C%97%E4%BA%AC">北京空气质量指数AQI_PM2.5月统计历史数据_中国空气质量在线监测分析平台历史数据</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://github.com/JoeyZheng/Lewei365B35">JoeyZheng&#x2F;Lewei365B35：一个简单的应用程序，从365 B35获取数据，然后发送到Lewei50平台，用于网页和微信的数据监控和跟踪。</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://purotechbogger.wordpress.com/air/">室內空氣品質標準 – 浦羅特官方討論區</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>监控</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Afterburner和Grafana监控PC性能</title>
    <link href="/2022/08/20/%E7%94%A8Afterburner%E5%92%8CGrafana%E7%9B%91%E6%8E%A7PC%E6%80%A7%E8%83%BD/"/>
    <url>/2022/08/20/%E7%94%A8Afterburner%E5%92%8CGrafana%E7%9B%91%E6%8E%A7PC%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>监控Linux服务器性能已经有比较成熟的解决方案了：笔者用的是<code>node_exporter</code>+<code>Prometheus</code>+<code>Grafana</code>的经典三件套，整体效果令人满意：</p><table><thead><tr><th>整体架构</th><th>Grafana面板</th></tr></thead><tbody><tr><td><img src="/images/2022/8/20/43f3ee1d6e7cc42258812b94b31292d3.jpg"></td><td><img src="/images/2022/8/20/5315d9b41fb01e5f42efbcdb90c33b38.jpg"></td></tr></tbody></table><p>同时笔者在使用PC时偶尔还会使用<a href="https://www.msi.com/Landing/afterburner/graphics-cards">MSI Afterburner</a>（以下简称Afterburner）来观察PC性能：</p><p><img src="/images/2022/8/20/be56457ed0e1952818d51b2009053c09.jpg"></p><p>但Afterburner的监控功能并不易用（特别是在高分辨率下），如果能将监控数据在Grafana上呈现那就太棒了。<a href="https://github.com/RafhaanShah/grAfterburner">RafhaanShah&#x2F;grAfterburner</a>这个开源项目做到了这点，其使用的是方案是<a href="https://collectd.org/">collectd</a>+<a href="https://graphiteapp.org/">Graphite</a>+<a href="https://grafana.com/">Grafana</a>，整体用<code>docker-compose</code>启动。不过由于笔者已经有了另一套基于<code>Prometheus</code>的监控方案，所以笔者决定新造个轮子来复用现有的监控组件。</p><h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><p>Afterburner本体在<a href="https://www.msi.com/Landing/afterburner/graphics-cards">官网</a>下载并安装即可，但Afterburner不直接对外提供监控数据，而是通过一个叫<code>MSI Afterburner Remote Server</code>的小工具来做到。这个工具是为了在手机上监控PC性能而开发的，但因为种种原因官网已经不再提供其下载入口，最新版本也停留在2011年开发的V1.2。万幸的是我们可以从第三方网站下载到这个工具（<a href="https://drive.google.com/file/d/1zRZQ8_aEQcKwld3uavyT0aFi3b4sux-R/view">google driver</a>、<a href="https://github.com/wolf-joe/data-backup/tree/main/software/msi-afterburner">github</a>）。</p><p>运行Afterburner后，点击<code>MSI Afterburner Remote Server</code>的主程序，该工具会在后台运行，并在托盘区域内展示密码、端口（默认82）等信息：</p><p><img src="/images/2022/8/20/c9934a2d9cba41ce121e27231caa7980.jpg" alt="image-20220820162024028"></p><p>在浏览器中打开<code>127.0.0.1:82/mahm</code>，输入用户名<code>MSIAfterburner</code>和上面的密码即可看到对应的监控数据：</p><p><img src="/images/2022/8/20/b93b658e283490dbfd7b6b26845e07cc.jpg" alt="image-20220820162505895"></p><h1 id="转换数据格式"><a href="#转换数据格式" class="headerlink" title="转换数据格式"></a>转换数据格式</h1><p><code>MSI Afterburner Remote Server</code>提供的监控数据是xml格式的，要想适配<code>Prometheus</code>，得做一层转换才行。笔者选用Golang实现一个HTTP正向代理小工具来完成这层转换，逻辑很简单：接收<code>Prometheus</code>发出的数据采集请求、从<code>MSI Afterburner Remote Server</code>处获取监控数据、将监控数据以metrics格式进行返回。</p><!---@startumlparticipant Afterburner as dataparticipant proxyparticipant Prometheus as pmpm -> proxy: GET /metricsproxy -> data: GET /mahmdata --\> proxy: xmlproxy -> proxy: convertproxy --\> pm@enduml--><p><img src="/images/2022/8/20/d3ce4a5f1aeea651a6ab8534e7965d3d.jpg" alt="PlantUML diagram"></p><p>该工具已在<a href="https://github.com/wolf-joe/tools/tree/main/cmd/afterburner_exporter">GitHub</a>上开源，安装运行后可直接通过浏览器看到工具输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go install github.com/wolf-joe/tools/cmd/afterburner_exporter@latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">afterburner_exporter -listen <span class="hljs-string">&quot;0.0.0.0:8090&quot;</span> -target <span class="hljs-string">&quot;127.0.0.1:82&quot;</span> -password <span class="hljs-string">&quot;17cc95b4017d496f82&quot;</span></span><br>2022/08/20 18:13:08 listen on :8090<br></code></pre></td></tr></table></figure><p><img src="/images/2022/8/20/0701aeb276daaf249d1ac1ea26062661.jpg" alt="image-20220820185928484"></p><h1 id="接入Prometheus"><a href="#接入Prometheus" class="headerlink" title="接入Prometheus"></a>接入Prometheus</h1><p>修改Prometheus的配置文件，让其定时抓取上一章的metrics数据，重启后可看到服务正常接入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-string">...</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;desktop&quot;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9102&quot;</span>] <span class="hljs-comment"># 这里将PC上的127.0.0.1:8090转发到了Prometheus服务器的:9102</span><br></code></pre></td></tr></table></figure><p><img src="/images/2022/8/20/815351595b418e04648bacc311c011b7.jpg" alt="image-20220820190351844"></p><h1 id="配置Grafana"><a href="#配置Grafana" class="headerlink" title="配置Grafana"></a>配置Grafana</h1><p>Prometheus抓取到数据之后，在Grafana上添加对应面板：</p><p><img src="/images/2022/8/20/4e0513124777c920c5a47b0f70b7a005.jpg" alt="image-20220821051812112"></p><p>最终效果如下：</p><p><img src="/images/2022/8/20/c6d98f87fc49e13258216134d189871a.jpg" alt="image-20220821051331042"></p><p>大功告成！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>监控</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言error四问</title>
    <link href="/2021/07/17/Go%E8%AF%AD%E8%A8%80error%E5%9B%9B%E9%97%AE/"/>
    <url>/2021/07/17/Go%E8%AF%AD%E8%A8%80error%E5%9B%9B%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是error"><a href="#什么是error" class="headerlink" title="什么是error"></a>什么是error</h1><p>Go语言没有像Java&#x2F;Python一样提供<code>try</code>&amp;<code>catch</code>这种错误捕获方式，而是要求编码者显示地处理下游的传递的错误、显示地向上游抛出错误，也难怪总是有人吐槽Go在这方面的啰嗦。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> file *os.File<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>file, err = os.Open(<span class="hljs-string">&quot;something.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理打开文件时的错误，比如panic</span><br>    <span class="hljs-built_in">panic</span>(file)<br>&#125;<br><span class="hljs-comment">// 处理文件</span><br>fmt.Println(file.Stat())<br><span class="hljs-comment">// 处理关闭文件时的错误，比如直接忽略</span><br>_ = file.Close()<br></code></pre></td></tr></table></figure><p><img src="/images/2021/07/17/most_used_words.png" alt="words.png"></p><p>Go在标准库里提供了一种错误表现形式：<code>error</code>接口，定义很简单：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> builtin<br><br><span class="hljs-comment">// The error built-in interface type is the conventional interface for</span><br><span class="hljs-comment">// representing an error condition, with the nil value representing no error.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而Go提倡的组合机制让任何实现了<code>Error() string</code>方法的类型都可以视作<code>error</code>，这就带来了极大的灵活性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Error1 <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Error1)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(e) &#125;<br><br><span class="hljs-keyword">type</span> Error2 <span class="hljs-keyword">struct</span>&#123; msg <span class="hljs-type">string</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Error2)</span></span> SetMsg(msg <span class="hljs-type">string</span>) &#123; e.msg = msg &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Error2)</span></span> Error() <span class="hljs-type">string</span>     &#123; <span class="hljs-keyword">return</span> e.msg &#125;<br><br><span class="hljs-keyword">var</span> err1 <span class="hljs-type">error</span> = Error1(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">// Error1可以被视为Error</span><br><span class="hljs-keyword">var</span> err2 <span class="hljs-type">error</span> = &amp;Error2&#123;msg: <span class="hljs-string">&quot;world&quot;</span>&#125; <span class="hljs-comment">// Error2也可以被视为Error</span><br></code></pre></td></tr></table></figure><h1 id="如何创建error"><a href="#如何创建error" class="headerlink" title="如何创建error"></a>如何创建error</h1><p>Go原生提供了两种方式来创建一个<code>error</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> err1 <span class="hljs-type">error</span> = errors.New(<span class="hljs-string">&quot;error msg&quot;</span>)<br><span class="hljs-keyword">var</span> err2 <span class="hljs-type">error</span> = fmt.Errorf(<span class="hljs-string">&quot;error msg: %s&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>前者比较简单，单纯地创建了一个<code>string</code>的封装类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<br><br><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125; &#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span>&#123; s <span class="hljs-type">string</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.s &#125;<br></code></pre></td></tr></table></figure><p>后者在示例代码中也很简单，可以看成<code>fmt.Sprintf</code>+<code>errors.New</code>。当然Go1.13做了点小改进，下文会提到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go1.12源码</span><br><span class="hljs-keyword">package</span> fmt<br><br><span class="hljs-comment">// Errorf formats according to a format specifier and returns the string</span><br><span class="hljs-comment">// as a value that satisfies error.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> errors.New(Sprintf(format, a...))<br>&#125;<br></code></pre></td></tr></table></figure><p>但这两种方式还是太简陋了，毕竟携带的只是字符串信息。所以在实际应用场景中，更常见的做法是自定义错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> BizError <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 自定义业务错误</span><br>    Code <span class="hljs-type">int32</span> <span class="hljs-comment">// 错误码</span><br>    Msg  <span class="hljs-type">string</span> <span class="hljs-comment">// 错误提示</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *BizError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;BizError&lt;%d&gt;: %s&quot;</span>, e.Code, e.Msg) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBizErr</span><span class="hljs-params">(code <span class="hljs-type">int32</span>, msg <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> &amp;BizError&#123;Code: code, Msg: msg&#125; &#125;<br></code></pre></td></tr></table></figure><p>当然，为某些特定场景设计的公用错误（如标准库里的<code>io.EOF</code>）也会使用<code>errors.New</code>，这些错误的意思也足以用简短的字符串描述。</p><h1 id="如何向上游传递error"><a href="#如何向上游传递error" class="headerlink" title="如何向上游传递error"></a>如何向上游传递error</h1><p>由于Go中的错误一般是通过<code>error</code>接口以返回值的形式传递给上游的，且一般不会包含函数调用栈信息，所以在给上游传递<code>error</code>时就需要考虑附加上下文信息以便排查问题，特别是将下游的<code>error</code>传递给上游时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dial80</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    addr, timeout := <span class="hljs-string">&quot;127.0.0.1:80&quot;</span>, time.Second<br>        <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">if</span> ... &#123;<br>        timeout = time.Second * <span class="hljs-number">3</span><br>    &#125;<br>    conn, err := net.DialTimeout(<span class="hljs-string">&quot;tcp&quot;</span>, addr, timeout)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    _ = conn.Close()<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如这个简单的函数，如果上游<strong>有必要</strong>感知出现错误时的上下文信息（比如超时配置），应该怎么处理呢？</p><p>一种简单的方法是将错误信息重新拼装一下，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dial80</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 对error来说，%s会调用.Error()方法</span><br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;dial80 timeout %s: %s&quot;</span>, timeout, err)<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种方法是将<code>error</code>再包装一层：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> dial80Err <span class="hljs-keyword">struct</span> &#123;<br>    timeout time.Duration<br>    err     <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *dial80Err)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;dial80 timeout %s: %s&quot;</span>, e.timeout, e.err) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dial80</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;dial80Err&#123;timeout: timeout, err: err&#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但两种方法都并不完美。前者会丢失<code>error</code>中除<code>.Error()</code>返回值外的其它信息，后者用起来很繁琐，有没有更好的方法呢？当然是有的。Go1.13引入了<em>Error wrapping</em>的概念，通过扩展<code>fmt.Errorf</code>来包装<code>error</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dial80</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;dial80 timeout %s: %w&quot;</span>, timeout, err)<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>注意其中<code>%w</code>占位符，<code>fmt.Errorf</code>会特殊处理这个占位符，如果存在这个占位符，<code>fmt.Errorf</code>会将其对应的<code>error</code>与错误信息一起放入一个新的结构体里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go1.13源码</span><br><span class="hljs-keyword">package</span> fmt<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> &#123;<br>        err = errors.New(s)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        err = &amp;wrapError&#123;s, p.wrappedErr&#125;<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> &#123;<br>    msg <span class="hljs-type">string</span><br>    err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.msg &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> e.err &#125;<br></code></pre></td></tr></table></figure><p>这种方法综合了前两种的优点，即使用便捷又不会丢失信息。所以在Go1.13之后，非常推荐使用<code>%w</code>占位符来为错误附加上下文信息并传递给上游。</p><h1 id="如何分析下游传递的error"><a href="#如何分析下游传递的error" class="headerlink" title="如何分析下游传递的error"></a>如何分析下游传递的error</h1><p>当我们得到下游传递的<code>error</code>且需要根据其类型、属性做进一步操作时，该怎么办呢？（当然，前提是下游不能使用<code>errors.New</code>或<code>fmt.Errorf</code>+<code>%s</code>来传递错误，笑）</p><p>由于下游可能传递<code>wrapError</code>给上游，所以上游并不能直接对<code>error</code>进行比较运算（<code>==</code>）、类型断言，而是要用<code>errors</code>包提供的API进行分析。</p><p>比如，用<code>errors.Is</code>替代<code>==</code>运算符来判断两个<code>error</code>是否相等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">myRead := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> ... &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;myRead: %w&quot;</span>, io.EOF)<br>    &#125;<br>    ...<br>&#125;<br>buf, err := myRead()<br><span class="hljs-keyword">if</span> errors.Is(err, io.EOF) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>又比如，用<code>errors.As</code>替代<code>.(type)</code>来做类型断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">err := dial80()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">var</span> opErr *net.OpError<br>    <span class="hljs-comment">// 判断err是否为超时错误</span><br>    <span class="hljs-keyword">if</span> ok := errors.As(err, &amp;opErr); ok &amp;&amp; opErr.Timeout() &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="github-com-x2F-pkg-x2F-errors"><a href="#github-com-x2F-pkg-x2F-errors" class="headerlink" title="github.com&#x2F;pkg&#x2F;errors"></a>github.com&#x2F;pkg&#x2F;errors</h1><p>标准库中<code>errors.Is</code>和<code>errors.As</code>两个函数需要频繁使用性能较差的反射，<code>errors.As</code>使用起来也很繁琐，所以如果有条件的话可以使用功能更丰富的<a href="https://github.com/pkg/errors/">github.com&#x2F;pkg&#x2F;errors</a>包，例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// import github.com/pkg/errors</span><br>myRead := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> ... &#123;<br>        <span class="hljs-comment">// 效果类似 fmt.Errorf(&quot;myRead: %w&quot;, io.EOF)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.WithMessage(io.EOF, <span class="hljs-string">&quot;myRead&quot;</span>)<br>    &#125;<br>    ...<br>&#125;<br>buf, err := myRead()<br><span class="hljs-keyword">if</span> errors.Is(err, io.EOF) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><span class="hljs-comment">// 谨慎使用</span><br><span class="hljs-keyword">if</span> errors.Cause(err) == io.EOF &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用时在下游通过<code>errors.WithMessage</code>&#x2F;<code>errors.WithMessagef</code>包装错误，在上游通过<code>errors.Cause</code>获取被包装的原始错误。不过<code>errors.Cause</code>不能穿透被<code>fmt.Errorf</code>+<code>%w</code>包装的<code>wrapError</code>，所以使用时一定要谨慎。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Go中的<code>error</code>是一个只需实现<code>Error() string</code>方法的接口。</li><li>除非是公用错误，否则尽量使用自定义错误类型来生成错误，而不是使用<code>errors.New</code>和<code>fmt.Errorf</code>。</li><li>使用<code>fmt.Errorf</code>与<code>%w</code>来为错误附加上下文信息。</li><li>使用<code>errors.Is</code>、<code>errors.As</code>来分析错误。</li><li>如有条件，可使用更优秀的<a href="https://github.com/pkg/errors/">github.com&#x2F;pkg&#x2F;errors</a>包替代标准库的<code>errors</code>包和<code>fmt.Errorf</code>。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《流畅的Python》：一等函数</title>
    <link href="/2020/07/05/fluent-python-chap-5/"/>
    <url>/2020/07/05/fluent-python-chap-5/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一等对象（<code>first-class objects</code>）是指拥有如下特性的程序实体：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果</li></ul><p>Python中的函数拥有这几个特性，所以被称作<strong>一等函数</strong>（<code>functions as first-class objects</code>，简称<code>first-class functions</code>）。</p><h1 id="把函数视作对象"><a href="#把函数视作对象" class="headerlink" title="把函数视作对象"></a>把函数视作对象</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>):  <span class="hljs-comment"># 在运行时创建</span><br><span class="hljs-meta">... </span>    <span class="hljs-string">&quot;&quot;&quot;return x * x&quot;&quot;&quot;</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x * x<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bar = foo  <span class="hljs-comment"># 赋值给变量</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bar.__doc__<br><span class="hljs-string">&#x27;return x * x&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(bar)  <span class="hljs-comment"># 作为参数传给函数</span><br>&lt;function foo at ...&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fooo</span>(): <span class="hljs-keyword">return</span> foo<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fooo()(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 作为函数的返回结果</span><br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>接受函数为参数，或把函数作为结果返回的函数是<strong>高阶函数</strong>，比如上文提到的<code>print()</code>和<code>fooo()</code>。再比如接收函数作为<code>key</code>参数的<code>sorted()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>([-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], key=<span class="hljs-built_in">abs</span>)<br>[<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>函数式编程语言一般会提供<code>map</code>、<code>filter</code>、<code>reduce</code>三个高阶函数。Python也提供这三个函数，但列表推导（<code>list comprehensions</code>）和生成器表达式（<code>generator expressions</code>）在完成和<code>map</code>、<code>filter</code>相同的功能时代码可读性更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(foo, <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)))<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[foo(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(foo, <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x &gt; <span class="hljs-number">2</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>))))  <span class="hljs-comment"># 用lambda关键字创造了一个匿名函数</span><br>[<span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[foo(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2</span>]<br>[<span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br></code></pre></td></tr></table></figure><p>如果是执行求和操作，也可以用内置的<code>sum</code>函数替代<code>reduce</code>，性能和可读性更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce  <span class="hljs-comment"># Python3起，reduce不再是内置函数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> add  <span class="hljs-comment"># add 相当于 lambda a, b: a + b</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(add, <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>))<br><span class="hljs-number">4950</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>))<br><span class="hljs-number">4950</span><br></code></pre></td></tr></table></figure><p>和<code>sum</code>和<code>reduce</code>的思路类似，<code>all</code>和<code>any</code>也是两个内置的归约函数：</p><ul><li><code>all(iterable)</code>：如果每个元素都为真，返回<code>True</code>。<code>all([])</code>返回<code>True</code>。</li><li><code>any(iterable)</code>：如任意一个元素为真，返回<code>True</code>。<code>any([])</code>返回<code>False</code>。</li></ul><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>用<code>lambda</code>关键字创造的函数叫做<strong>匿名函数</strong>。匿名函数只能使用纯表达式，函数内不能赋值，也不能使用<code>while</code>、<code>try</code>等语句。匿名函数一般只作为参数传递给高阶函数，就像上一节的示例那样。</p><p>从<code>Pythonic</code>的角度来说，匿名函数最好不要超过一行，也不推荐将匿名函数赋值给其它变量。</p><h1 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h1><p>能被调用运算符（即<code>()</code>）应用的对象被称为<strong>可调用对象</strong>，这点可以通过内置的<code>callable</code>函数来判断。<a href="https://docs.python.org/3/reference/datamodel.html">Python数据模型</a>文档列出了7种可调用对象：</p><ul><li>用户定义的函数（<code>User-defined functions</code>），使用<code>def</code>语句和<code>lambda</code>表达式创建的函数。</li><li>方法（<code>Instance methods</code>），在类的定义体中定义的函数。</li><li>生成器函数（<code>Generator functions</code>），使用<code>yield</code>关键字的函数或方法。调用生成器函数会返回生成器对象。</li><li>内置函数（<code>Built-in functions</code>）、内置方法（<code>Built-in methods</code>），用C语言实现的函数&#x2F;方法，如<code>len()</code>、<code>alist.append()</code>。</li><li>类（<code>Classes</code>），调用类时会运行类的<code>__new__</code>方法创建实例，然后运行<code>__init__</code>方法初始化实例。</li><li>类的实例（<code>Class Instances</code>），定义了<code>__call__</code>方法的类的实例。</li></ul><p>当然，《流畅的Python》基于Python3.4，后续的Python版本还引入了其它种类的可调用对象，如协程函数（<code>Coroutine functions</code>）和异步生成器函数（<code>Asynchronous generator functions</code>），详见前文的文档链接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>, <span class="hljs-built_in">str</span>, <span class="hljs-number">13</span><br>(&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">abs</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;, <span class="hljs-number">13</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-built_in">callable</span>(obj) <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> (<span class="hljs-built_in">abs</span>, <span class="hljs-built_in">str</span>, <span class="hljs-number">13</span>)]<br>[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]<br></code></pre></td></tr></table></figure><h1 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h1><p><strong>内省</strong>指程序在运行时检查对象类型的一种能力，在Python中，函数提供许多属性来实现内省。函数特有的属性主要有如下几种：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>__annotations__</code></td><td>dict</td><td>参数和返回值的注解</td></tr><tr><td><code>__call__</code></td><td>method-wrapper</td><td>实现<code>()</code>运算符</td></tr><tr><td><code>__closure__</code></td><td>tuple</td><td>函数闭包，即自由变量的绑定</td></tr><tr><td><code>__code__</code></td><td>code</td><td>编译成字节码的函数元数据和函数定义体</td></tr><tr><td><code>__defaults__</code></td><td>tuple</td><td>形参的默认值</td></tr><tr><td><code>__get__</code></td><td>method-wraper</td><td>实现<a href="https://docs.python.org/3/howto/descriptor.html">只读描述符协议</a></td></tr><tr><td><code>__globals__</code></td><td>dict</td><td>函数所在模块的全局变量</td></tr><tr><td><code>__kwdefaults__</code></td><td>dict</td><td>仅限关键字形参的默认值</td></tr><tr><td><code>__name__</code></td><td>str</td><td>函数名称</td></tr><tr><td><code>__qualname__</code></td><td>str</td><td>函数的<a href="https://www.python.org/dev/peps/pep-3155/">限定名称</a>，如<code>Random.choice</code></td></tr></tbody></table><h1 id="函数参数、获取关于参数的信息"><a href="#函数参数、获取关于参数的信息" class="headerlink" title="函数参数、获取关于参数的信息"></a>函数参数、获取关于参数的信息</h1><p>详见<a href="/2020/07/04/python-parameters-and-arguments/">上一篇文章</a></p><h1 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h1><p>Python3提供的新语法<code>函数注解</code>可以为函数声明的参数和返回值附加元数据，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num_a: <span class="hljs-string">&#x27;int &gt; 0&#x27;</span>, num_b: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;123&#x27;</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>    <span class="hljs-keyword">return</span> (num_a + <span class="hljs-built_in">int</span>(num_b)) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>函数中的参数可以在<code>:</code>之后增加注解表达式。如参数有默认值，则表达式放在参数和<code>=</code>号之间。函数末尾的<code>)</code>和<code>:</code>之间也可以放入表达式，用于注解返回值。注解不会做任何处理，只是储存在函数的<code>__annotations__</code>属性里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo.__annotations__<br>&#123;<span class="hljs-string">&#x27;num_a&#x27;</span>: <span class="hljs-string">&#x27;int &gt; 0&#x27;</span>, <span class="hljs-string">&#x27;num_b&#x27;</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;, <span class="hljs-string">&#x27;return&#x27;</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;&#125;<br></code></pre></td></tr></table></figure><p>注解只是元数据，可以供IDE、框架、装饰器、静态代码分析工具等使用。标准库中只有上一节提到的<code>inspect.signature</code>会用到注解，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> signature<br><span class="hljs-meta">&gt;&gt;&gt; </span>sig = signature(foo)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sig.return_annotation<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> sig.parameters.values():<br><span class="hljs-meta">... </span>    anno = <span class="hljs-built_in">str</span>(param.annotation)<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;anno:&lt;<span class="hljs-number">13</span>&#125;</span> : <span class="hljs-subst">&#123;param.name&#125;</span> = <span class="hljs-subst">&#123;param.default&#125;</span>&#x27;</span>)<br><span class="hljs-meta">... </span><br><span class="hljs-built_in">int</span> &gt; <span class="hljs-number">0</span>       : num_a = &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;inspect._empty&#x27;</span>&gt;<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt; : num_b = <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h2 id="用注解实现参数校验"><a href="#用注解实现参数校验" class="headerlink" title="用注解实现参数校验"></a>用注解实现参数校验</h2><p>Python大牛<code>Raymond Hettinger</code>在一个<a href="https://stackoverflow.com/questions/3038033/what-are-good-uses-for-python3s-function-annotations">StackOverflow问答</a>里展示了一种方便的、基于注解的参数校验机制，摘录如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">func, <span class="hljs-built_in">locals</span></span>):<br>    <span class="hljs-keyword">for</span> var, test <span class="hljs-keyword">in</span> func.__annotations__.items():<br>        value = <span class="hljs-built_in">locals</span>[var]<br>        msg = <span class="hljs-string">&#x27;Var: &#123;0&#125;\tValue: &#123;1&#125;\tTest: &#123;2.__name__&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(var, value, test)<br>        <span class="hljs-keyword">assert</span> test(value), msg<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_int</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isinstance</span>(x, <span class="hljs-built_in">int</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">between</span>(<span class="hljs-params">lo, hi</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_between</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> lo &lt;= x &lt;= hi<br>    <span class="hljs-keyword">return</span> _between<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x: between(<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">10</span></span>), y: is_int</span>):<br>    validate(f, <span class="hljs-built_in">locals</span>())<br>    <span class="hljs-built_in">print</span>(x, y)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">0</span>, <span class="hljs-number">31.1</span>)<br>Traceback (most recent call last):<br>  ...<br>AssertionError: Var: xValue: <span class="hljs-number">0</span>Test: _between<br></code></pre></td></tr></table></figure><p>其基本思想是用<code>Callable</code>对象充当函数参数的注解，然后在函数被调用时调用<code>Callable</code>对象来校验参数。换句话说，上面的函数<code>f</code>可以改写成如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">3</span> &lt;= x &lt;= <span class="hljs-number">10</span>, <span class="hljs-string">f&#x27;Var: xValue: <span class="hljs-subst">&#123;x&#125;</span>Test: _between&#x27;</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(y, <span class="hljs-built_in">int</span>), <span class="hljs-string">f&#x27;Var: yValue: <span class="hljs-subst">&#123;y&#125;</span>Test: is_int&#x27;</span><br>    <span class="hljs-built_in">print</span>(x, y)<br></code></pre></td></tr></table></figure><p>由此可见前文参数校验机制的精妙。</p><h1 id="支持函数式编程的模块"><a href="#支持函数式编程的模块" class="headerlink" title="支持函数式编程的模块"></a>支持函数式编程的模块</h1><p>在<code>operator</code>和<code>functools</code>等模块的支持下，Python也可以很方便地实现函数式编程风格。</p><h2 id="operator模块"><a href="#operator模块" class="headerlink" title="operator模块"></a>operator模块</h2><p><code>operator</code>模块为许多算数运算符提供了对应的函数，如<code>add</code>（对应<code>a + b</code>）、<code>mul</code>（对应<code>a * b</code>）等等。比如计算<code>1~n</code>的和与<code>n</code>的阶乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> add, mul<br><span class="hljs-meta">&gt;&gt;&gt; </span>n = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(add, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>))  <span class="hljs-comment"># 1 + 2 + ... + 10</span><br><span class="hljs-number">55</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(mul, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>))  <span class="hljs-comment"># 1 * 2 * ... * 10</span><br><span class="hljs-number">3628800</span><br></code></pre></td></tr></table></figure><p><code>operator</code>模块还提供了<code>itemgetter</code>和<code>attrgetter</code>两个函数，可以从序列中提取元素或读取对象的属性。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>records = [(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juice&#x27;</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter, attrgetter<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(records, key=itemgetter(<span class="hljs-number">1</span>))  <span class="hljs-comment"># itemgetter(1) 等效于 lambda x: x[1]</span><br>[(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juice&#x27;</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>)]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>attrgetter(<span class="hljs-string">&#x27;append&#x27;</span>)(records)<br>&lt;built-<span class="hljs-keyword">in</span> method append of <span class="hljs-built_in">list</span> <span class="hljs-built_in">object</span> at ...&gt;<br></code></pre></td></tr></table></figure><p>最后介绍<code>methodcaller</code>函数，这个函数创建的函数会调用对象上的指定方法，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> methodcaller<br><span class="hljs-meta">&gt;&gt;&gt; </span>records<br>[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juice&#x27;</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>append_lemon = methodcaller(<span class="hljs-string">&#x27;append&#x27;</span>, (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;lemon&#x27;</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>append_lemon(records)  <span class="hljs-comment"># 等效于 records.append((4, &#x27;lemon&#x27;))</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>records<br>[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juice&#x27;</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;lemon&#x27;</span>)]<br></code></pre></td></tr></table></figure><h2 id="用functools-partial冻结参数"><a href="#用functools-partial冻结参数" class="headerlink" title="用functools.partial冻结参数"></a>用functools.partial冻结参数</h2><p>除了前文已经多次提到的<code>reduce</code>，<code>functools</code>模块还提供了许多有用的函数，比如可以冻结函数参数的<code>partial</code>。上一节提到的<code>append_lemon</code>其实就起到了类似<code>partial</code>的作用，但<code>partial</code>的功能更强大。比如前文提到的自定义排序，可以用更通用的形式重写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>records = [(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juice&#x27;</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter, attrgetter<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(records, key=itemgetter(<span class="hljs-number">1</span>))  <span class="hljs-comment"># itemgetter(1) 等效于 lambda x: x[1]</span><br>[(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juice&#x27;</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>)]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><span class="hljs-meta">&gt;&gt;&gt; </span>sort_by_second = partial(<span class="hljs-built_in">sorted</span>, key=itemgetter(<span class="hljs-number">1</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>sort_by_second(records)<br>[(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;apple&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juice&#x27;</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;orange&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>在需要用相同（或类似）的参数反复调用某个函数时，使用<code>functools.partial</code>冻结参数可以有效降低工作量和bug出现的几率。<code>functools</code>还提供了<code>wraps</code>、<code>lru_cache</code>等比较实用的装饰器，这方面的内容可以参考笔者<a href="/2020/06/20/python-decorators-source-code/">先前的文章</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>流畅的Python</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的函数参数与参数传递</title>
    <link href="/2020/07/04/python-parameters-and-arguments/"/>
    <url>/2020/07/04/python-parameters-and-arguments/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：本篇文章使用CPython3.6</p></blockquote><h1 id="定位参数、关键字参数"><a href="#定位参数、关键字参数" class="headerlink" title="定位参数、关键字参数"></a>定位参数、关键字参数</h1><p>在Python中，当定义一个函数时，函数接收的参数叫做为形式参数（<code>parameters</code>），以下简称<strong>形参</strong>；当调用一个函数时，调用者传递给该函数的值叫做实际参数（<code>arguments</code>），以下简称<strong>实参</strong>。</p><p>根据<a href="https://docs.python.org/3/library/inspect.html">inspect模块</a>的描述，Python的形参可以分成如下五类：</p><ul><li><em>POSITIONAL_OR_KEYWORD</em>，默认类型，可通过定位&#x2F;关键字实参传递；</li><li><em>VAR_POSITIONAL</em>，定位形参元祖，如<code>*args</code>，捕获剩下的定位实参；</li><li><em>KEYWORD_ONLY</em>，在<code>*</code>或<code>*args</code>之后的形参，只能通过关键字实参传递；</li><li><em>VAR_KEYWORD</em>，关键字形参字典，如<code>**kwargs</code>，捕获剩下的关键字实参；</li><li><em>POSITIONAL_ONLY</em>，只能通过定位实参传递，Python语法暂不支持，只有一些C函数（如<code>divmod</code>）使用。</li></ul><p>比如定义如下函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, *args</span>):<br>    <span class="hljs-built_in">print</span>(a, args)<br></code></pre></td></tr></table></figure><p>其中形参<code>a</code>属于<em>POSITIONAL_OR_KEYWORD</em>，可通过定位&#x2F;关键字实参传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span> ()<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo(a=<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span> ()<br></code></pre></td></tr></table></figure><p>满足形参<code>a</code>之后，剩余的定位实参将被<code>*args</code>以元组的形式捕获：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">1</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>再比如定义如下函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, *args, b, **kwargs</span>):<br>    <span class="hljs-built_in">print</span>(a, args, b, kwargs)<br></code></pre></td></tr></table></figure><p>形参<code>b</code>属于<em>KEYWORD_ONLY</em>，因为它在<code>*args</code>之后定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo(<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>)<br><span class="hljs-number">1</span> () <span class="hljs-number">2</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>满足形参<code>b</code>之后，剩余的关键字实参将被<code>**kwargs</code>以字典的形式捕获：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo(<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>, c=<span class="hljs-number">3</span>)<br><span class="hljs-number">1</span> () <span class="hljs-number">2</span> &#123;<span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>如果想定义<em>KEYWORD_ONLY</em>形参，但不想使用<em>VAR_POSITIONAL</em>形参（即<code>*args</code>），则可以在定义函数时单独的<code>*</code>号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, *, b</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a, b)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo(<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: foo() takes <span class="hljs-number">1</span> positional argument but <span class="hljs-number">2</span> were given<br></code></pre></td></tr></table></figure><h1 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h1><p>在定义函数时，我们可以给形参指定默认值，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=<span class="hljs-number">1</span>, *args, b=<span class="hljs-number">2</span>, **kwargs</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a, args, b, kwargs)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>foo()<br><span class="hljs-number">1</span> () <span class="hljs-number">2</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，形参的默认值存储在函数对象的<code>__defaults__</code>和<code>__kwdefaults__</code>属性里，而不是每次调用函数时动态生成，所以最好不要用可变对象充当形参的默认值。下面的例子就是反面教材：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">param=[]</span>):<br><span class="hljs-meta">... </span>    param.append(<span class="hljs-number">1</span>)<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(param), param)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(foo.__defaults__[<span class="hljs-number">0</span>]), foo.__defaults__[<span class="hljs-number">0</span>])<br><span class="hljs-number">140009169940232</span> []<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo()<br><span class="hljs-number">140009169940232</span> [<span class="hljs-number">1</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo()<br><span class="hljs-number">140009169940232</span> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="获取关于参数的信息"><a href="#获取关于参数的信息" class="headerlink" title="获取关于参数的信息"></a>获取关于参数的信息</h1><p><strong>内省</strong>指程序在运行时检查对象类型的一种能力，本节介绍的内容就属于函数内省的范围。假设有如下函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a=<span class="hljs-number">1</span>, *args, b=<span class="hljs-number">2</span>, **kwargs</span>):<br>    c = a<br>    <span class="hljs-built_in">print</span>(c, args, b, kwargs)<br></code></pre></td></tr></table></figure><p>就像上一节中提到的，<code>foo</code>函数有<code>__defaults__</code>、<code>__kwdefaults__</code>属性，用于记录定位参数和关键字参数的默认值；有<code>__code__</code>属性，存储函数编译后的字节码信息，其中就包括参数的名称。通过这些属性，我们可以获取关于函数参数的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>foo.__defaults__<br>(<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo.__kwdefaults__<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo.__code__.co_varnames  <span class="hljs-comment"># 参数&amp;局部变量名称</span><br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;args&#x27;</span>, <span class="hljs-string">&#x27;kwargs&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>foo.__code__.co_argcount  <span class="hljs-comment"># 定位参数数量</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>foo.__code__.co_kwonlyargcount  <span class="hljs-comment"># 仅限关键字参数数量</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>但这样还是太原始、太不方便了。幸好，我们有更好的选择：Python内置的<code>inspect</code>模块。下面这个例子就提取了<code>foo</code>函数的签名，然后获取函数的参数信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> signature<br><span class="hljs-meta">&gt;&gt;&gt; </span>sig = signature(foo)<br><span class="hljs-meta">&gt;&gt;&gt; </span>sig<br>&lt;Signature (a=<span class="hljs-number">1</span>, *args, b=<span class="hljs-number">2</span>, **kwargs)&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> sig.parameters.items():<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(param.kind):&lt;<span class="hljs-number">21</span>&#125;</span> : <span class="hljs-subst">&#123;param.name:&lt;<span class="hljs-number">6</span>&#125;</span> = <span class="hljs-subst">&#123;param.default&#125;</span>&#x27;</span>)<br><span class="hljs-meta">... </span><br>POSITIONAL_OR_KEYWORD : a      = <span class="hljs-number">1</span><br>VAR_POSITIONAL        : args   = &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;inspect._empty&#x27;</span>&gt;<br>KEYWORD_ONLY          : b      = <span class="hljs-number">2</span><br>VAR_KEYWORD           : kwargs = &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;inspect._empty&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>同时，<code>inspect.Signature</code>对象还有一个<code>bind</code>方法，该方法可以将一些对象绑定到函数的形参上，就像Python解释器在调用函数时做的那样。通过这种方法，框架可以在真正执行函数前验证参数，就像下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bound = sig.bind(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, c=<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> bound.arguments.items():<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name:&lt;<span class="hljs-number">6</span>&#125;</span> = <span class="hljs-subst">&#123;value&#125;</span>&#x27;</span>)<br><span class="hljs-meta">... </span><br>a      = <span class="hljs-number">1</span><br>args   = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>kwargs = &#123;<span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bound = sig.bind(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, a=<span class="hljs-number">4</span>)<br>Traceback (most recent call last):<br>  File ...<br>TypeError: multiple values <span class="hljs-keyword">for</span> argument <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h1><p>说起函数参数传递，可能就有人想起了<code>引用传递</code>、<code>值传递</code>……忘掉这两个概念，来看看下面两个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo1</span>(<span class="hljs-params">param: <span class="hljs-built_in">list</span></span>):<br>    param += [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br>arg1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>foo1(arg1)<br><span class="hljs-built_in">print</span>(arg1)  <span class="hljs-comment"># 输出[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><p>内存中有一个<code>list</code>对象（<code>[1, 2, 3]</code>），该对象有两个别名：<code>arg1</code>和<code>param</code>。由于<code>list</code>对象是可变的（<code>mutable</code>），所以可以通过<code>param</code>这个别名修改这个<code>list</code>对象的内容。</p><p><img src="/images/2020/07/04/list.webp" alt="tuple.webp"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo2</span>(<span class="hljs-params">param: <span class="hljs-built_in">tuple</span></span>):<br>    param += (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><br>arg2 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>foo2(arg2)<br><span class="hljs-built_in">print</span>(arg2)  <span class="hljs-comment"># 输出(1, 2, 3)</span><br></code></pre></td></tr></table></figure><p>内存中有一个<code>tuple</code>对象（<code>(1, 2, 3)</code>），该对象也有两个别名：<code>arg2</code>和<code>param</code>。但由于<code>tuple</code>对象是不可变的<code>(immutable)</code>，当执行<code>param += (4, 5)</code>时，解释器创建了一个新的<code>tuple</code>对象（<code>(1, 2, 3, 4, 5)</code>），并让<code>param</code>指向这个新的对象，而原来的对象没有被改变。</p><p><img src="/images/2020/07/04/tuple.webp" alt="tuple.webp"></p><p>在Python中，参数传递本质上是为已有的对象取了一个函数作用域级别的别名。如果该对象是可变的，那么就可以在函数内修改该对象，这种修改也可以被其它的别名所感知。弄清楚对象、别名的关系，就不会对<code>值传递</code>、<code>引用传递</code>这种说法感到困惑了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python部分内置函数装饰器源码浅析</title>
    <link href="/2020/06/20/python-decorators-source-code/"/>
    <url>/2020/06/20/python-decorators-source-code/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是这个博客里第一篇带有<code>源码</code>Tag的文章。在过去的一个月，笔者深刻地认识到自己在技术深度方面有很大的不足，所以在未来的学习道路上，笔者会尽量多地阅读开源软件的源代码，并将自己的理解以文章的形式表达出来。如有错漏，请各位读者不吝指教。</p><blockquote><p>注：本篇文章所用环境为CPython3.6</p></blockquote><h1 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h1><p><code>wraps</code>这个内置函数装饰器在笔者的<a href="/2020/06/19/%E8%AF%BB%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84Python%E3%80%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/#functool-wraps">上一篇文章</a>里有过介绍，功能很单纯（拷贝<code>__name__</code>、<code>__doc__</code>等属性），源码也很短（不到50行）。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;inner doc&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;inner(<span class="hljs-subst">&#123;args&#125;</span>, <span class="hljs-subst">&#123;kwargs&#125;</span>)&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@deco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;target doc&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;target(name=<span class="hljs-subst">&#123;name&#125;</span>)&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在不用<code>wraps</code>装饰器的情况下，<code>target</code>的<code>__name__</code>和<code>__doc__</code>属性都来自<code>deco()</code>里的<code>inner</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__doc__  :&#x27;</span>, target.__doc__)   <span class="hljs-comment"># __doc__  : inner doc</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__name__ :&#x27;</span>, target.__name__)  <span class="hljs-comment"># __name__ : inner</span><br>target(name=<span class="hljs-string">&#x27;bob&#x27;</span>)                    <span class="hljs-comment"># inner((), &#123;&#x27;name&#x27;: &#x27;bob&#x27;&#125;)</span><br></code></pre></td></tr></table></figure><p>这一点也不奇怪，因为此时<code>target</code>是<code>deco()</code>的返回值，其<code>__name__</code>等属性自然也不会是来自被装饰的原始<code>target</code>。但从调用者的角度来说，这是很让人费解的。所以Python内置了<code>wraps</code>装饰器，可以拷贝被装饰函数的部分属性，让装饰后的函数<code>看起来</code>和装饰前一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;inner doc&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;inner(<span class="hljs-subst">&#123;args&#125;</span>, <span class="hljs-subst">&#123;kwargs&#125;</span>)&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__doc__  :&#x27;</span>, target.__doc__)   <span class="hljs-comment"># __doc__  : target doc</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__name__ :&#x27;</span>, target.__name__)  <span class="hljs-comment"># __name__ : target</span><br>target(name=<span class="hljs-string">&#x27;bob&#x27;</span>)                    <span class="hljs-comment"># inner((), &#123;&#x27;name&#x27;: &#x27;bob&#x27;&#125;)</span><br></code></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><code>wraps</code>装饰器的入口函数在<code>functools.py</code>的第<a href="https://github.com/python/cpython/blob/3.6/Lib/functools.py#L74">74行</a>，函数很短小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wraps</span>(<span class="hljs-params">wrapped,</span><br><span class="hljs-params">          assigned = WRAPPER_ASSIGNMENTS,</span><br><span class="hljs-params">          updated = WRAPPER_UPDATES</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; ... 省略</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> partial(update_wrapper, wrapped=wrapped,<br>                   assigned=assigned, updated=updated)<br></code></pre></td></tr></table></figure><p><a href="/2020/06/19/%E8%AF%BB%E3%80%8A%E6%B5%81%E7%95%85%E7%9A%84Python%E3%80%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8">上一篇文章</a>我介绍过，带参数的函数装饰器会返回一个函数，用返回的函数来对目标函数进行装饰。于是，上面提到的<code>deco()</code>函数就可以转换为如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial, update_wrapper, WRAPPER_ASSIGNMENTS, WRAPPER_UPDATES<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br>    <span class="hljs-comment"># @functools.wraps(func)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;inner doc&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;inner(<span class="hljs-subst">&#123;args&#125;</span>, <span class="hljs-subst">&#123;kwargs&#125;</span>)&#x27;</span>)<br><br>    <span class="hljs-comment"># 关键的两行</span><br>    tmp = partial(update_wrapper, wrapped=func,<br>                  assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)<br>    inner = tmp(inner)<br><br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>由于<code>functools.partial</code>的功能只是固定参数，所以以上提到的关键的两行可以转换为如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">inner = update_wrapper(inner, wrapped=func, assigned=WRAPPER_ASSIGNMENTS,<br>                       updated=WRAPPER_UPDATES)<br></code></pre></td></tr></table></figure><p>再让我们把目光聚集在<code>update_wrapper()</code>函数的源码上（<code>functools.py</code><a href="https://github.com/python/cpython/blob/3.6/Lib/functools.py#L44">第44行</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">WRAPPER_ASSIGNMENTS = (<span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;__qualname__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>,<br>                       <span class="hljs-string">&#x27;__annotations__&#x27;</span>)<br>WRAPPER_UPDATES = (<span class="hljs-string">&#x27;__dict__&#x27;</span>,)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_wrapper</span>(<span class="hljs-params">wrapper,</span><br><span class="hljs-params">                   wrapped,</span><br><span class="hljs-params">                   assigned = WRAPPER_ASSIGNMENTS,</span><br><span class="hljs-params">                   updated = WRAPPER_UPDATES</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; ... 省略</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> assigned:<br>        <span class="hljs-keyword">try</span>:<br>            value = <span class="hljs-built_in">getattr</span>(wrapped, attr)<br>        <span class="hljs-keyword">except</span> AttributeError:<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">setattr</span>(wrapper, attr, value)<br>    <span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> updated:<br>        <span class="hljs-built_in">getattr</span>(wrapper, attr).update(<span class="hljs-built_in">getattr</span>(wrapped, attr, &#123;&#125;))<br>    <span class="hljs-comment"># Issue #17482: set __wrapped__ last so we don&#x27;t inadvertently copy it</span><br>    <span class="hljs-comment"># from the wrapped function when updating __dict__</span><br>    wrapper.__wrapped__ = wrapped<br>    <span class="hljs-comment"># Return the wrapper so this can be used as a decorator via partial()</span><br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>结合前两段代码，<code>functools.wraps</code>所做的事情就比较清晰了：通过<code>getattr()</code>从被装饰的函数中提取<code>__module__</code>、<code>__name__</code>等属性，再通过<code>setattr()</code>将提取到的属性赋值给装饰后的函数。也就是说，<code>deco()</code>装饰器最后可以转换为如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br>    <span class="hljs-comment"># @functools.wraps(func)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;inner doc&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;inner(<span class="hljs-subst">&#123;args&#125;</span>, <span class="hljs-subst">&#123;kwargs&#125;</span>)&#x27;</span>)<br><br><span class="hljs-comment"># 节省空间，不考虑AttributeError</span><br>    <span class="hljs-built_in">setattr</span>(inner, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-built_in">getattr</span>(func, <span class="hljs-string">&#x27;__module__&#x27;</span>)) <br>    <span class="hljs-comment"># ... 省略</span><br>    <span class="hljs-built_in">getattr</span>(inner, <span class="hljs-string">&#x27;__dict__&#x27;</span>).update(<span class="hljs-built_in">getattr</span>(func, <span class="hljs-string">&#x27;__dict__&#x27;</span>, &#123;&#125;))<br>    inner.__wrapped__ = func<br><br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>不考虑注释，<code>functools.wraps</code>的代码总共只有23行，可以说是相当短小了🤣</p><h1 id="functools-lru-cache"><a href="#functools-lru-cache" class="headerlink" title="functools.lru_cache"></a>functools.lru_cache</h1><p><code>lru_cache</code>是个非常实用的装饰器，这个装饰器可以将函数的结果缓存起来，避免传入相同的参数时重复计算。<code>lru</code>代表这个装饰器在缓存结果时采用<code>最近最少使用</code>算法，在缓存的结果到达一定数量时抛弃那些很久没命中过的缓存。</p><p><code>lru_cache</code>接收两个参数：<code>maxsize</code>和<code>typed</code>。前者用于指定缓存结果数量上限，而后者用于判断缓存是是否考虑参数类型。比如<code>func(1)</code>和<code>func(1.0)</code>在默认情况下会共用缓存，但当<code>typed</code>为<code>True</code>时，这两个函数就会分开缓存。</p><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>递归计算<code>fibonacci</code>数列这种需要多次重复计算的场景特别适合使用<code>lru_cache</code>装饰器。比如下面这个实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> k <span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> fibonacci(k - <span class="hljs-number">1</span>) + fibonacci(k - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>当计算<code>fibonacci(6)</code>时，总共需要调用25次<code>fibonacci()</code>函数，其中8次是<code>fibonacci(1)</code>。但使用<code>lru_cache</code>装饰器后，只需要调用7次<code>fibonacci()</code>函数即可得出计算结果，而且只需要在原函数上加上一行代码即可实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@functools.lru_cache()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> k <span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> fibonacci(k - <span class="hljs-number">1</span>) + fibonacci(k - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>比较有意思的是，使用了<code>lru_cache</code>装饰器的函数还会被”附赠”两个方法：<code>cache_info</code>和<code>cache_clear</code>，分别用于展示缓存情况和清空缓存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>fibonacci(<span class="hljs-number">6</span>)<br><span class="hljs-number">8</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fibonacci.cache_info()<br>CacheInfo(hits=<span class="hljs-number">4</span>, misses=<span class="hljs-number">7</span>, maxsize=<span class="hljs-number">128</span>, currsize=<span class="hljs-number">7</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>fibonacci.cache_clear()<br><span class="hljs-meta">&gt;&gt;&gt; </span>fibonacci.cache_info()<br>CacheInfo(hits=<span class="hljs-number">0</span>, misses=<span class="hljs-number">0</span>, maxsize=<span class="hljs-number">128</span>, currsize=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p><code>functool.lru_cache</code>在CPython里有两种实现，一种基于C语言（<code>_functool._lru_cache_wrapper</code>），另一种基于Python（<code>functool._lru_cache_wraper</code>）。后者只有在前者无法导入时才会启用，但本篇文章还是聚焦于后者的源码。</p><p><code>lru_cache</code>装饰器的入口函数在<code>functools.py</code>第<a href="https://github.com/python/cpython/blob/3.6/Lib/functools.py#L448">448行</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">_CacheInfo = namedtuple(<span class="hljs-string">&quot;CacheInfo&quot;</span>, [<span class="hljs-string">&quot;hits&quot;</span>, <span class="hljs-string">&quot;misses&quot;</span>, <span class="hljs-string">&quot;maxsize&quot;</span>, <span class="hljs-string">&quot;currsize&quot;</span>])<br><span class="hljs-comment"># ... 略</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lru_cache</span>(<span class="hljs-params">maxsize=<span class="hljs-number">128</span>, typed=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; ... 略</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> maxsize <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(maxsize, <span class="hljs-built_in">int</span>):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;Expected maxsize to be an integer or None&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorating_function</span>(<span class="hljs-params">user_function</span>):<br>        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)<br>        <span class="hljs-keyword">return</span> update_wrapper(wrapper, user_function)<br><br>    <span class="hljs-keyword">return</span> decorating_function<br></code></pre></td></tr></table></figure><p>和<code>wraps</code>一样，<code>lru_cache</code>也是一个带参数的装饰器。同时，<code>lru_cache</code>还用到了上一节提到的<code>update_wrapper()</code>函数，自动将被装饰函数的属性拷贝到新函数中。这段代码的关键是<code>wrapper = _lru_cache_wrapper(...)</code>，那就让我们来看看<code>_lru_cache_wrapper</code>函数的源码结构（<code>functools.py</code>第<a href="https://github.com/python/cpython/blob/3.6/Lib/functools.py#L485">485行</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_lru_cache_wrapper</span>(<span class="hljs-params">user_function, maxsize, typed, _CacheInfo</span>):<br>    <span class="hljs-comment"># 初始化变量，省略</span><br><br>    <span class="hljs-keyword">if</span> maxsize == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwds</span>):<br>            <span class="hljs-comment"># No caching -- just a statistics update after a successful call</span><br>            <span class="hljs-comment"># ... 省略</span><br>    <span class="hljs-keyword">elif</span> maxsize <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwds</span>):<br>            <span class="hljs-comment"># Simple caching without ordering or size limit</span><br>            <span class="hljs-comment"># ... 省略</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwds</span>):<br>            <span class="hljs-comment"># Size limited caching that tracks accesses by recency</span><br>            <span class="hljs-comment"># ... 省略</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cache_info</span>():<br>        <span class="hljs-string">&quot;&quot;&quot;Report cache statistics&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># ... 省略</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cache_clear</span>():<br>        <span class="hljs-string">&quot;&quot;&quot;Clear the cache and cache statistics&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># ... 省略</span><br><br>    wrapper.cache_info = cache_info<br>    wrapper.cache_clear = cache_clear<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>所以，当某个函数使用了<code>lru_cache</code>装饰器后，调用这个函数时被执行的实际上是源码里定义的各个<code>wrapper</code>，<code>cache_info()</code>和<code>cache_clear()</code>这两个方法也是在源码里为<code>wrapper</code>加上的。接下来，就让我们具体分析源码里定义的各个模块。</p><h3 id="maxsize为0"><a href="#maxsize为0" class="headerlink" title="maxsize为0"></a>maxsize为0</h3><p>当<code>maxsize</code>为0时，<code>lru_cache</code>不会缓存任何结果，除了调用原始函数并返回结果外，只增加<code>misses</code>（缓存未命中）计数器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_lru_cache_wrapper</span>(<span class="hljs-params">user_function, maxsize, typed, _CacheInfo</span>):<br>    <span class="hljs-comment"># ...</span><br>    hits = misses = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">if</span> maxsize == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwds</span>):<br>            <span class="hljs-comment"># No caching -- just a statistics update after a successful call</span><br>            <span class="hljs-keyword">nonlocal</span> misses<br>            result = user_function(*args, **kwds)<br>            misses += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> result<br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h3 id="maxsize为None"><a href="#maxsize为None" class="headerlink" title="maxsize为None"></a>maxsize为None</h3><p>当<code>maxsize</code>为<code>None</code>时，<code>lru_cache</code>会无限制地缓存结果，<code>lru</code>算法并不会生效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_lru_cache_wrapper</span>(<span class="hljs-params">user_function, maxsize, typed, _CacheInfo</span>):<br>    <span class="hljs-comment"># Constants shared by all lru cache instances:</span><br>    sentinel = <span class="hljs-built_in">object</span>()          <span class="hljs-comment"># unique object used to signal cache misses</span><br>    make_key = _make_key         <span class="hljs-comment"># build a key from the function arguments</span><br>    cache = &#123;&#125;<br>    hits = misses = <span class="hljs-number">0</span><br>    cache_get = cache.get    <span class="hljs-comment"># bound method to lookup a key or return None</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">elif</span> maxsize <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwds</span>):<br>            <span class="hljs-comment"># Simple caching without ordering or size limit</span><br>            <span class="hljs-keyword">nonlocal</span> hits, misses<br>            key = make_key(args, kwds, typed)<br>            result = cache_get(key, sentinel)<br>            <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> sentinel:<br>                hits += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> result<br>            result = user_function(*args, **kwds)<br>            cache[key] = result<br>            misses += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> result<br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>lru_cache</code>首先会通过函数的参数生成<code>key</code>值（<code>make_key</code>），再用<code>key</code>值去缓存池（<code>dict</code>）里查找结果。如果命中缓存，则返回缓存并增加<code>hits</code>计数器；否则调用函数返回结果，将结果加入缓存池并增加<code>misses</code>（缓存未命中）计数器。</p><h3 id="make-key"><a href="#make-key" class="headerlink" title="_make_key"></a>_make_key</h3><p>再让我们将目光转到<code>_make_key</code>上来。这个函数会通过函数的参数、<code>typed</code>的值来为函数调用生成<code>key</code>值，用于在缓存池里查找或缓存结果。其源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_HashedSeq</span>(<span class="hljs-title class_ inherited__">list</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; ... 省略</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    __slots__ = <span class="hljs-string">&#x27;hashvalue&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, tup, <span class="hljs-built_in">hash</span>=<span class="hljs-built_in">hash</span></span>):<br>        self[:] = tup<br>        self.hashvalue = <span class="hljs-built_in">hash</span>(tup)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.hashvalue<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_key</span>(<span class="hljs-params">args, kwds, typed,</span><br><span class="hljs-params">             kwd_mark = (<span class="hljs-params"><span class="hljs-built_in">object</span>(<span class="hljs-params"></span>),</span>),</span><br><span class="hljs-params">             fasttypes = &#123;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">frozenset</span>, <span class="hljs-built_in">type</span>(<span class="hljs-params"><span class="hljs-literal">None</span></span>)&#125;,</span><br><span class="hljs-params">             <span class="hljs-built_in">tuple</span>=<span class="hljs-built_in">tuple</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">type</span>, <span class="hljs-built_in">len</span>=<span class="hljs-built_in">len</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; ... 省略</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    key = args<br>    <span class="hljs-keyword">if</span> kwds:<br>        key += kwd_mark<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> kwds.items():<br>            key += item<br>    <span class="hljs-keyword">if</span> typed:<br>        key += <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">type</span>(v) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> args)<br>        <span class="hljs-keyword">if</span> kwds:<br>            key += <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">type</span>(v) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> kwds.values())<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(key) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">type</span>(key[<span class="hljs-number">0</span>]) <span class="hljs-keyword">in</span> fasttypes:<br>        <span class="hljs-keyword">return</span> key[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> _HashedSeq(key)<br></code></pre></td></tr></table></figure><p>从这段源码可以看出，当函数的参数只有一个、<code>typed</code>为<code>False</code>、且类型为<code>int</code>、<code>str</code>等时，<code>_make_key</code>会直接将该参数作为<code>key</code>值返回。否则，<code>_make_key</code>会生成一个<code>_HashedSeq</code>来存储函数的参数，当<code>typed</code>为<code>True</code>时还会存储参数的类型，且<code>*args</code>和<code>**kwargs</code>这两种参数之间会插入一个<code>object</code>用作分隔。下面这几个例子能帮助理解这段源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> _make_key<br><span class="hljs-meta">&gt;&gt;&gt; </span>_make_key((<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;123&#x27;</span>), &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;, <span class="hljs-literal">False</span>)<br>[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;123&#x27;</span>, &lt;<span class="hljs-built_in">object</span> <span class="hljs-built_in">object</span> at ...&gt;, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;bob&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>_make_key((<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;123&#x27;</span>), &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;, <span class="hljs-literal">True</span>)<br>[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;123&#x27;</span>, &lt;<span class="hljs-built_in">object</span> <span class="hljs-built_in">object</span> at ...&gt;, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>_make_key((<span class="hljs-number">1</span>,), &#123;&#125;, <span class="hljs-literal">False</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>_make_key((<span class="hljs-number">1</span>,), &#123;&#125;, <span class="hljs-literal">True</span>)<br>[<span class="hljs-number">1</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;]<br></code></pre></td></tr></table></figure><h4 id="谁错了？"><a href="#谁错了？" class="headerlink" title="谁错了？"></a>谁错了？</h4><p>理解了这段源码之后，又会出现新的问题：不管<code>typed</code>为<code>True</code>还是<code>False</code>，对于单参数<code>1</code>和<code>1.0</code>，<code>_make_key()</code>得到的结果的哈希值都不一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> _make_key<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hash</span>(_make_key((<span class="hljs-number">1</span>,), &#123;&#125;, <span class="hljs-literal">False</span>))    <span class="hljs-comment"># 1</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hash</span>(_make_key((<span class="hljs-number">1.0</span>,), &#123;&#125;, <span class="hljs-literal">False</span>))  <span class="hljs-comment"># [1.0]</span><br><span class="hljs-number">3430019387558</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hash</span>(_make_key((<span class="hljs-number">1</span>,), &#123;&#125;, <span class="hljs-literal">True</span>))     <span class="hljs-comment"># [1, &lt;class &#x27;int&#x27;&gt;]</span><br><span class="hljs-number">3713082220284583106</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hash</span>(_make_key((<span class="hljs-number">1.0</span>,), &#123;&#125;, <span class="hljs-literal">True</span>))   <span class="hljs-comment"># [1.0, &lt;class &#x27;float&#x27;&gt;]</span><br><span class="hljs-number">3713082219329796056</span><br></code></pre></td></tr></table></figure><p>但此时如果使用<code>lru_cache</code>，就会发现<code>lru_cache</code>是将单参数<code>1</code>和<code>1.0</code>一起缓存的，和本文一开始对<code>lru_cache</code>的描述一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@functools.lru_cache()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">val</span>):<br>    <span class="hljs-built_in">print</span>(val)<br><br>test(<span class="hljs-number">1</span>)    <span class="hljs-comment"># 输出1</span><br>test(<span class="hljs-number">1.0</span>)  <span class="hljs-comment"># 已缓存，不输出</span><br></code></pre></td></tr></table></figure><p>所以这到底是哪里出了问题？答案就是前文提到的C语言实现和Python实现的区别。C语言实现的<code>_lru_cache_wrapper()</code>并不使用Python实现的<code>_make_key()</code>，而CPython默认使用的是前者，所以会造成这里提到的问题。</p><p>此时如果将修改CPython内置的<code>functools.py</code>，只使用Python实现的<code>_lru_cache_wrapper()</code>，就会发现结果是符合预期的。<code>1</code>和<code>1.0</code>通过<code>_make_key()</code>得到的哈希值不同，自然也就会分开缓存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 不使用C语言实现的版本</span><br>    <span class="hljs-comment"># from _functools import _lru_cache_wrapper</span><br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@functools.lru_cache()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">val</span>):<br>    <span class="hljs-built_in">print</span>(val)<br><br>test(<span class="hljs-number">1</span>)    <span class="hljs-comment"># 输出1</span><br>test(<span class="hljs-number">1.0</span>)  <span class="hljs-comment"># 输出1.0</span><br></code></pre></td></tr></table></figure><h3 id="maxsize为正整数"><a href="#maxsize为正整数" class="headerlink" title="maxsize为正整数"></a>maxsize为正整数</h3><p>当<code>maxsize</code>为正整数时，<code>lru_cache</code>不能无限制地缓存函数结果，必须用<code>lru</code>算法清除缓存。遗憾的是，由于受限于篇幅，且笔者并没有弄懂这部分的代码（这才是重点吧……），所以这部分源码就先按下不表。</p><h3 id="cache-info和cache-clear"><a href="#cache-info和cache-clear" class="headerlink" title="cache_info和cache_clear"></a>cache_info和cache_clear</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_lru_cache_wrapper</span>(<span class="hljs-params">user_function, maxsize, typed, _CacheInfo</span>):<br>    <span class="hljs-comment"># ...</span><br>    hits = misses = <span class="hljs-number">0</span><br>    full = <span class="hljs-literal">False</span><br>    cache_len = cache.__len__  <span class="hljs-comment"># get cache size without calling len()</span><br>    lock = RLock()           <span class="hljs-comment"># because linkedlist updates aren&#x27;t threadsafe</span><br>    root = []                <span class="hljs-comment"># root of the circular doubly linked list</span><br>    root[:] = [root, root, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]     <span class="hljs-comment"># initialize by pointing to self</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cache_info</span>():<br>        <span class="hljs-string">&quot;&quot;&quot;Report cache statistics&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">with</span> lock:<br>            <span class="hljs-keyword">return</span> _CacheInfo(hits, misses, maxsize, cache_len())<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cache_clear</span>():<br>        <span class="hljs-string">&quot;&quot;&quot;Clear the cache and cache statistics&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">nonlocal</span> hits, misses, full<br>        <span class="hljs-keyword">with</span> lock:<br>            cache.clear()<br>            root[:] = [root, root, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>]<br>            hits = misses = <span class="hljs-number">0</span><br>            full = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>这两个函数的作用比较单纯，分别是返回当前缓存状态和清空缓存。源码也简单易懂，这里就不过多介绍。其中<code>root</code>、<code>lock</code>、<code>full</code>等变量是只有在<code>maxsize</code>为正整数，或者说启用<code>lru</code>算法时才需要的，本文介绍的、针对其它情况的源码不需要这几个变量。</p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>本来笔者还想分析<code>singledispatch</code>装饰器的源码的，但一个<code>lru_cache</code>就把笔者折腾得够呛，这还是跳过了最复杂的<code>lru</code>算法的情况下……路漫漫其修远兮啊。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《流畅的Python》：函数装饰器与闭包</title>
    <link href="/2020/06/19/fluent-python-chap-7/"/>
    <url>/2020/06/19/fluent-python-chap-7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2020/06/19/fluent_python.webp"></p><p>读书笔记这种内容，放在<code>Evernote</code>等笔记软件里似乎要比放在博客里更合适。但其一是笔者还没有找到适合我的笔记同步方案，其二是博客相比笔记软件更能锻炼自身的表达能力（或许吧），其三是将读书笔记放在博客里可以避免在求职的时候被面试官吐槽博客内容太少（笑），所以还是决定将这篇文章放在博客里。</p><p>但不管怎样，读书笔记终归是读书笔记，对其他人的作用还是有限，如有读者觉得碍眼烦请无视。</p><blockquote><p>注：本篇文章使用CPython3.6</p></blockquote><h1 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h1><p>函数装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。下面是一个简单的装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running inner()&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>用法也很容易理解，下面两段代码效果一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@deco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br><br>target = deco(target)<br></code></pre></td></tr></table></figure><p>从上面的例子就可以看出，装饰器只是一个语法糖。即使没有这个语法糖，也只是在进行类似的操作时需要更繁琐的代码，但不会造成功能上的缺失。</p><p>既然上面两段代码效果一样，那装饰器何时运行就很明显了：<strong>在被装饰的函数定义之后（通常是函数被导入时）立即运行</strong>。毕竟，真正被导入的不是<code>target()</code>，而是<code>deco()</code>的返回值。而要获得<code>deco()</code>的返回值，就必须让<code>deco()</code>先运行。</p><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>下面两段代码有什么区别？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">9</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-built_in">print</span>(b)<br><br>f1()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">9</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># UnboundLocalError: local variable &#x27;b&#x27; referenced before assignment</span><br>    b = <span class="hljs-number">3</span><br><br>f2()<br></code></pre></td></tr></table></figure><p>答案是后一段代码在执行<code>print(b)</code>时会抛出<code>UnboundLocalError</code>。因为在<code>f2()</code>中变量<code>b</code>被赋值了（<code>b = 3</code>），于是Python在编译<code>f2()</code>的定义体时将<code>b</code>视为局部变量，而不是像<code>f1()</code>那样在全局变量里查找<code>b</code>。如果想让<code>f2()</code>也将<code>b</code>视为全局变量，就需要使用<code>global</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">9</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-keyword">global</span> b<br>    <span class="hljs-built_in">print</span>(b)<br>    b = <span class="hljs-number">3</span><br><br>f1()  <span class="hljs-comment"># 正常运行</span><br></code></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>为什么会突然提到变量作用域这个概念呢？我们知道，Python中的局部变量在离开作用域会后被GC（垃圾回收）机制销毁，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> weakref<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br><span class="hljs-meta">... </span>    s = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">... </span>    weakref.finalize(s, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s has gone&#x27;</span>))<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>foo()<br>s has gone<br></code></pre></td></tr></table></figure><p>很明显，<code>foo()</code>运行完成后，运行期间创建的变量<code>s</code>被销毁了。但如果我们想在<code>foo()</code>内部再定义一个函数，并让这个函数能访问变量<code>s</code>，那<code>s</code>就不会被销毁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> weakref<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br><span class="hljs-meta">... </span>    s = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">... </span>    weakref.finalize(s, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s has gone&#x27;</span>))<br>...<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(s)<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> bar<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bar = foo()<br><span class="hljs-meta">&gt;&gt;&gt; </span>bar()<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>像<code>bar()</code>这种<strong>延伸了作用域的函数</strong>叫做<strong>闭包</strong>，它能访问不在定义体内定义的非全局变量。从这点可以看出，只有嵌套函数才有闭包这个概念。</p><p>变量<code>s</code>在<code>foo()</code>运行函数后已经是孤魂野鬼，被称作自由变量（<code>free variable</code>）。但<code>bar()</code>要能够访问变量<code>s</code>，就需要持有变量<code>s</code>的引用，这点可以从<code>__code__</code>属性（编译后的函数定义体）和<code>__closure__</code>属性中可以看出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bar.__code__.co_varnames  <span class="hljs-comment"># 局部变量</span><br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>bar.__code__.co_freevars  <span class="hljs-comment"># 自由变量</span><br>(<span class="hljs-string">&#x27;s&#x27;</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bar.__closure__<br>(&lt;cell at ...: <span class="hljs-built_in">set</span> <span class="hljs-built_in">object</span> at ...&gt;,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bar.__closure__[<span class="hljs-number">0</span>].cell_contents<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="危险地带：被删除的自由变量"><a href="#危险地带：被删除的自由变量" class="headerlink" title="危险地带：被删除的自由变量"></a>危险地带：被删除的自由变量</h2><p>Python在编译<code>foo()</code>时发现<code>bar()</code>需要访问变量<code>s</code>，于是将<code>s</code>视为自由变量，即使离开作用域也不会销毁。但Python不是静态语言，对象的实际状态需要等到运行时才能确定。看下面这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    s = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br>    weakref.finalize(s, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s has gone&#x27;</span>))<br>    <span class="hljs-keyword">del</span> s         <span class="hljs-comment"># 1. 输出s has gone</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br>        <span class="hljs-built_in">print</span>(s)  <span class="hljs-comment"># 4. NameError: free variable &#x27;s&#x27; referenced before assignment in enclosing scope</span><br><br>    <span class="hljs-keyword">return</span> bar<br><br><br>bar = foo()<br><span class="hljs-built_in">print</span>(bar.__code__.co_freevars)  <span class="hljs-comment"># 2. 输出(&#x27;s&#x27;,)</span><br><span class="hljs-built_in">print</span>(bar.__closure__[<span class="hljs-number">0</span>])        <span class="hljs-comment"># 3. 输出&lt;cell at ...: empty&gt;</span><br>bar()<br></code></pre></td></tr></table></figure><p>这段代码的执行顺序和输出结果已经以注释的形式附加。Python在编译完<code>bar()</code>之后知道应该将<code>s</code>视为自由变量，但实际上<code>bar()</code>在运行时变量<code>s</code>已经被删除了……这个例子告诉我们，Python的动态特性是把双刃剑，更直白点就是：不要作死.</p><h2 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h2><p>再来看看这样一个返回值为<code>统计平均值的函数</code>的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    nums = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        nums.append(num)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(nums) / <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-keyword">return</span> averager<br><br>averager = make_averager()<br><span class="hljs-built_in">print</span>(averager(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 10.0</span><br><span class="hljs-built_in">print</span>(averager(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 7.5</span><br></code></pre></td></tr></table></figure><p>嗯，运行很完美。优化一下这个函数，让它不需要将所有的数字都保存起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    total, count = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        total += num  <span class="hljs-comment"># UnboundLocalError</span><br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total / count<br><br>    <span class="hljs-keyword">return</span> averager<br></code></pre></td></tr></table></figure><p>和上一节的第二个例子类似，<code>averager()</code>在运行时会抛出<code>UnboundLocalError</code>异常。但这次不能用<code>global</code>关键字来解决这个异常了：因为<code>total</code>和<code>num</code>压根就不是全局变量，而是作用域仅限<code>make_averager()</code>的局部变量。那怎样让<code>averager()</code>能修改<code>total</code>和<code>num</code>呢？答案是<code>nonlocal</code>关键字。和<code>global</code>关键字类似，<code>nonlocal</code>会告知Python：<strong>这个变量在更外层的作用域</strong>。如代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    total, count = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">nonlocal</span> total, count<br>        total += num<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total / count  <span class="hljs-comment"># 正常运行</span><br><br>    <span class="hljs-keyword">return</span> averager<br></code></pre></td></tr></table></figure><p>但<code>nonlocal</code>关键字并不能取代<code>global</code>关键字，因为局部变量（<code>locals()</code>）和全局变量（<code>globals()</code>）是互相独立的，比如如下的代码会抛出<code>SyntaxError</code>，即使<code>f2()</code>并没有被实际执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-number">9</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-keyword">nonlocal</span> b<br>    <span class="hljs-built_in">print</span>(b)<br>    b = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>同时<code>nonlocal</code>关键字的声明是不限深度的，也就是说Python会一直向更外层的作用域寻找这个变量，直到找到为止。如代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    total, count = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">deeper</span>():<br>            <span class="hljs-keyword">nonlocal</span> total, count<br>            total += num<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> total / count  <span class="hljs-comment"># 正常运行</span><br><br>        <span class="hljs-keyword">return</span> deeper()<br><br>    <span class="hljs-keyword">return</span> averager<br></code></pre></td></tr></table></figure><h1 id="计时函数装饰器"><a href="#计时函数装饰器" class="headerlink" title="计时函数装饰器"></a>计时函数装饰器</h1><p>了解了函数装饰器、闭包等概念后，就可以编写一个稍微具有一点实用性的函数装饰器了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">clock</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;inner doc&quot;&quot;&quot;</span><br>        t0 = time.perf_counter()<br>        result = func(*args, **kwargs)<br>        elapsed = time.perf_counter() - t0<br>        fmt = <span class="hljs-string">&#x27;[&#123;elapsed:.4f&#125;s] &#123;func.__name__&#125;(&#123;args&#125;, &#123;kwargs&#125;): &#123;result&#125;&#x27;</span><br>        <span class="hljs-built_in">print</span>(fmt.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">locals</span>()))<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>同样的，<code>inner</code>函数属于闭包函数，<code>func</code>属于自由变量。使用方法和效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@clock</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">snooze</span>(<span class="hljs-params">second: <span class="hljs-built_in">float</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;snooze doc&quot;&quot;&quot;</span><br>    time.sleep(second)<br><br>snooze(<span class="hljs-number">0.1</span>)  <span class="hljs-comment"># 输出：[0.1001s] snooze((0.1,), &#123;&#125;): None</span><br></code></pre></td></tr></table></figure><h2 id="functool-wraps"><a href="#functool-wraps" class="headerlink" title="functool.wraps"></a>functool.wraps</h2><p>上面这个装饰器的缺点是无法继承被装饰函数的属性（如<code>__name__</code>、<code>__doc__</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(snooze.__name__)  <span class="hljs-comment"># inner</span><br><span class="hljs-built_in">print</span>(snooze.__doc__)  <span class="hljs-comment"># inner doc</span><br></code></pre></td></tr></table></figure><p>这个时候就需要请出Python内置的装饰器<code>functool.wraps</code>了，这个装饰器会自动复制被装饰函数的属性到返回值函数里（换句话说就是让<code>inner()</code>按目标函数<code>snnoze()</code>的样子整个容）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">clock</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;inner doc&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># ... 略</span><br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@clock</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">snooze</span>(<span class="hljs-params">second: <span class="hljs-built_in">float</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;snooze doc&quot;&quot;&quot;</span><br>    time.sleep(second<br><br><span class="hljs-built_in">print</span>(snooze.__name__)  <span class="hljs-comment"># snooze</span><br><span class="hljs-built_in">print</span>(snooze.__doc__)  <span class="hljs-comment"># snooze doc</span><br></code></pre></td></tr></table></figure><h1 id="带参数的函数装饰器"><a href="#带参数的函数装饰器" class="headerlink" title="带参数的函数装饰器"></a>带参数的函数装饰器</h1><p>上节提到的<code>functool.wraps</code>装饰器比较特别，这个装饰器可以传入参数。我们知道，对于不带参数的装饰器，下面两段代码是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@deco</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br><br>target = deco(target)<br></code></pre></td></tr></table></figure><p>而对于带参数的装饰器，下面两段代码也是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@deco(<span class="hljs-params"><span class="hljs-number">123</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br><br>target = deco(<span class="hljs-number">123</span>)(target)<br></code></pre></td></tr></table></figure><p>从上面的例子可以看出，装饰器带不带参数，决定了是用这个函数本身来当装饰器，还是用函数的返回值来当装饰器（可能有点绕）。用这个思路改进一下前面提到的函数计时装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">DEFAULT_FMT = <span class="hljs-string">&#x27;[&#123;elapsed:.4f&#125;s] &#123;func.__name__&#125;(&#123;args&#125;, &#123;kwargs&#125;): &#123;result&#125;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clock_plus</span>(<span class="hljs-params">fmt=DEFAULT_FMT</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clock</span>(<span class="hljs-params">func: <span class="hljs-type">Callable</span></span>) -&gt; <span class="hljs-type">Callable</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;inner doc&quot;&quot;&quot;</span><br>            t0 = time.perf_counter()<br>            result = func(*args, **kwargs)<br>            elapsed = time.perf_counter() - t0<br>            <span class="hljs-built_in">print</span>(fmt.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">locals</span>()))<br>            <span class="hljs-keyword">return</span> result<br><br>        <span class="hljs-keyword">return</span> inner<br>    <span class="hljs-keyword">return</span> clock<br></code></pre></td></tr></table></figure><p>用法和效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@clock_plus(<span class="hljs-params">fmt=<span class="hljs-string">&#x27;&#123;elapsed:.4f&#125;&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">snooze</span>(<span class="hljs-params">second: <span class="hljs-built_in">float</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;snooze doc&quot;&quot;&quot;</span><br>    time.sleep(second)<br><br>snooze(<span class="hljs-number">0.1</span>)  <span class="hljs-comment"># 输出：0.1001</span><br></code></pre></td></tr></table></figure><p>所以，带参数的函数装饰器只是在不带函数的装饰器外面裹了一层，并没有太多魔术操作。</p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>《流畅的Python》第七章（函数装饰器和闭包）的概念不算少，同时笔者也没能在提取关键信息的基础上控制好篇幅，再加上文章里还有笔者的一些个人理解，所以文章最后只能草草收尾，没有介绍叠放装饰器、<code>functools.lru_cache</code>等内容。</p><p>也许在读完这类书籍后，画一个思维导图，或单纯写一篇给自己看的笔记才是最好的选择，至少不会在博客里丢人（逃</p>]]></content>
    
    
    
    <tags>
      
      <tag>流畅的Python</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Python中引起内存泄露</title>
    <link href="/2020/06/14/%E5%A6%82%E4%BD%95%E5%9C%A8Python%E4%B8%AD%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <url>/2020/06/14/%E5%A6%82%E4%BD%95%E5%9C%A8Python%E4%B8%AD%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2020/06/14/gc.jpg"></p><p>嗯，怎么看怎么像标题党写的标题……其实这篇文章只是笔者对Python中引用计数、弱引用的一些记录和思考，不涉及引用循环、分代回收等概念，先打个预防针。</p><blockquote><p>注：本篇文章基于CPython 3.6，可能不适用于其它CPython版本或其它类型的Python实现。</p></blockquote><h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p><strong>引用计数</strong>（Reference counting）可以说是一个老生常谈的问题了，炒冷饭也没啥意思。引用一下《流畅的Python》里的描述：<em>“每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁”</em>。引用计数在不存在<strong>引用循环</strong>（Reference cycle）时能够及时清理内存，这也是CPython最主要的垃圾回收算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> weakref<br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.getrefcount(s1)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2 = s1<br><span class="hljs-meta">&gt;&gt;&gt; </span>s2 <span class="hljs-keyword">is</span> s1<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.getrefcount(s1)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>weakref.finalize(s1, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;obj has gone&quot;</span>))<br>&lt;finalize <span class="hljs-built_in">object</span> at ...; <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;set&#x27;</span> at ...&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> s2<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.getrefcount(s1)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> s1<br>obj has gone<br></code></pre></td></tr></table></figure><p>从上面的例子可以看出，<code>set(range(3))</code>这个对象总共有两个引用：<code>s1</code>和<code>s2</code>，只有当这两个引用都无效（<code>del s2</code>、<code>del s1</code>）之后，这个对象才会被销毁（或者说占用的内存空间被回收）。</p><p>需要注意的是，<code>sys.getrefcount()</code>返回的值会比真实引用计数值高出1，因为参数传递会（临时）增加一个引用，详见<a href="https://docs.python.org/3.6/library/sys.html#sys.getrefcount">官方文档</a>。同时，笔者用到了<code>weakref.finalize()</code>方法来确认对象是否被销毁，该方法会在第一个参数指向的对象被销毁时调用第二个参数（一个<code>Callable</code>对象）。</p><h1 id="如何引起内存泄露"><a href="#如何引起内存泄露" class="headerlink" title="如何引起内存泄露"></a>如何引起内存泄露</h1><p>前面提到，引用计数在不存在引用循环时能及时清理内存，但这并不能代表程序员就能高枕无忧了。毕竟，被遗忘的引用也是引用。考虑下面这个可以追踪当前实例的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOBJ</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __instances = <span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>):<br>        self.name = name<br>        self.__instances.add(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;MyOBJ(&#x27;<span class="hljs-subst">&#123;self.name&#125;</span>&#x27;)&quot;</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">instances</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-keyword">return</span> cls.__instances<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>obj1 = MyOBJ(<span class="hljs-string">&quot;obj1&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>weakref.finalize(obj1, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;obj1 has gone&quot;</span>))<br>&lt;finalize <span class="hljs-built_in">object</span> at ...; <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;MyOBJ&#x27;</span> at ...&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> obj1<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(MyOBJ.instances())<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到，即使通过<code>del obj1</code>将对象的引用删除，但由于<code>MyOBJ</code>这个类的<code>__instances</code>属性里始终持有<code>obj1</code>对应对象的另一个引用，所以这个对象始终无法被销毁。如果不能将<code>__instances</code>里的引用也删除，就会引起内存泄露。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>MyOBJ.instances().pop()<br>MyOBJ(<span class="hljs-string">&#x27;obj1&#x27;</span>)<br>obj1 has gone<br></code></pre></td></tr></table></figure><h1 id="弱引用（weakref）"><a href="#弱引用（weakref）" class="headerlink" title="弱引用（weakref）"></a>弱引用（weakref）</h1><p>可能从第一个例子里就有读者奇怪：<code>weakref.finalize()</code>会在对象被销毁时执行动作，按理说也应该持有该对象的一个引用才对，这不就产生矛盾了吗？实际上<code>weakref</code>这个模块名就给出了说明：<strong>弱引用</strong>（weakref）指不增加对象引用计数的引用。于是，<code>weakref.finalize()</code>自然也就不会妨碍对象被销毁了。</p><p>同样的，上一节提到的内存泄露问题也可以通过<code>weakref</code>模块提供的功能解决。只需要将<code>MyOBJ</code>里<code>__instances</code>的类型改为<code>WeakSet</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOBJ</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __instances = weakref.WeakSet()<br>    <br>    <span class="hljs-comment"># ... 省略</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>obj1 = MyOBJ(<span class="hljs-string">&quot;obj1&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>weakref.finalize(obj1, <span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;obj1 has gone&quot;</span>))<br>&lt;finalize <span class="hljs-built_in">object</span> at ...; <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;MyOBJ&#x27;</span> at ...&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(MyOBJ.instances())<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> obj1<br>obj1 has gone<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(MyOBJ.instances())<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在引入了<code>WeakSet</code>后，<code>__instances</code>属性持有的引用都是弱引用，当实际的对象被垃圾回收机制销毁时，<code>__instances</code>属性里的引用也会跟着被删除。类似的数据结构还有<code>WeakKeyDictionary</code>、<code>WeakValueDictionary</code>，它们会将对象的引用分别当成字典的键和值，更具体的说明可以参考<a href="https://docs.python.org/3.6/library/weakref.html">官方文档</a>。</p><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>实际上本文只涉及Python内存管理中最基本的一些概念。关于引用循环、分代回收等概念，推荐阅读以下内容：</p><ul><li><a href="https://github.com/python/cpython/blob/3.6/Modules/gcmodule.c#L899">cpython&#x2F;gcmodule.c at 3.6 · python&#x2F;cpython</a></li><li><a href="https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/">The Garbage Collector | Yet Another Python Internals Blog</a></li><li><a href="https://www.quora.com/How-does-garbage-collection-in-Python-work-What-are-the-pros-and-cons">How does garbage collection in Python work? What are the pros and cons? - Quora</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何高效地对100万个UUID进行前缀匹配查询</title>
    <link href="/2020/06/13/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E5%AF%B9100%E4%B8%87%E4%B8%AAUUID%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E6%9F%A5%E8%AF%A2/"/>
    <url>/2020/06/13/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E5%AF%B9100%E4%B8%87%E4%B8%AAUUID%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2020/06/13/redis-logo.png"></p><p>在《Redis实战》这本书的第六章中，作者介绍了如何使用Redis的ZSET来实现通讯录自动补全（即前缀匹配查询）。这部分内容激发了我的兴趣，于是我借助这个机会抛出问题：如何高效地对100万个UUID进行前缀匹配，并尝试用这篇文章来解答。</p><h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p>首先是数据准备工作：生成100万个UUID、将其写入至Redis和MariaDB（后者可作为对比）。顺便一提，Redis和MariaDB均在笔者电脑上通过Docker部署，版本分别为Redis 6.0和MariaDB 10.4。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># 生成100万个UUID</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;0..999999&#125;; <span class="hljs-keyword">do</span> uuidgen; <span class="hljs-keyword">done</span> &gt; uuids_1m.txt</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">du</span> uuids_1m.txt -h</span><br>36Muuids_1m.txt<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">head</span> -n2 uuid_1m.txt</span><br>25e2cc59-b117-4961-9bc6-a63c5b1770db<br>e9f833b9-630d-47cb-b2ae-69c6d1bc2bde<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">redis&gt; </span><span class="language-bash">zcount uuids -inf +inf</span><br>(integer) 1000000<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># MariaDB表结构，在uuid字段加了索引<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> uuids (<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    uuid <span class="hljs-type">char</span>(<span class="hljs-number">36</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    key idx_uuid (uuid)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">mariadb<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> uuids;<br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000000</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br>mariadb<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> table_name, data_length, index_length <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;uuids&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">------------+-------------+--------------+</span><br><span class="hljs-operator">|</span> table_name <span class="hljs-operator">|</span> data_length <span class="hljs-operator">|</span> index_length <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------+-------------+--------------+</span><br><span class="hljs-operator">|</span> uuids      <span class="hljs-operator">|</span> <span class="hljs-number">64569344</span>    <span class="hljs-operator">|</span> <span class="hljs-number">78397440</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">------------+-------------+--------------+</span><br></code></pre></td></tr></table></figure><p>可以看到，在插入100万条UUID数据后，MariaDB数据表的大小超过了60MB，索引的大小超过了70MB。同时，数据准备完成后，Redis和MariaDB的内存占用从刚部署时的5M和80M上升至了120M和270M。</p><h1 id="Python遍历查询"><a href="#Python遍历查询" class="headerlink" title="Python遍历查询"></a>Python遍历查询</h1><p>数据准备完成后，下面要做的就是进行前缀匹配查询。最直接的方式应该是遍历查询了，实现起来也简单，但<code>O(n)</code>的时间复杂实在是让人不敢恭维，代码贴出来权当消遣。</p><p>为了更符合前缀匹配查询的定义，我在读取完UUID后还会对数据进行一次排序操作，而这个排序的时间消耗是不会被统计到后续的性能对比中的，这对下一节的二分查询同样适用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">uuids = []<br><span class="hljs-comment"># .. 读取uuid</span><br>uuids.sort()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">str</span>, limit=<span class="hljs-number">10</span></span>):<br>    start = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> start &lt; <span class="hljs-built_in">len</span>(uuids) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> uuids[start].startswith(prefix):<br>        start += <span class="hljs-number">1</span><br>    ans = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, <span class="hljs-built_in">min</span>(start + limit, <span class="hljs-built_in">len</span>(uuids))):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> uuids[i].startswith(prefix):<br>            <span class="hljs-keyword">break</span><br>        ans.append(uuids[i])<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="Python二分查询"><a href="#Python二分查询" class="headerlink" title="Python二分查询"></a>Python二分查询</h1><p>遍历查询最大的问题在于其<code>O(n)</code>的时间复杂度。但只要目标数据是有序的，那就到时间复杂度只有<code>O(log n)</code>的二分查询上场的时候了。对于前缀匹配查询来说，查询以<code>abcd</code>开头的字符串，本质上是查询比<code>abcczzzz...</code>大的字符串。而在代码中，我用<code>0xffff</code>这个边界符号来代替前文提到的那一串<code>zzzz....</code>，这对UUID这种不超过ASCII码范围的字符串来说已经足够了。</p><p>同时，代码里二分查找的结果（<code>start</code>）是第一个大于要找的字符串的元素的下标，这点需要注意。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bin_search</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">str</span>, limit=<span class="hljs-number">10</span></span>):<br>    target = prefix[:-<span class="hljs-number">1</span>] + <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(prefix[-<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>) + <span class="hljs-built_in">chr</span>(<span class="hljs-number">0xffff</span>)<br>    left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(uuids) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:<br>        mid = (left + right) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> uuids[mid] == target:<br>            start = left + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> uuids[mid] &lt; target:<br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            right = mid - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        start = left<br>    ans = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, <span class="hljs-built_in">min</span>(start + limit, <span class="hljs-built_in">len</span>(uuids))):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> uuids[i].startswith(prefix):<br>            <span class="hljs-keyword">break</span><br>        ans.append(uuids[i])<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h1 id="Redis-ZSET查询"><a href="#Redis-ZSET查询" class="headerlink" title="Redis+ZSET查询"></a>Redis+ZSET查询</h1><p>Redis+ZSET查询的原理和二分查询原理的类似。Redis中的ZSET默认会按照元素的分值进行排序，但如果两个元素的分值一致，那就按元素本身排序。换言之，在ZSET里存放多个分值一致的UUID，从中任意取出一段UUID，这些UUID必然是有序的。</p><p>而为了进行前缀匹配查询，我们需要在ZSET里插入两个边界元素，用来标示开始和结束。对于前缀<code>abcd</code>来说，这两个边界元素就是<code>abcc0xffff</code>和<code>abcd0xffff</code>，ZSET里这两个边界元素之间的数据就是我们想要查询的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">redis_zset</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">str</span>, limit=<span class="hljs-number">10</span></span>):<br>    identifier = <span class="hljs-built_in">str</span>(uuid4())<br>    start = prefix[:-<span class="hljs-number">1</span>] + <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(prefix[-<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>)<br>    start += <span class="hljs-built_in">chr</span>(<span class="hljs-number">0xffff</span>) + identifier<br>    end = prefix + <span class="hljs-built_in">chr</span>(<span class="hljs-number">0xffff</span>) + identifier<br>    conn.zadd(<span class="hljs-string">&quot;uuids&quot;</span>, &#123;start: <span class="hljs-number">0</span>, end: <span class="hljs-number">0</span>&#125;)  <span class="hljs-comment"># 所有UUID的分值都是0</span><br>    si = conn.zrank(<span class="hljs-string">&quot;uuids&quot;</span>, start) + <span class="hljs-number">1</span><br>    ei = conn.zrank(<span class="hljs-string">&quot;uuids&quot;</span>, end) - <span class="hljs-number">1</span><br>    ei = <span class="hljs-built_in">min</span>(si + limit - <span class="hljs-number">1</span>, ei)<br>    pipe = conn.pipeline()<br>    pipe.zrange(<span class="hljs-string">&quot;uuids&quot;</span>, si, ei)<br>    pipe.zrem(<span class="hljs-string">&quot;uuids&quot;</span>, start, end)<br>    zr = pipe.execute()[<span class="hljs-number">0</span>]  <span class="hljs-comment"># type: <span class="hljs-type">List</span>[<span class="hljs-built_in">bytes</span>]</span><br>    ans = [uuid.decode(<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">for</span> uuid <span class="hljs-keyword">in</span> zr]<br>    <span class="hljs-keyword">return</span> [uuid <span class="hljs-keyword">for</span> uuid <span class="hljs-keyword">in</span> ans <span class="hljs-keyword">if</span> <span class="hljs-built_in">chr</span>(<span class="hljs-number">0xffff</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> uuid]<br></code></pre></td></tr></table></figure><p>可以看到，查询过程还是很复杂的：要先插入边界元素，再找出两个边界元素的位置，再用边界元素的位置获取查询结果。而且由于过程复杂，这种方法实际的性能表现并不能让人满意，这个之后再分析。</p><blockquote><p>这段代码有很大的隐患：没有考虑多个查询同时执行的情况。更完善的实现请参考《Redis实战》第六章：使用Redis构建应用程序组件</p></blockquote><h1 id="MariaDB-Like查询"><a href="#MariaDB-Like查询" class="headerlink" title="MariaDB+Like查询"></a>MariaDB+Like查询</h1><p>最后介绍一种简单粗暴的查询方法：MariaDB+Like查询，一条SQL解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mysql_like</span>(<span class="hljs-params">prefix: <span class="hljs-built_in">str</span>, limit=<span class="hljs-number">10</span></span>):<br>    sql = <span class="hljs-string">&quot;select uuid from uuids where uuid like %s order by uuid limit %s&quot;</span><br>    cursor.execute(sql, (prefix + <span class="hljs-string">&#x27;%&#x27;</span>, limit))<br>    <span class="hljs-keyword">return</span> [uuid <span class="hljs-keyword">for</span> uuid, <span class="hljs-keyword">in</span> cursor.fetchall()]<br></code></pre></td></tr></table></figure><h1 id="验证-amp-性能测试"><a href="#验证-amp-性能测试" class="headerlink" title="验证&amp;性能测试"></a>验证&amp;性能测试</h1><p>用<code>5678e</code>这个前缀来验证四种查询方法的正确性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;5678e37b-6e7c-4760-89aa-1dc4c2b547c5&#x27;</span>, <span class="hljs-string">&#x27;5678e967-4d5d-4e26-8ed1-bd8819b5b62c&#x27;</span>]<br>traverse(<span class="hljs-string">&#x27;5678e&#x27;</span>): <span class="hljs-number">0.108424</span>s<br>[<span class="hljs-string">&#x27;5678e37b-6e7c-4760-89aa-1dc4c2b547c5&#x27;</span>, <span class="hljs-string">&#x27;5678e967-4d5d-4e26-8ed1-bd8819b5b62c&#x27;</span>]<br>bin_search(<span class="hljs-string">&#x27;5678e&#x27;</span>): <span class="hljs-number">0.000020</span>s<br>[<span class="hljs-string">&#x27;5678e37b-6e7c-4760-89aa-1dc4c2b547c5&#x27;</span>, <span class="hljs-string">&#x27;5678e967-4d5d-4e26-8ed1-bd8819b5b62c&#x27;</span>]<br>redis_zset(<span class="hljs-string">&#x27;5678e&#x27;</span>): <span class="hljs-number">0.002244</span>s<br>[<span class="hljs-string">&#x27;5678e37b-6e7c-4760-89aa-1dc4c2b547c5&#x27;</span>, <span class="hljs-string">&#x27;5678e967-4d5d-4e26-8ed1-bd8819b5b62c&#x27;</span>]<br>mysql_like(<span class="hljs-string">&#x27;5678e&#x27;</span>): <span class="hljs-number">0.000773</span>s<br></code></pre></td></tr></table></figure><p>从耗时来看，<code>O(n)</code>的遍历查询妥妥垫底，<code>O(log n)</code>的二分查询秒杀全场，MariaDB的查询速度则远远甩开了Redis。当然，单次特定条件查询不能说明什么问题，下面来看看10000次随机前缀（长度为1~8的随机字符串）匹配查询所需要的时间：</p><p><img src="/images/2020/06/13/compare.png"></p><ul><li><p>不出所料，二分查询的速度是最快的，毕竟是在内存中以<code>O(log n)</code>的时间复杂度来查找数据。</p></li><li><p>MariaDB查找的速度比二分查找的速度慢上十倍，但性能依然出乎我的意料。InnoDB的B+树索引无疑是最大功臣，定位到特定前缀的首个UUID只需要<code>O(log n)</code>的时间复杂度，之后就只需要顺序读取数据。同时，100万个UUID的索引小到可以全部放入内存，这进一步提高了性能。</p></li><li><p>Redis这个以快著称的KV数据库反而最慢，但仔细想想也无可厚非。为了进行一次查询，我们需要执行如下操作：<code>ZADD</code>添加边界元素、<code>ZRANK</code>确定位置、<code>ZRANGE</code>提取结果、<code>ZREM</code>移除边界元素。而这些操作的时间复杂度都达到甚至超过了<code>O(log n)</code>，速度当然快不起来。只能说《Redis实战》这本书提供了这样一个思路，但在具体实现上还是要更慎重。</p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>读完文章后可能会有读者大呼上当：100万的数据集也太小了吧？数据的插入和删除怎么解决？前缀树呢？好吧，这篇文章确实没有回答这些问题。直接在内存中进行二分查询性能确实非常好，但插入和删除数据的时间复杂度来到了<code>O(n)</code>，同时也对超过内存容量限制的数据集无能为力。但是我觉得，前者可以通过分离数据的修改和查询解决（在数据库中修改，缓存到内存后查询），后者可以通过水平扩展解决（每个进程&#x2F;机器缓存部分数据集），同时笔者水平有限，所以没有回答更深入的问题。</p><p>文章最后，衷心感谢黄健宏老师的著作《Redis设计与实现》和译作《Redis实战》。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>数据库</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Golang里实现一个高性能的TTLMap</title>
    <link href="/2020/05/24/%E5%A6%82%E4%BD%95%E5%9C%A8Golang%E9%87%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84TTLMap/"/>
    <url>/2020/05/24/%E5%A6%82%E4%BD%95%E5%9C%A8Golang%E9%87%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84TTLMap/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>TTLMap</code>是一个比较实用的数据结构，特别是在需要缓存数据的场景下。<code>TTLMap</code>的实现现不算复杂，但也有许多需要注意的地方，这也是这篇文章出现的原因。</p><p>在<code>TTLMap</code>里，移除失效的数据有三种策略：立即删除、惰性删除和定期删除策略。立即删除策略会在数据过期时立即将数据删除；惰性删除策略只在碰到过期键时才进行删除操作；定期删除策略则每隔一段时间，主动查找并删除过期键。第一种策略对CPU不友好，第二种策略容易造成内存泄露。<code>Redis</code>对设置了TTL的数据采取的是惰性删除和定期删除策略，而本篇文章会将重点放在性能上，所以只会采取定期删除策略。</p><blockquote><p>注：本篇文章使用<code>go1.13.5 linux/amd64</code></p></blockquote><h1 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h1><p>先来看看<code>TTLMap</code>的接口定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TTLMap <span class="hljs-keyword">interface</span> &#123;<br>Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>)<br>Set(key <span class="hljs-type">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;, ex time.Duration)<br>Len() <span class="hljs-type">int</span><br>clean(tick time.Duration)<br>&#125;<br><br><span class="hljs-keyword">type</span> item <span class="hljs-keyword">struct</span> &#123;<br>value  <span class="hljs-keyword">interface</span>&#123;&#125;<br>expire <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Get()</code>函数负责从<code>TTLMap</code>中获取数据，如数据不存在或已失效则第二个返回值为<code>false</code>，行为和内置的<code>map</code>保持一致。<code>Set()</code>函数负责将数据放入<code>TTLMap</code>，并接收一个<code>time.Duration</code>参数用来标示数据的生命周期。<code>Len()</code>函数返回<code>TTLMap</code>中数据的数量，不过为了性能考虑，一般不区分数据是否已经失效。<code>clean()</code>函数则负责实现上文提到的定期删除策略。</p><h1 id="初步实现（V0版本）"><a href="#初步实现（V0版本）" class="headerlink" title="初步实现（V0版本）"></a>初步实现（V0版本）</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TTLMapV0 <span class="hljs-keyword">struct</span> &#123;<br>items <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]item<br>mux   *sync.Mutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV0)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>) &#123;<br>tm.mux.Lock()<br><span class="hljs-keyword">defer</span> tm.mux.Unlock()<br><span class="hljs-keyword">if</span> item, ok := tm.items[key]; !ok || time.Now().UnixNano() &gt; item.expire &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> item.value, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV0)</span></span> Set(key <span class="hljs-type">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;, ex time.Duration) &#123;<br>tm.mux.Lock()<br>tm.items[key] = item&#123;value: val, expire: time.Now().Add(ex).UnixNano()&#125;<br>tm.mux.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV0)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>tm.mux.Lock()<br><span class="hljs-keyword">defer</span> tm.mux.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tm.items)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV0)</span></span> clean(tick time.Duration) &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> time.Tick(tick) &#123;<br>tm.mux.Lock()<br><span class="hljs-keyword">for</span> key, item := <span class="hljs-keyword">range</span> tm.items &#123;<br><span class="hljs-keyword">if</span> time.Now().UnixNano() &gt;= item.expire &#123;<br><span class="hljs-built_in">delete</span>(tm.items, key)<br>&#125;<br>&#125;<br>tm.mux.Unlock()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTTLMapV0</span><span class="hljs-params">(cleanTick time.Duration)</span></span> *TTLMapV0 &#123;<br>tm := &amp;TTLMapV0&#123;items: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]item&#123;&#125;, mux: <span class="hljs-built_in">new</span>(sync.Mutex)&#125;<br><span class="hljs-keyword">go</span> tm.clean(cleanTick)<br><span class="hljs-keyword">return</span> tm<br></code></pre></td></tr></table></figure><h1 id="防止内存泄露（V1版本）"><a href="#防止内存泄露（V1版本）" class="headerlink" title="防止内存泄露（V1版本）"></a>防止内存泄露（V1版本）</h1><p>上面的V0版本实现在功能上已经基本完整了，但由于<code>clean()</code>函数会一直运行，所以V0版本的<code>TTLMap</code>不会被Golang的垃圾回收机制回收，进而引起内存泄露。所以我们需要对V0版本做出一点改进，并将改进后的<code>TTLMap</code>包裹起来以启动自动回收机制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TTLMapV1 <span class="hljs-keyword">struct</span> &#123;<br>*TTLMapV0<br>stop <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV1)</span></span> clean(tick time.Duration) &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> time.Tick(tick) &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-tm.stop:<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>tm.mux.Lock()<br><span class="hljs-keyword">for</span> key, item := <span class="hljs-keyword">range</span> tm.items &#123;<br><span class="hljs-keyword">if</span> time.Now().UnixNano() &gt;= item.expire &#123;<br><span class="hljs-built_in">delete</span>(tm.items, key)<br>&#125;<br>&#125;<br>tm.mux.Unlock()<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> TTLMapWrapper <span class="hljs-keyword">struct</span> &#123;<br>TTLMap<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTTLMapV1</span><span class="hljs-params">(cleanTick time.Duration)</span></span> *TTLMapWrapper &#123;<br>tm0 := &amp;TTLMapV0&#123;items: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]item&#123;&#125;, mux: <span class="hljs-built_in">new</span>(sync.Mutex)&#125;<br>tm1 := &amp;TTLMapV1&#123;TTLMapV0: tm0, stop: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)&#125;<br><span class="hljs-keyword">go</span> tm1.clean(cleanTick)<br>tmw := &amp;TTLMapWrapper&#123;TTLMap: tm1&#125;<br>runtime.SetFinalizer(tmw, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123; tm1.stop &lt;- <span class="hljs-literal">true</span> &#125;)<br><span class="hljs-keyword">return</span> tmw<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="验证自动回收是否启用"><a href="#验证自动回收是否启用" class="headerlink" title="验证自动回收是否启用"></a>验证自动回收是否启用</h2><p>为了验证上文的改进是否有效，将代码改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV0)</span></span> clean(tick time.Duration) &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;v0.clean() stopped&quot;</span>)<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTTLMapV0</span><span class="hljs-params">(cleanTick time.Duration)</span></span> *TTLMapV0 &#123;<br><span class="hljs-comment">// ...</span><br>runtime.SetFinalizer(tm, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;v0 gone&quot;</span>) &#125;)<br><span class="hljs-keyword">return</span> tm<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV1)</span></span> clean(tick time.Duration) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;v1.clean() stopped&quot;</span>) &#125;()<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTTLMapV1</span><span class="hljs-params">(cleanTick time.Duration)</span></span> *TTLMapWrapper &#123;<br>    <span class="hljs-comment">// ...</span><br>runtime.SetFinalizer(tm1, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;v1 gone&quot;</span>) &#125;)<br>runtime.SetFinalizer(tm0, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;v1.v0 gone&quot;</span>) &#125;)<br><span class="hljs-keyword">return</span> tmw<br>&#125;<br></code></pre></td></tr></table></figure><p>然后编写测试代码并运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestTTLMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>NewTTLMapV0(time.Millisecond * <span class="hljs-number">100</span>)<br>NewTTLMapV1(time.Millisecond * <span class="hljs-number">100</span>)<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;--&gt; first gc&quot;</span>)<br>runtime.GC()<br>time.Sleep(time.Millisecond * <span class="hljs-number">200</span>)<br>fmt.Println(<span class="hljs-string">&quot;--&gt; second gc&quot;</span>)<br>runtime.GC()<br>fmt.Println(<span class="hljs-string">&quot;--&gt; third gc&quot;</span>)<br>runtime.GC()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> .</span><br>=== RUN   TestTTLMap<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">first gc</span><br>v1.clean() stopped<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">second gc</span><br>v1 gone<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">third gc</span><br>v1.v0 gone<br>--- PASS: TestTTLMap (0.20s)<br></code></pre></td></tr></table></figure><p>可以看到，改进后的代码确实生效了，未被引用的<code>TTLMap</code>（V1版本）会被自动回收，不会出现内存泄露。</p><blockquote><p>PS：在接下来的版本将省略<code>TTLMapWrapper</code>的实现部分</p></blockquote><h1 id="使用读写锁提高性能（V2版本）"><a href="#使用读写锁提高性能（V2版本）" class="headerlink" title="使用读写锁提高性能（V2版本）"></a>使用读写锁提高性能（V2版本）</h1><p>在之前的版本里，<code>TTLMap</code>使用的并发控制锁都是普通的<code>sync.Mutex</code>，也就是说同一时刻只能有一个<code>Goruntime</code>访问该对象。但<code>TTLMap</code>应用的场景大多是读多写少，所以我们可以使用读写锁，即<code>sync.RWMutex</code>来获得更好性能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TTLMapV2 <span class="hljs-keyword">struct</span> &#123;<br>items <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]item<br>mux   *sync.RWMutex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV2)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>) &#123;<br>tm.mux.RLock()<br><span class="hljs-keyword">defer</span> tm.mux.RUnlock()<br><span class="hljs-keyword">if</span> item, ok := tm.items[key]; !ok || time.Now().UnixNano() &gt; item.expire &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> item.value, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV2)</span></span> Set(key <span class="hljs-type">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;, ex time.Duration) &#123;<br><span class="hljs-comment">// ... 同V0版本</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV2)</span></span> clean(tick time.Duration) &#123;<br><span class="hljs-comment">// ... 同V0版本</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV2)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>tm.mux.RLock()<br><span class="hljs-keyword">defer</span> tm.mux.RUnlock()<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(tm.items)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTTLMapV2</span><span class="hljs-params">(cleanTick time.Duration)</span></span> *TTLMapV2 &#123;<br>tm := &amp;TTLMapV2&#123;<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]item&#123;&#125;, <span class="hljs-built_in">new</span>(sync.RWMutex)&#125;<br><span class="hljs-keyword">go</span> tm.clean(cleanTick)<br><span class="hljs-keyword">return</span> tm<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用不精确的时间提高性能（V3版本）"><a href="#使用不精确的时间提高性能（V3版本）" class="headerlink" title="使用不精确的时间提高性能（V3版本）"></a>使用不精确的时间提高性能（V3版本）</h1><p>在之前的版本里，每次调用<code>Get()</code>和<code>Set()</code>函数时都会调用<code>time.Now()</code>以获取精确时间。但在对时间的精确度要求不那么高的场合下，可以缓存<code>time.Now()</code>的结果来获得更好的性能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TTLMapV3 <span class="hljs-keyword">struct</span> &#123;<br>items <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]item<br>mux   *sync.RWMutex<br>now   <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV3)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">bool</span>) &#123;<br>tm.mux.RLock()<br><span class="hljs-keyword">defer</span> tm.mux.RUnlock()<br><span class="hljs-keyword">if</span> item, ok := tm.items[key]; !ok || tm.now &gt; item.expire &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> item.value, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV3)</span></span> Set(key <span class="hljs-type">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;, ex time.Duration) &#123;<br>tm.mux.Lock()<br>tm.items[key] = item&#123;value: val, expire: tm.now + ex.Nanoseconds()&#125;<br>tm.mux.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV3)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// ... 同V2版本</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV3)</span></span> clean(tick time.Duration) &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> time.Tick(tick) &#123;<br>tm.mux.Lock()<br><span class="hljs-keyword">for</span> key, item := <span class="hljs-keyword">range</span> tm.items &#123;<br><span class="hljs-keyword">if</span> tm.now &gt;= item.expire &#123;<br><span class="hljs-built_in">delete</span>(tm.items, key)<br>&#125;<br>&#125;<br>tm.mux.Unlock()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tm *TTLMapV3)</span></span> updateNow(tick time.Duration) &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> time.Tick(tick) &#123;<br>tm.mux.Lock()<br>tm.now = time.Now().UnixNano()<br>tm.mux.Unlock()<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTTLMapV3</span><span class="hljs-params">(cleanTick time.Duration)</span></span> *TTLMapV3 &#123;<br>tm := &amp;TTLMapV3&#123;<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]item&#123;&#125;,<br><span class="hljs-built_in">new</span>(sync.RWMutex), time.Now().UnixNano()&#125;<br><span class="hljs-keyword">go</span> tm.clean(cleanTick)<br><span class="hljs-keyword">go</span> tm.updateNow(time.Second)<br><span class="hljs-keyword">return</span> tm<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="性能测试-amp-结语"><a href="#性能测试-amp-结语" class="headerlink" title="性能测试&amp;结语"></a>性能测试&amp;结语</h1><p>编写测试代码用于测试以上版本的性能并运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkTTLMap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>rand.Seed(time.Now().UnixNano())<br>key := RandStringBytesRmndr(<span class="hljs-number">20</span>)<br>tasks := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>ttl  TTLMap<br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;TTLMapV0&quot;</span>, NewTTLMapV0(time.Minute)&#125;,<br>&#123;<span class="hljs-string">&quot;TTLMapV2&quot;</span>, NewTTLMapV2(time.Minute)&#125;,<br>&#123;<span class="hljs-string">&quot;TTLMapV3&quot;</span>, NewTTLMapV3(time.Minute)&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, task := <span class="hljs-keyword">range</span> tasks &#123;<br>b.Run(task.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sb *testing.B)</span></span> &#123;<br>sb.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br>task.ttl.Set(key, key, time.Minute)<br>task.ttl.Get(key)<br>&#125;<br>&#125;)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -bench .</span>  <br>goos: linux<br>goarch: amd64<br>BenchmarkTTLMap/TTLMapV0-8               3972699               301 ns/op<br>BenchmarkTTLMap/TTLMapV2-8               4972598               241 ns/op<br>BenchmarkTTLMap/TTLMapV3-8               9125235               132 ns/op<br>PASS<br></code></pre></td></tr></table></figure><p>可以看出，V2相比V0性能提升了20%左右，而V3相比V0的性能提升幅度更是超过了56%。而从PPROF的分析结果来看，剩下的时间主要消耗在互斥锁上，应该很难有进一步优化的空间了。</p><p><img src="/images/2020/05/24/pprof.webp"></p><p>虽然理论上来说用<code>int</code>当<code>Map</code>的键而不是<code>string</code>时会有更好的性能表现，但是从实际测试来看，对于长度为20的<code>string</code>，<code>fnv32</code>等哈希算法的开销还是超过了其能带来的收益，更别提还要考虑潜在的哈希冲突。</p><p>最后要重申一点的是，V2和V3版本的实现省略了V1中提到的<code>TTLMapWrapper</code>部分，所以请不要直接使用V2和V3版本的代码😂</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://github.com/golang/go/issues/19780">proposal: a faster, better fnv32 implementation #19780</a></li><li><a href="https://my.oschina.net/solate/blog/3034188">go benchmark 性能测试</a></li><li><a href="https://zhuanlan.zhihu.com/p/76504936">使用runtime.SetFinalizer优雅关闭后台goroutine</a></li><li><a href="http://redisbook.com/preview/database/review.html">重点回顾-Redis设计与实现</a></li><li><a href="https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go">How to generate a random string of a fixed length in Go?</a></li><li><a href="https://medium.com/justforfunc/analyzing-the-performance-of-go-functions-with-benchmarks-60b8162e61c6">Analyzing the performance of Go functions with benchmarks</a></li><li><a href="https://stackimpact.com/blog/practical-golang-benchmarks/#map-access">Practical Go Benchmarks</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django多数据库历险记（番外）</title>
    <link href="/2020/05/02/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/05/02/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>这篇文章基于前两篇文章<a href="/2020/04/23/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">Django多数据库历险记（一）</a>、<a href="/2020/04/25/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89">Django多数据库历险记（二）</a>，将继续讲述关于Django多数据库的历险记。<br>好吧其实这篇文章的内容已经和Django多数据库没有太大关系了……只是为了和前两篇文章的命名保持一致才取了这个标题。</p><h1 id="秘技：避免物理外键约束"><a href="#秘技：避免物理外键约束" class="headerlink" title="秘技：避免物理外键约束"></a>秘技：避免物理外键约束</h1><p><a href="https://docs.djangoproject.com/en/2.2/ref/models/fields/#django.db.models.ForeignKey.db_constraint"><img src="/images/2020/05/02/document.webp" alt="document.webp"></a></p><p>对于数据库层面的物理外键，国内互联网上的声音普遍一致，那就是不推荐使用（比如这个<a href="https://www.zhihu.com/question/39062169">知乎问题</a>），公司的DBA也持这个态度。既然如此，就应该想办法在执行<code>Migrate</code>操作时避免产生物理外键了。<br>幸运的时，从很早开始（不晚于<code>Django1.8</code>）Django就提供了直接的手段来避免产生物理外键：<code>db_constraint</code>属性。从Django DB模块的源码（<a href="https://github.com/django/django/blob/2.2.12/django/db/backends/base/schema.py">schema.py</a>）中可以看出，Django在创建Model、添加&#x2F;修改Field时都会通过<code>db_constraint</code>属性的值来决定是否加入物理外键约束。实验一下（省略内容见<a href="/2020/04/23/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">上一篇文章</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app_1/models.py</span><br><span class="hljs-comment"># ... 略</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildModel1</span>(models.Model):<br>    name = models.CharField(max_length=<span class="hljs-number">255</span>)<br>    parent1 = models.ForeignKey(<span class="hljs-string">&quot;Model1&quot;</span>, on_delete=models.CASCADE, db_constraint=<span class="hljs-literal">False</span>)<br>    parent2 = models.ForeignKey(<span class="hljs-string">&quot;app_2.Model2&quot;</span>, on_delete=models.CASCADE, db_constraint=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py makemigrations</span><br>Migrations for &#x27;app_1&#x27;:<br>  app_1/migrations/0002_childmodel1.py<br>    - Create model ChildModel1<br><span class="hljs-meta prompt_">$</span><span class="language-bash"></span><br><span class="language-bash">$ python manage.py migrate app_1 --database db_1</span><br>Operations to perform:<br>  Apply all migrations: app_1<br>Running migrations:<br>  Applying app_2.0001_initial... OK<br>  Applying app_1.0002_childmodel1... OK<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql">mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> django_migrations<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------------------+----------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> app   <span class="hljs-operator">|</span> name             <span class="hljs-operator">|</span> applied                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------------------+----------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1</span>  <span class="hljs-operator">|</span> app_1 <span class="hljs-operator">|</span> <span class="hljs-number">0001</span>_initial     <span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-operator">-</span>xx<span class="hljs-operator">-</span>xx xx:xx:xx.xxxxxx <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3</span>  <span class="hljs-operator">|</span> app_2 <span class="hljs-operator">|</span> <span class="hljs-number">0001</span>_initial     <span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-operator">-</span>xx<span class="hljs-operator">-</span>xx xx:xx:xx.xxxxxx <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3</span>  <span class="hljs-operator">|</span> app_1 <span class="hljs-operator">|</span> <span class="hljs-number">0002</span>_childmodel1 <span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-operator">-</span>xx<span class="hljs-operator">-</span>xx xx:xx:xx.xxxxxx <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------------------+----------------------------+</span><br>mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> tables<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> Tables_in_db_1    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> app_1_childmodel1 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> app_1_model1      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> django_migrations <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br>mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> app_1_model1<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `app_1_childmodel1` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `parent1_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `parent2_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `app_1_childmodel1_parent1_id_8dfbb0b1` (`parent1_id`),<br>  KEY `app_1_childmodel1_parent2_id_db0fdb2e` (`parent2_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci<br></code></pre></td></tr></table></figure><h1 id="秘技：migrations转SQL语句"><a href="#秘技：migrations转SQL语句" class="headerlink" title="秘技：migrations转SQL语句"></a>秘技：<code>migrations</code>转SQL语句</h1><p><a href="https://docs.djangoproject.com/en/2.2/ref/django-admin/#django-admin-sqlmigrate"><img src="/images/2020/05/02/sqlmigrate.webp" alt="sqlmigrate.webp"></a></p><p>在某些特殊场景下（比如处于安全考量），Django自带的<code>migrate</code>命令可能不被允许运行。如果此时还想使用Django的数据迁移功能，则可以使用<code>sqlmigrate</code>命令来将创建好的迁移方案转换为SQL语句。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py sqlmigrate app_1 0001_initial --database db_1</span><br>BEGIN;<br>--<br>-- Create model Model1<br>--<br>CREATE TABLE `app_1_model1` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `name` varchar(255) NOT NULL);<br>COMMIT;<br></code></pre></td></tr></table></figure><p>不过这个命令并一次只能转换一条迁移方案，所以我们可以参考魔改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># my_sqlmigrate.py</span><br><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> django<br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.core.management <span class="hljs-keyword">import</span> execute_from_command_line, CommandParser<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> DEFAULT_DB_ALIAS<br><span class="hljs-keyword">from</span> django.db.migrations.loader <span class="hljs-keyword">import</span> MigrationLoader<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;multi_db.settings&#x27;</span>)<br>django.setup()<br><br>parser = CommandParser()<br>parser.add_argument(<br>    <span class="hljs-string">&#x27;app_label&#x27;</span>, nargs=<span class="hljs-string">&#x27;?&#x27;</span>,<br>    <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;App label of an application to synchronize the state.&#x27;</span>,<br>)<br>app_label = parser.parse_args().app_label<br><br>loader = MigrationLoader(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 获取所有migration</span><br>db = settings.DB_ROUTING.get(app_label, DEFAULT_DB_ALIAS)<br><span class="hljs-comment"># 遍历app下所有migration</span><br>migrations = <span class="hljs-built_in">sorted</span>(name <span class="hljs-keyword">for</span> app, name <span class="hljs-keyword">in</span> loader.disk_migrations <span class="hljs-keyword">if</span> app == app_label)<br><span class="hljs-keyword">for</span> migration <span class="hljs-keyword">in</span> migrations:<br>    argv = [<span class="hljs-string">&quot;manage.py&quot;</span>, <span class="hljs-string">&quot;sqlmigrate&quot;</span>, <span class="hljs-string">&quot;--database&quot;</span>, db, app_label, migration]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n-- python &quot;</span> + <span class="hljs-string">&quot; &quot;</span>.join(argv))<br>    execute_from_command_line(argv)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-- my_sqlmigrate complete&quot;</span>)<br></code></pre></td></tr></table></figure><p>现在可以一次性转换所有迁移方案了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python my_sqlmigrate.py app_1</span><br><br>-- python manage.py sqlmigrate --database db_1 app_1 0001_initial<br>BEGIN;<br>--<br>-- Create model Model1<br>--<br>CREATE TABLE `app_1_model1` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `name` varchar(255) NOT NULL);<br>COMMIT;<br><br>-- python manage.py sqlmigrate --database db_1 app_1 0002_childmodel1<br>BEGIN;<br>--<br>-- Create model ChildModel1<br>--<br>CREATE TABLE `app_1_childmodel1` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `name` varchar(255) NOT NULL, `parent1_id` integer NOT NULL, `parent2_id` integer NOT NULL);<br>CREATE INDEX `app_1_childmodel1_parent1_id_8dfbb0b1` ON `app_1_childmodel1` (`parent1_id`);<br>CREATE INDEX `app_1_childmodel1_parent2_id_db0fdb2e` ON `app_1_childmodel1` (`parent2_id`);<br>COMMIT;<br>-- my_sqlmigrate complete<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章的实用性可能谈不上有多高，只能说聊以自慰。虽然我在第一篇文章的开头说<code>对多数据库的支持……坑无处不在</code>，但在深入了解之后，我还是被Django完善的架构给折服了：不愧是最优秀的Python Web框架，我还是too young, too simple。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
      <tag>多数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django多数据库历险记（二）</title>
    <link href="/2020/04/25/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/04/25/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>这篇文章基于上一篇文章<a href="/2020/04/23/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">Django多数据库历险记（一）</a>，将继续讲述关于Django多数据库的历险记。</p><p>在上一篇文章中，我创建了一个Django项目：<code>multi_db</code>，在这个项目里指定了两个app：<code>app_1</code>和<code>app_2</code>，每个app下各自创建了一个<code>Model</code>：<code>Model1</code>和<code>Model2</code>，并为这两个app各自分配了独立的数据库<code>db_1</code>和<code>db_2</code>。历险继续～</p><h1 id="第三关：TestCase"><a href="#第三关：TestCase" class="headerlink" title="第三关：TestCase"></a>第三关：TestCase</h1><p>在<code>multi_db</code>这个Django项目能够运行起来之后，下一步让我们来运行一些TestCase（对，即使这个项目里一个视图函数都还没有，<del>毕竟是TDD😂</del>）。编辑TestCase文件并运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># tests/test_multi_db.py</span><br><span class="hljs-keyword">from</span> django.test <span class="hljs-keyword">import</span> TestCase<br><br><span class="hljs-keyword">from</span> app_1.models <span class="hljs-keyword">import</span> Model1<br><span class="hljs-keyword">from</span> app_2.models <span class="hljs-keyword">import</span> Model2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDB1</span>(<span class="hljs-title class_ inherited__">TestCase</span>):<br>    databases = [<span class="hljs-string">&quot;db_1&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_query</span>(<span class="hljs-params">self</span>):<br>        count = Model1.objects.count()<br>        self.assertEqual(count, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDB2</span>(<span class="hljs-title class_ inherited__">TestCase</span>):<br>    databases = [<span class="hljs-string">&quot;db_2&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_query</span>(<span class="hljs-params">self</span>):<br>        count = Model2.objects.count()<br>        self.assertEqual(count, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">time python manage.py <span class="hljs-built_in">test</span> tests/</span><br>Creating test database for alias &#x27;db_1&#x27;...<br>Creating test database for alias &#x27;db_2&#x27;...<br>System check identified no issues (0 silenced).<br>..<br>----------------------------------------------------------------------<br>Ran 2 tests in 0.006s<br><br>OK<br>Destroying test database for alias &#x27;db_1&#x27;...<br>Destroying test database for alias &#x27;db_2&#x27;...<br>python manage.py test tests/  1.02s user 0.04s system 14% cpu 7.288 total<br></code></pre></td></tr></table></figure><p>很好，两个TestCase都测试通过（毕竟没有比这更简单的TestCase了）。一切都看起来非常美好，除了这惊人的命令耗时：为什么创建&amp;销毁两个测试数据库会消耗7秒以上的时间！如果你看过上一篇文章，那么你可能已经隐约猜到原因了。没错，幕后黑手还是<code>migrate</code>命令。</p><p>从Django测试模块源码（<a href="https://github.com/django/django/blob/2.2.12/django/test/runner.py#L614">runner.py#L614</a>）中可以看出，对于TestCase里所有的<code>databases</code>（比如上面的<code>db_1</code>、<code>db_2</code>），Django都会创建对应的测试数据库（<code>test_db_1</code>、<code>test_db_2</code>），并为每个测试数据库执行一次<code>migrate</code>命令（<a href="https://github.com/django/django/blob/2.2.12/django/db/backends/base/creation.py#L67">creation.py#L67</a>）。在上一篇文章中，我们就已经知道<code>migrate</code>命令会一股脑地将所有迁移方案都应用到数据库，这里也不例外。用<code>test</code>命令的<code>--keepdb</code>选项验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py <span class="hljs-built_in">test</span> tests/ --keepdb</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">... 略</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:test_db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> tables<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+</span><br><span class="hljs-operator">|</span> Tables_in_test_db_1        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+</span><br><span class="hljs-operator">|</span> app_1_model1               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> app_2_model2               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> auth_group                 <span class="hljs-operator">|</span><br># ... 略<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:test_db_2<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> tables<br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+</span><br><span class="hljs-operator">|</span> Tables_in_test_db_2        <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------------------------+</span><br><span class="hljs-operator">|</span> app_1_model1               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> app_2_model2               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> auth_group                 <span class="hljs-operator">|</span><br># ... 略<br></code></pre></td></tr></table></figure><p>那么，有没有办法在对<code>db_1</code>进行测试时，只在<code>test_db_1</code>这个测试数据库上创建只属于<code>app_1</code>的<code>Model</code>呢？答案是肯定的。</p><h2 id="allow-migrate"><a href="#allow-migrate" class="headerlink" title="allow_migrate"></a>allow_migrate</h2><p>在上一篇文章的<code>DBRouter</code>数据库路由类中，我将<code>allow_migrate()</code>方法的返回值固定为<code>True</code>，意味着Django可以在任何数据库上、对任何app进行数据库迁移。这当然是一种有点不负责任的做法，所以，只要严格限制在<code>db_1</code>上只能进行<code>app_1</code>的迁移、在<code>db_2</code>上只能进行<code>app_2</code>的迁移，就可以达成我上文提到的需求了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-comment"># multi_db/db_routers.py</span><br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> DEFAULT_DB_ALIAS<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBRouter</span>:<br>    <span class="hljs-comment"># ... 略</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">allow_migrate</span>(<span class="hljs-params">self, db, app_label, model_name=<span class="hljs-literal">None</span>, **hints</span>):<br>        <span class="hljs-keyword">return</span> db == settings.DB_ROUTING.get(app_label, DEFAULT_DB_ALIAS)<br></code></pre></td></tr></table></figure><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>再次执行<code>test</code>命令，可以很明显地感受到效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">time python manage.py <span class="hljs-built_in">test</span> tests/</span><br>Creating test database for alias &#x27;db_1&#x27;...<br>Creating test database for alias &#x27;db_2&#x27;...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">... 略</span><br>python manage.py test tests/  0.74s user 0.02s system 57% cpu 1.320 total<br></code></pre></td></tr></table></figure><p>总耗时由7秒下降至1秒。再用<code>--keepdb</code>选项验证一下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mariadb root@127.0.0.1:test_db_1&gt; show tables                                   </span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">| Tables_in_test_db_1 |</span><br><span class="hljs-section">+---------------------+</span><br>| app<span class="hljs-emphasis">_1_model1        |</span><br><span class="hljs-emphasis">| django_</span>migrations   |<br><span class="hljs-code">+---------------------+</span><br></code></pre></td></tr></table></figure><p>完美。</p><h1 id="第四关：跨库外键约束"><a href="#第四关：跨库外键约束" class="headerlink" title="第四关：跨库外键约束"></a>第四关：跨库外键约束</h1><p><img src="/images/2020/04/27/document.webp" alt="document.webp"></p><p>必须要说的是，Django（至少在文档里）并不支持跨数据库的外键约束。当然，这里指的是物理约束，即数据库层面的<code>CONSTRAINT</code>字段约束。但在实际业务中，由Django管理的、逻辑上的跨库外键约束却并不少见，这给程序员带来了巨大的便利——但代价是什么呢？代价往往是抛弃Django的数据迁移机制。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在<code>app_1</code>里创建一个新Model（省略内容见<a href="/2020/04/23/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">上一篇文章</a>），并生成对应迁移方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app_1/models.py</span><br><span class="hljs-comment"># ... 略</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildModel1</span>(models.Model):<br>    name = models.CharField(max_length=<span class="hljs-number">255</span>)<br>    parent1 = models.ForeignKey(<span class="hljs-string">&quot;Model1&quot;</span>, on_delete=models.CASCADE)<br>    parent2 = models.ForeignKey(<span class="hljs-string">&quot;app_2.Model2&quot;</span>, on_delete=models.CASCADE)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py makemigrations</span>               <br>Migrations for &#x27;app_1&#x27;:<br>  app_1/migrations/0002_childmodel1.py<br>    - Create model ChildModel1<br></code></pre></td></tr></table></figure><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate app_1 --database db_1</span><br>Operations to perform:<br>  Apply all migrations: app_1<br>Running migrations:<br>  Applying app_2.0001_initial... OK<br>  Applying app_1.0002_childmodel1...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">... 略</span><br>django.db.utils.OperationalError: (1005, &#x27;Can\&#x27;t create table `db_1`.`app_1_childmodel1` (errno: 150 &quot;Foreign key constraint is incorrectly formed&quot;)&#x27;)<br></code></pre></td></tr></table></figure><p>果不其然，报错了。Django想要在<code>db_1</code>上应用<code>app_2</code>的迁移方案<code>0001_initial</code>来为<code>ChildModel1</code>的迁移铺路，但在上一关的<code>allow_migrate()</code>中我已经严格限制了数据库和app的对应关系，所以实际上<code>app_2.0001_initial</code>被跳过了（虽然还是在迁移进度里留下了成功标记）。</p><p>于是到了物理约束部分，Django想要在<code>db1</code>上创建从<code>ChildModel1</code>到<code>Model2</code>的<code>CONSTRAINT</code>约束就不可能成功：因为<code>app_2.0001_inital</code>这个前提并没有实际应用。打开数据库验证一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql">mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> tables                                        <br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> Tables_in_db_1    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> app_1_childmodel1 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> app_1_model1      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> django_migrations <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br>mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> django_migrations<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------------------+----------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> app   <span class="hljs-operator">|</span> name             <span class="hljs-operator">|</span> applied                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------------------+----------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1</span>  <span class="hljs-operator">|</span> app_1 <span class="hljs-operator">|</span> <span class="hljs-number">0001</span>_initial     <span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-number">-04</span><span class="hljs-number">-27</span> xx:xx:xx.xxxxxx <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">2</span>  <span class="hljs-operator">|</span> app_2 <span class="hljs-operator">|</span> <span class="hljs-number">0001</span>_initial     <span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-number">-04</span><span class="hljs-number">-27</span> xx:xx:xx.xxxxxx <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">3</span>  <span class="hljs-operator">|</span> app_1 <span class="hljs-operator">|</span> <span class="hljs-number">0002</span>_childmodel1 <span class="hljs-operator">|</span> <span class="hljs-number">2020</span><span class="hljs-number">-04</span><span class="hljs-number">-27</span> xx:xx:xx.xxxxxx <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------+------------------+----------------------------+</span><br>mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> app_1_childmodel1<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `app_1_childmodel1` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `parent1_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `parent2_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `xxx` (`parent1_id`),<br>  <span class="hljs-keyword">CONSTRAINT</span> `xxx` <span class="hljs-keyword">FOREIGN</span> KEY (`parent1_id`) <span class="hljs-keyword">REFERENCES</span> `app_1_model1` (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci<br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>当然，即使Django在应用迁移方案的时候报错了，但缺失的只有一个数据库层面的约束字段，并不影响逻辑层面的外键约束。所以，我们可以直接在Django里使用这个Model了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app_1/views.py</span><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> JsonResponse<br><br><span class="hljs-keyword">from</span> app_1.models <span class="hljs-keyword">import</span> ChildModel1, Model1<br><span class="hljs-keyword">from</span> app_2.models <span class="hljs-keyword">import</span> Model2<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">request</span>):<br>    child = ChildModel1.objects.create(<br>        name=<span class="hljs-string">&quot;carl&quot;</span>, parent1=Model1.objects.create(name=<span class="hljs-string">&quot;alice&quot;</span>),<br>        parent2=Model2.objects.create(name=<span class="hljs-string">&quot;bob&quot;</span>),<br>    )<br>    <span class="hljs-keyword">return</span> JsonResponse(&#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: child.name, <span class="hljs-string">&quot;parent1&quot;</span>: child.parent1.name,<br>        <span class="hljs-string">&quot;parent2&quot;</span>: child.parent2.name<br>    &#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># multi_db/urls.py</span><br><span class="hljs-comment"># ... 略</span><br><span class="hljs-keyword">from</span> app_1.views <span class="hljs-keyword">import</span> test<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, test)<br>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py runserver 8000</span><br>Performing system checks...<br><br>Watching for file changes with StatReloader<br>System check identified no issues (0 silenced).<br>April 27, 2020 - xx:xx:xx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新termial</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:8000</span><br>&#123;&quot;name&quot;: &quot;carl&quot;, &quot;parent1&quot;: &quot;alice&quot;, &quot;parent2&quot;: &quot;bob&quot;&#125;<br></code></pre></td></tr></table></figure><h2 id="TestCase"><a href="#TestCase" class="headerlink" title="TestCase"></a>TestCase</h2><p>在上一节中可以这样蒙混过关，是因为<code>migrate</code>命令的失败并不会影响<code>runserver</code>命令的执行，但在TestCase里这样就行不通了。在第三关中提到，Django在进行TestCase前会对测试数据库执行<code>migrate</code>命令，而<code>migrate</code>的失败会导致TestCase直接结束。</p><p>解决方案主要有取消<code>allow_migrate()</code>对app&amp;数据库对应关系的限制、在运行TestCase时使用sqlite3（默认禁用外键约束）作为测试数据库。但这些都不能从根本上解决问题，这也就是为什么我在本关开头提到，跨库外键的代价往往是抛弃Django的数据迁移机制。</p><p>要想从根本上解决这个问题，就只有避免出现物理上的外键约束，只由Django进行逻辑上的外键约束管理。这个话题，就留到下篇文章再讲吧。（我怎么感觉我要被打了……）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
      <tag>多数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django多数据库历险记（一）</title>
    <link href="/2020/04/23/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/04/23/Django%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>毫无疑问，Django是最优秀的Python Web框架之一，然而其对多数据库的支持却让我内心十分复杂。在数据库迁移、跨库外键、单元测试等方面，坑无处不在。于是就有了这篇文章，关于Django多数据库的历险记。</p><blockquote><p>注：本篇文章使用<code>Python 3.6</code>+<code>Django 2.2</code></p></blockquote><h1 id="准备出发"><a href="#准备出发" class="headerlink" title="准备出发"></a>准备出发</h1><ol><li><p>创建Django项目<code>multi_db</code>和两个app：<code>app_1</code>和<code>app_2</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">django-admin startproject multi_db</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> multi_db/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py startapp app_1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py startapp app_2</span><br></code></pre></td></tr></table></figure></li><li><p>在<code>app_1</code>和<code>app_2</code>里分别添加各自的<code>Model</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app_1/models.py</span><br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model1</span>(models.Model):<br>    name = models.CharField(max_length=<span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        app_label = <span class="hljs-string">&quot;app_1&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># app_2/models.py</span><br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model2</span>(models.Model):<br>    name = models.CharField(max_length=<span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        app_label = <span class="hljs-string">&quot;app_2&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>为两个app指定不同的数据库并为其编写路由文件（省略部分内容）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># multi_db/settings.py</span><br><span class="hljs-comment"># ...</span><br>INSTALLED_APPS = [<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-string">&#x27;app_1&#x27;</span>,<br>    <span class="hljs-string">&#x27;app_2&#x27;</span>,<br>]<br><span class="hljs-comment"># ...</span><br>DATABASES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.sqlite3&#x27;</span>,<br>        <span class="hljs-string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="hljs-string">&#x27;db.sqlite3&#x27;</span>),<br>    &#125;,<br>    <span class="hljs-string">&#x27;db_1&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>, <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;db_1&#x27;</span>,<br>        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-string">&#x27;6603&#x27;</span>, <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;CHARSET&#x27;</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-string">&#x27;TEST&#x27;</span>: &#123;<span class="hljs-string">&#x27;DEPENDENCIES&#x27;</span>: []&#125;,<br>    &#125;,<br>    <span class="hljs-string">&#x27;db_2&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>, <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;db_2&#x27;</span>,<br>        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-string">&#x27;6603&#x27;</span>, <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-string">&#x27;CHARSET&#x27;</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-string">&#x27;TEST&#x27;</span>: &#123;<span class="hljs-string">&#x27;DEPENDENCIES&#x27;</span>: []&#125;,<br>    &#125;,<br>&#125;<br>DB_ROUTING = &#123;<span class="hljs-string">&#x27;app_1&#x27;</span>: <span class="hljs-string">&#x27;db_1&#x27;</span>, <span class="hljs-string">&#x27;app_2&#x27;</span>: <span class="hljs-string">&#x27;db_2&#x27;</span>&#125;<br>DATABASE_ROUTERS = [<span class="hljs-string">&#x27;multi_db.db_routers.DBRouter&#x27;</span>]<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># multi_db/db_routers.py</span><br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBRouter</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">db_for_read</span>(<span class="hljs-params">self, model, **hints</span>):<br>        <span class="hljs-keyword">return</span> settings.DB_ROUTING.get(model._meta.app_label)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">db_for_write</span>(<span class="hljs-params">self, model, **hints</span>):<br>        <span class="hljs-keyword">return</span> settings.DB_ROUTING.get(model._meta.app_label)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">allow_relation</span>(<span class="hljs-params">self, obj1, obj2, **hints</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">allow_migrate</span>(<span class="hljs-params">self, db, app_label, model_name=<span class="hljs-literal">None</span>, **hints</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="第一关：数据迁移"><a href="#第一关：数据迁移" class="headerlink" title="第一关：数据迁移"></a>第一关：数据迁移</h1><p>Django里数据库迁移分两部分，<code>makemigrations</code>和<code>migrate</code>。前者负责在Model出现变动时生成迁移方案文件，后者则负责在数据库中应用前者的迁移方案。于是，麻烦来了。</p><h2 id="makemigrations"><a href="#makemigrations" class="headerlink" title="makemigrations"></a>makemigrations</h2><p><code>makemigrations</code>命令不涉及数据库操作，所以用起来比较简单。使用时可以指定app以检测部分Model，也可以不指定app以检测全部Model。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py makemigrations</span><br>Migrations for &#x27;app_1&#x27;:<br>  app_1/migrations/0001_initial.py<br>    - Create model Model1<br>Migrations for &#x27;app_2&#x27;:<br>  app_2/migrations/0001_initial.py<br>    - Create model Model2<br></code></pre></td></tr></table></figure><p>OK，两个app的迁移方案文件就生成好了。Django内置的一些app（比如<code>django.contrib.auth</code>）已经<a href="https://github.com/django/django/blob/2.2.12/django/contrib/auth/migrations">自带迁移方案</a>，所以这里没有生成迁移方案文件。</p><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><p><code>migrate</code>命令和<code>makemigrations</code>一样，可以指定app。这里我们不指定app，直接应用所有迁移方案。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">multi_db python manage.py migrate</span><br>Operations to perform:<br>  Apply all migrations: admin, app_1, app_2, auth, contenttypes, sessions<br>Running migrations:<br>  Applying contenttypes.0001_initial... OK<br>  Applying auth.0001_initial... OK<br>  Applying admin.0001_initial... OK<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br>  Applying app_1.0001_initial... OK<br>  Applying app_2.0001_initial... OK<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br>  Applying sessions.0001_initial... OK<br></code></pre></td></tr></table></figure><p>很好，包括内置app、自定义app的所有迁移方案全部完成。按照前面的配置，默认的<code>db.sqlite3</code>里应该出现Django内置app的Model、<code>db_1</code>里应该出现<code>app_1</code>的Model、<code>db2</code>里应该出现<code>app_2</code>的Model，对吧？</p><p>现实是残酷的。从<code>migrate</code>模块的源码（<a href="https://github.com/django/django/blob/2.2.12/django/core/management/commands/migrate.py#L81">migrate.py#L81</a>）可以看出，<code>migrate</code>在应用迁移方案时根本不会考虑<code>DATABASE_ROUTERS</code>里的<code>db_for_read</code>和<code>db_for_write</code>，只会对参数<code>--database</code>指定的数据库（如不指定则为默认数据库）进行操作——也就是说，这里所有的Model都被一股脑写入到了默认的<code>db.sqlite3</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sqlite3 db.sqlite3 .tables</span><br>app_1_model1                auth_user_groups<br>app_2_model2                auth_user_user_permissions<br>auth_group                  django_admin_log<br>auth_group_permissions      django_content_type<br>auth_permission             django_migrations<br>auth_user                   django_session<br></code></pre></td></tr></table></figure><p>很明显，这不是我想要的。如何补救呢？措施有两种。</p><h3 id="补救措施1"><a href="#补救措施1" class="headerlink" title="补救措施1"></a>补救措施1</h3><p>第一种补救措施是在生成自定义app的迁移方案之前抢先完成对内置app的迁移方案，然后再进行自定义app的迁移。这种措施需要删除已经生成好的迁移方案文件。当然，这个补救措施有点耍滑头了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> db.sqlite3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> app_?/migrations/0001_initial.py</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># 迁移内置app</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate</span><br>Operations to perform:<br>  Apply all migrations: admin, auth, contenttypes, sessions<br>Running migrations:<br>  Applying contenttypes.0001_initial... OK<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># 重新生成自定义app的model的迁移方案</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py makemigrations</span><br>Migrations for &#x27;app_1&#x27;:<br>  app_1/migrations/0001_initial.py<br>    - Create model Model1<br>Migrations for &#x27;app_2&#x27;:<br>  app_2/migrations/0001_initial.py<br>    - Create model Model2<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># 迁移时指定数据库</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate app_1 --database db_1</span><br>Operations to perform:<br>  Apply all migrations: app_1<br>Running migrations:<br>  Applying app_1.0001_initial... OK<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate app_2 --database db_2</span><br>Operations to perform:<br>  Apply all migrations: app_2<br>Running migrations:<br>  Applying app_2.0001_initial... OK<br></code></pre></td></tr></table></figure><h3 id="补救措施2"><a href="#补救措施2" class="headerlink" title="补救措施2"></a>补救措施2</h3><p>第二种补救措施不必删除已经生成好的自定义app的迁移方案文件，而是单独迁移内置app。虽然<code>migrate</code>命令一次只能迁移一个app，但所幸需要用到的内置app一般不会太多。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> db.sqlite3</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate admin</span><br>Operations to perform:<br>  Apply all migrations: admin<br>Running migrations:<br>  Applying contenttypes.0001_initial... OK<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate auth</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate contenttypes</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate sessions</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># 单独迁移完内置app后再迁移自定义app</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate app_1 --database db_1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py migrate app_2 --database db_2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">...</span><br><br></code></pre></td></tr></table></figure><h2 id="自定义migrate"><a href="#自定义migrate" class="headerlink" title="自定义migrate"></a>自定义migrate</h2><p>前文提到的两个补救措施终究只是一时的权宜之计，用起来也很麻烦。反正只是多运行几次<code>migrate</code>命令，为什么不交给python来做呢？编辑<code>my_migrate.py</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># my_migrate.py</span><br><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> django<br><span class="hljs-keyword">from</span> django.apps <span class="hljs-keyword">import</span> apps, AppConfig<br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.core.management <span class="hljs-keyword">import</span> execute_from_command_line, CommandError<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> DEFAULT_DB_ALIAS<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;multi_db.settings&#x27;</span>)<br>django.setup()<br><br><span class="hljs-keyword">for</span> app_config <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(apps.get_app_configs()):  <span class="hljs-comment"># type: AppConfig</span><br>    app_label = app_config.label  <span class="hljs-comment"># type: <span class="hljs-built_in">str</span></span><br>    db = settings.DB_ROUTING.get(app_config.label, DEFAULT_DB_ALIAS)<br>    argv = [<span class="hljs-string">&quot;manage.py&quot;</span>, <span class="hljs-string">&quot;migrate&quot;</span>, <span class="hljs-string">&quot;--traceback&quot;</span>, <span class="hljs-string">&quot;--database&quot;</span>, db, app_label]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;python &quot;</span> + <span class="hljs-string">&quot; &quot;</span>.join(argv))<br>    <span class="hljs-keyword">try</span>:<br>        execute_from_command_line(argv)<br>    <span class="hljs-keyword">except</span> CommandError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;migrate complete&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>一股熟悉的味道……没错，看起来就像是<code>manage.py</code>的魔改版本。代码在<code>migrate</code>某app之前会去配置文件里的<code>DB_ROUTING</code>字典查找该app对应的数据库，再用这个数据库来<code>migrate</code>这个app。运行效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python my_migrate.py</span><br>python manage.py migrate --traceback --database default admin<br>Operations to perform:<br>  Apply all migrations: admin<br>Running migrations:<br>  Applying contenttypes.0001_initial... OK<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">... 略</span><br><br>python manage.py migrate --traceback --database db_1 app_1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">... 略</span><br></code></pre></td></tr></table></figure><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>于是，这个Django项目的数据库迁移工作终于完成了，太不容易了……验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sqlite3 db.sqlite3 .tables</span><br>auth_group                  auth_user_user_permissions<br>auth_group_permissions      django_admin_log<br>auth_permission             django_content_type<br>auth_user                   django_migrations<br>auth_user_groups            django_session<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_1<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> tables<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> Tables_in_db_1    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> app_1_model1      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> django_migrations <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mariadb root<span class="hljs-variable">@127</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:db_2<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> tables<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> Tables_in_db_2    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br><span class="hljs-operator">|</span> app_2_model2      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> django_migrations <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------+</span><br></code></pre></td></tr></table></figure><h1 id="第二关：运行"><a href="#第二关：运行" class="headerlink" title="第二关：运行"></a>第二关：运行</h1><p>数据库迁移（终于）完成后，该运行这个Django项目了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py runserver</span><br>Watching for file changes with StatReloader<br>Performing system checks...<br>System check identified no issues (0 silenced).<br>You have 2 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): app_1, app_2.<br>Run &#x27;python manage.py migrate&#x27; to apply them.<br>April 23, 2020 - xx:xx:xx<br></code></pre></td></tr></table></figure><p>等等，为什么我在上一步已经完成了全部迁移工作，Django还会提示<code>app_1</code>和<code>app_2</code>未迁移？虽然这并不影响运行，但鲜红的提示总是令人不爽。</p><p>从<code>apply_migration()</code>的源码（<a href="https://github.com/django/django/blob/2.2.12/django/db/migrations/executor.py#L246">executor.py#L246</a>）中可以看出，在<code>migrate</code>命令过程中，每执行完一条迁移任务，Django都会在同数据库的<code>django_migrations</code>表中写入一条迁移完成的标记，用于记录迁移进度。实际上，<code>db_1</code>和<code>db_2</code>的<code>django_migrations</code>也是有对应标记的。</p><p>但从模块<code>check_migrations()</code>的源码（<a href="https://github.com/django/django/blob/2.2.12/django/core/management/base.py#L453">base.py#L453</a>）中可以看出，在运行<code>runserver</code>命令时，Django只会到默认数据库的<code>django_migrations</code>表中查找迁移进度，<code>db_1</code>和<code>db_2</code>的迁移进度就被无视了……那么，怎样才能让在运行<code>runserver</code>时检查非默认数据库的迁移进度呢？</p><h2 id="自定义check-migrations"><a href="#自定义check-migrations" class="headerlink" title="自定义check_migrations"></a>自定义check_migrations</h2><p>简单来说，就是修改<code>runserver</code>里<code>check_migrations()</code>的行为。先来看看原始的<code>check_migrations()</code>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_migrations</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">from</span> django.db.migrations.executor <span class="hljs-keyword">import</span> MigrationExecutor<br>    <span class="hljs-keyword">try</span>:<br>        executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS])<br>    <span class="hljs-keyword">except</span> ImproperlyConfigured:<br>        <span class="hljs-comment"># No databases are configured (or the dummy one)</span><br>        <span class="hljs-keyword">return</span><br><br>    plan = executor.migration_plan(executor.loader.graph.leaf_nodes())<br>    <span class="hljs-keyword">if</span> plan:<br>        <span class="hljs-comment"># 提示未migrate的app，省略</span><br>        self.stdout.write(self.style.NOTICE(<span class="hljs-string">&quot;Run &#x27;python manage.py migrate&#x27; to apply them.\n&quot;</span>))<br></code></pre></td></tr></table></figure><p>总体逻辑并不复杂，关键在于<code>executor</code>对象的<code>migration_plan()</code>方法。我要做的就是引入<code>db_1</code>和<code>db_2</code>的<code>executor</code>，让每个数据库只检查自己的迁移进度。下面是我自己实现的<code>check_migrations()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># multi_db/my_runserver.py</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.core.management.commands <span class="hljs-keyword">import</span> runserver<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> connections, DEFAULT_DB_ALIAS<br><span class="hljs-keyword">from</span> django.db.migrations.executor <span class="hljs-keyword">import</span> MigrationExecutor<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCommand</span>(runserver.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_migrations</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 为每个数据库连接创建一个executor并放到字典里</span><br>        executors = &#123;&#125;<br>        <span class="hljs-keyword">for</span> alias <span class="hljs-keyword">in</span> connections:<br>            executors[alias] = MigrationExecutor(connections[alias])<br>        default_executor = executors[DEFAULT_DB_ALIAS]<br>        <span class="hljs-comment"># 获取迁移任务列表（nodes）</span><br>        <span class="hljs-comment"># nodes是一个tuple的list，每个tuple的第一个元素是app的名称</span><br>        nodes = default_executor.loader.graph.leaf_nodes()<br>        <span class="hljs-comment"># 按app名称将node分类</span><br>        node_map = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> nodes:  <span class="hljs-comment"># type: <span class="hljs-built_in">tuple</span></span><br>            alias = settings.DB_ROUTING.get(node[<span class="hljs-number">0</span>], DEFAULT_DB_ALIAS)<br>            node_map[alias].append(node)<br>        <span class="hljs-comment"># 让每个executor检查各自的迁移任务是否完成</span><br>        plan = []<br>        <span class="hljs-keyword">for</span> alias, executor <span class="hljs-keyword">in</span> executors.items():<br>            plan.extend(executor.migration_plan(node_map[alias]))<br><br>        <span class="hljs-keyword">if</span> plan:<br>            <span class="hljs-comment"># 提示未migrate的app，同原函数，省略</span><br>            self.stdout.write(self.style.NOTICE(<span class="hljs-string">&quot;Run &#x27;python manage.py migrate&#x27; to apply them.\n&quot;</span>))<br></code></pre></td></tr></table></figure><p>下一步就是让<code>manager.py</code>使用我这个<code>check_migrations()</code>而不是Django内置的<code>check_migrations()</code>。在<code>manager.py</code>的文件头修改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-string">&quot;&quot;&quot;Django&#x27;s command-line utility for administrative tasks.&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> multi_db.my_runserver <span class="hljs-keyword">import</span> MyCommand<br><span class="hljs-keyword">from</span> django.core.management.commands <span class="hljs-keyword">import</span> runserver<br><br>runserver.Command = MyCommand<br><span class="hljs-comment"># ... 略</span><br></code></pre></td></tr></table></figure><h2 id="大功告成-1"><a href="#大功告成-1" class="headerlink" title="大功告成"></a>大功告成</h2><p>运行看看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python manage.py runserver</span><br>Watching for file changes with StatReloader<br>Performing system checks...<br><br>System check identified no issues (0 silenced).<br>April 23, 2020 - xx:xx:xx<br></code></pre></td></tr></table></figure><p>终于不提示还有<code>unapplied migration</code>了……我哭了，你呢？</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
      <tag>多数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django视图函数性能分析（续）</title>
    <link href="/2020/04/19/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <url>/2020/04/19/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88%E7%BB%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2020/04/19/django.png" alt="django.png"></p><p>在<a href="/2019/03/11/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">以前的文章</a>中，我介绍了两种分析Django视图函数性能的工具：<code>Django Debug Toolbar</code>和<code>cProfile中间件</code>。在实际开发过程中，前者的SQL执行分析是相当实用的功能。</p><p>但美中不足的是，<code>Django Debug Toolbar</code>只能在浏览器里分析响应类型为HTML的视图函数，这就导致响应类型为JSON的视图函数必须要借助<code>Django Rest Framework</code>框架中的<code>HTMLRenderer</code>等手段修改自身的响应类型，否则无法使用该工具。</p><p>那有没有更直接的手段，来为JSON视图函数分析SQL执行情况呢？这就是文本要探究的问题。</p><blockquote><p>注：本文所使用的运行环境为<code>Python 3.6</code>+<code>Django 2.2</code></p></blockquote><h1 id="Django中的SQL执行"><a href="#Django中的SQL执行" class="headerlink" title="Django中的SQL执行"></a>Django中的SQL执行</h1><p>在查阅了相关文档后，我发现事情比我想象中的简单。在Django官方文档中的<a href="https://docs.djangoproject.com/en/2.2/faq/models/">FAQ: Databases and models</a>有这样的描述：</p><p><img src="/images/2020/04/19/document.webp" alt="document.webp"></p><p>如此一来方法就很清晰了：写一个中间件，将<code>connection.queries</code>里的内容插入到JSON响应中。中间件代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.core.exceptions <span class="hljs-keyword">import</span> MiddlewareNotUsed<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> connections<br><span class="hljs-keyword">from</span> django.http.response <span class="hljs-keyword">import</span> HttpResponse<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileMiddleware</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    ignore_sql = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, get_response</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> settings.DEBUG:<br>            <span class="hljs-keyword">raise</span> MiddlewareNotUsed  <span class="hljs-comment"># 只在DEBUG模式下启用该中间件</span><br><br>        self.get_response = get_response<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, request</span>):<br>        response = self.get_response(request)  <span class="hljs-comment"># type: HttpResponse</span><br>        <span class="hljs-comment"># 根据url参数和返回类型判断是否应该插入SQL执行信息</span><br>        <span class="hljs-keyword">if</span> request.GET.get(<span class="hljs-string">&quot;profile&quot;</span>) == <span class="hljs-string">&quot;db&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;application/json&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">repr</span>(response):<br>            <span class="hljs-keyword">try</span>:<br>                data = json.loads(response.content)<br>            <span class="hljs-keyword">except</span> (TypeError, ValueError):<br>                <span class="hljs-keyword">return</span> response  <span class="hljs-comment"># 解析json失败</span><br>            <span class="hljs-comment"># 插入sql执行信息</span><br>            sql_queries = []<br>            <span class="hljs-keyword">for</span> alias <span class="hljs-keyword">in</span> connections:<br>                <span class="hljs-keyword">for</span> query <span class="hljs-keyword">in</span> connections[alias].queries:<br>                    <span class="hljs-keyword">if</span> query[<span class="hljs-string">&quot;sql&quot;</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.ignore_sql:<br>                        query[<span class="hljs-string">&quot;using&quot;</span>] = alias<br>                        sql_queries.append(query)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>):<br>                data[<span class="hljs-string">&quot;_debug_sql&quot;</span>] = sql_queries<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">list</span>):<br>                data.append(&#123;<span class="hljs-string">&quot;_debug_sql&quot;</span>: sql_queries&#125;)<br>            response.content = json.dumps(data)<br><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>写个简单视图函数来验证一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> django.contrib.auth.models <span class="hljs-keyword">import</span> User<br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> JsonResponse<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_count</span>(<span class="hljs-params">request</span>):<br>    data = &#123;<span class="hljs-string">&quot;count&quot;</span>: User.objects.count()&#125;<br>    <span class="hljs-keyword">return</span> JsonResponse(data)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s localhost:8000/user_count/\?profile=db | python3 -m json.tool</span><br>&#123;<br>    &quot;count&quot;: 0,<br>    &quot;_debug_sql&quot;: [<br>        &#123;<br>            &quot;sql&quot;: &quot;SELECT COUNT(*) AS \&quot;__count\&quot; FROM \&quot;auth_user\&quot;&quot;,<br>            &quot;time&quot;: &quot;0.000&quot;,<br>            &quot;using&quot;: &quot;default&quot;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="和cProfile中间件组合"><a href="#和cProfile中间件组合" class="headerlink" title="和cProfile中间件组合"></a>和cProfile中间件组合</h1><p>在<a href="/2019/03/11/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">以前的文章</a>中我也介绍了使用<code>cProfile中间件</code>来分析Django视图函数的Python代码执行情况，这里就顺便组合起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">import</span> cProfile<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> pstats<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.core.exceptions <span class="hljs-keyword">import</span> MiddlewareNotUsed<br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> connections<br><span class="hljs-keyword">from</span> django.http.response <span class="hljs-keyword">import</span> HttpResponse<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileMiddleware</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    ignore_sql = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, get_response</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> settings.DEBUG:<br>            <span class="hljs-keyword">raise</span> MiddlewareNotUsed  <span class="hljs-comment"># 只在DEBUG模式下启用该中间件</span><br><br>        self.get_response = get_response<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, request</span>):<br>        <span class="hljs-keyword">if</span> request.GET.get(<span class="hljs-string">&quot;profile&quot;</span>) == <span class="hljs-string">&quot;cprofile&quot;</span>:<br>            <span class="hljs-comment"># 用cProfile的结果覆盖原始响应</span><br>            profile = cProfile.Profile()<br>            profile.enable()<br>            self.get_response(request)<br>            profile.disable()<br>            ram_file = StringIO()<br>            sort_by = <span class="hljs-string">&#x27;tottime&#x27;</span><br>            stats = pstats.Stats(profile, stream=ram_file)<br>            stats.strip_dirs().sort_stats(sort_by).print_stats()<br>            <span class="hljs-keyword">return</span> HttpResponse(ram_file.getvalue().encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-string">&#x27;text/plain&#x27;</span>)<br><br>        response = self.get_response(request)  <span class="hljs-comment"># type: HttpResponse</span><br>        <span class="hljs-comment"># 根据url参数和返回类型判断是否应该插入SQL执行信息</span><br>        <span class="hljs-keyword">if</span> request.GET.get(<span class="hljs-string">&quot;profile&quot;</span>) == <span class="hljs-string">&quot;db&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;application/json&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">repr</span>(response):<br>            <span class="hljs-keyword">try</span>:<br>                data = json.loads(response.content)<br>            <span class="hljs-keyword">except</span> (TypeError, ValueError):<br>                <span class="hljs-keyword">return</span> response  <span class="hljs-comment"># 解析json失败</span><br>            <span class="hljs-comment"># 插入sql执行信息</span><br>            sql_queries = []<br>            <span class="hljs-keyword">for</span> alias <span class="hljs-keyword">in</span> connections:<br>                <span class="hljs-keyword">for</span> query <span class="hljs-keyword">in</span> connections[alias].queries:<br>                    <span class="hljs-keyword">if</span> query[<span class="hljs-string">&quot;sql&quot;</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.ignore_sql:<br>                        query[<span class="hljs-string">&quot;using&quot;</span>] = alias<br>                        sql_queries.append(query)<br>            data[<span class="hljs-string">&quot;_debug_sql&quot;</span>] = sql_queries<br>            response.content = json.dumps(data)<br><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>同样验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -s localhost:8000/user_count/\?profile=cprofile</span><br>         830 function calls (826 primitive calls) in 0.002 seconds<br><br>   Ordered by: internal time<br><br>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br>        1    0.000    0.000    0.000    0.000 base.py:379(execute)<br>        1    0.000    0.000    0.000    0.000 &#123;built-in method _sqlite3.connect&#125;<br>        4    0.000    0.000    0.000    0.000 base.py:53(list_aggregate)<br>       20    0.000    0.000    0.000    0.000 functools.py:44(update_wrapper)<br>      158    0.000    0.000    0.000    0.000 &#123;built-in method builtins.getattr&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不得不感叹Django真是一个功能完善、生态丰富的Web框架，这篇文章只是站在巨人的肩膀上取得了一些微不足道的成就。<code>Django Debug Toolbar</code>虽然也是通过<code>connection.queries</code>的方式获取了SQL执行情况（<a href="https://github.com/jazzband/django-debug-toolbar/blob/2.2/debug_toolbar/panels/sql/panel.py#L58">panel.py#L58</a>），但其所做的工作远不止如此，值得细看。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Python</tag>
      
      <tag>性能分析</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang极简实现WebSocket承载socks5流量</title>
    <link href="/2020/02/20/Golang%E6%9E%81%E7%AE%80%E5%AE%9E%E7%8E%B0WebSocket%E6%89%BF%E8%BD%BDsocks5%E6%B5%81%E9%87%8F/"/>
    <url>/2020/02/20/Golang%E6%9E%81%E7%AE%80%E5%AE%9E%E7%8E%B0WebSocket%E6%89%BF%E8%BD%BDsocks5%E6%B5%81%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>假设有一台远程服务器：<code>1.2.3.4</code>，上面运行着一个socks5代理：<code>127.0.0.1:1080</code>。登上这台远程服务器后，可以通过curl验证这个代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl --socks5 127.0.0.1:1080 https://httpbin.org/get</span><br>&#123;<br>  ...<br>  &quot;origin&quot;: &quot;1.2.3.4&quot;,<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>本文的目标是通过WebSocket的方式让本地curl也可以使用这个socks5代理。</p><h1 id="服务器运行代码"><a href="#服务器运行代码" class="headerlink" title="服务器运行代码"></a>服务器运行代码</h1><p>这段代码运行于远程服务器，代码运行时会在<code>1.2.3.4:5000</code>上开启一个WebSocket服务。每接收到一个WebSocket请求，代码就会连接至本地的socks5代理，使用<code>io.Copy</code>进行数据转发工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;golang.org/x/net/websocket&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ws2socks</span><span class="hljs-params">(ws *websocket.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> ws.Close()<br>socks, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:1080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;dial socks error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> socks.Close()<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>ioCopy := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>io.Copy(dst, src)<br>&#125;<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> ioCopy(socks, ws)<br><span class="hljs-keyword">go</span> ioCopy(ws, socks)<br>wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.Handle(<span class="hljs-string">&quot;/&quot;</span>, websocket.Handler(ws2socks))<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;1.2.3.4:5000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="本地运行代码"><a href="#本地运行代码" class="headerlink" title="本地运行代码"></a>本地运行代码</h1><p>这段代码运行于本地，代码运行时会监听<code>127.0.0.1:8888</code>。每接收到一个TCP连接，代码就会连接至远程服务器的WebSocket服务，同样使用<code>io.Copy</code>进行数据转发工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;golang.org/x/net/websocket&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">socks2ws</span><span class="hljs-params">(socks *net.TCPConn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> socks.Close()<br>    ws, err := websocket.Dial(<span class="hljs-string">&quot;ws://1.2.3.4:5000/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ws://1.2.3.4:5000/&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;dial websocket error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> ws.Close()<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>ioCopy := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>io.Copy(dst, src)<br>&#125;<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> ioCopy(ws, socks)<br><span class="hljs-keyword">go</span> ioCopy(socks, ws)<br>wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;listen tcp at:&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, _ := listener.Accept()<br><span class="hljs-keyword">go</span> socks2ws(conn.(*net.TCPConn))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实际运行"><a href="#实际运行" class="headerlink" title="实际运行"></a>实际运行</h1><p>在远程服务器、本地分别运行对应的代码后，就可以在本地用curl测试这个”本地socks5代理”了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl --socks5 127.0.0.1:8888 https://httpbin.org/get</span><br>&#123;<br>  ...<br>  &quot;origin&quot;: &quot;1.2.3.4&quot;,<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="TLS加密"><a href="#TLS加密" class="headerlink" title="TLS加密"></a>TLS加密</h1><p>如果不使用TLS加密传输，WebSocket中的数据将以明文的方式暴露在互联网上。为了安全性考虑，使用TLS加密传输是很有必要的。</p><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><p>关于域名和证书的文章有很多，这里就不赘述了。假设有域名<code>test.com</code>的解析指向了这台服务器<code>1.2.3.4</code>，已经生成自签名证书文件于<code>/etc/ssl/1.cert</code>和<code>/etc/ssl/2.key</code>。配置了Nginx之后（如下所示），WebSocket服务的地址就会从<code>ws://1.2.3.4:5000/</code>变为<code>wss://test.com/ws</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br>listen 443 ssl;<br>server_name test.com;<br><br>ssl_certificate     /etc/ssl/1.cert;<br>ssl_certificate_key /etc/ssl/2.key;<br>ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;<br>ssl_ciphers         HIGH:!aNULL:!MD5;<br><br>root /var/www/html;<br>index index.html index.htm index.nginx-debian.html;<br><br>location / &#123;<br>try_files $uri $uri/ =404;<br>&#125;<br><br>location /ws &#123;<br>proxy_pass http://1.2.3.4:5000;<br>proxy_http_version 1.1;<br>proxy_set_header Upgrade $http_upgrade;<br>proxy_set_header Connection &quot;Upgrade&quot;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="本地代码变动"><a href="#本地代码变动" class="headerlink" title="本地代码变动"></a>本地代码变动</h2><p>如果不是自签名证书，那么本地代码只需要更改WebSocket连接地址。但如果是自签名证书，本地代码最好主动接受认证文件（即上文提到的<code>1.cert</code>），因为跳过证书认证会带来额外的风险。于是，本地代码在向WebSocket服务请求之前需要先读取认证文件，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br>...<br><span class="hljs-keyword">var</span> wsConfig *websocket.Config<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initConfig</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// load certificate file</span><br>content, err := ioutil.ReadFile(<span class="hljs-string">&quot;1.cert&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>roots := x509.NewCertPool()<br><span class="hljs-keyword">if</span> ok := roots.AppendCertsFromPEM(content); ok != <span class="hljs-literal">true</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;cert parse fail&quot;</span>)<br>&#125;<br><span class="hljs-comment">// generate websocket config</span><br>wsConfig, err = websocket.NewConfig(<span class="hljs-string">&quot;wss://test.com/ws&quot;</span>, <span class="hljs-string">&quot;wss://test.com/ws&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>wsConfig.TlsConfig = &amp;tls.Config&#123;RootCAs: roots&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">socks2ws</span><span class="hljs-params">(socks *net.TCPConn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> socks.Close()<br>ws, err := websocket.DialConfig(wsConfig)<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>initConfig()<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>思路很简单，实现也简单……就当是Golang的入门练习。总结一下就是，Golang真香。</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>websocket</tag>
      
      <tag>socks5</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APT、Docker、PyPI使用国内镜像加速</title>
    <link href="/2019/12/17/APT%E3%80%81Docker%E3%80%81PyPI%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/"/>
    <url>/2019/12/17/APT%E3%80%81Docker%E3%80%81PyPI%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2019-12-17.03.webp"></p><p>因为一些不可描述的原因，在中国绝大多数地区进行更新APT软件包列表（<code>apt-get update</code>）&amp;安装APT软件包（<code>apt-get isntall</code>）、拉取Docker镜像（<code>docker pull</code>）、安装PyPI包（<code>pip install</code>）等操作都是一件非常痛苦的事：网络连接速度太慢了。万幸的是我们有许多开源软件镜像站点，合理设置镜像站点能够极大提升工作和学习效率。这篇文章介绍的就是在上述三种场景下如何设置镜像站点。</p><h1 id="APT镜像加速"><a href="#APT镜像加速" class="headerlink" title="APT镜像加速"></a>APT镜像加速</h1><p><a href="https://mirror.tuna.tsinghua.edu.cn/help">TUNA镜像站（清华大学开源软件镜像站）</a>上介绍了绝大部分Linux发行版的镜像加速设置方法，这里只介绍Debian系发行版的APT镜像加速如何设置。<br>APT更新软件包列表的第一步是从本地源列表（<code>/etc/apt/sources.list</code>和<code>/etc/apt/sources.list.d/*.list</code>）中读取所有软件来源站点，所以我们只要更新本地源列表就可以实现镜像加速了（下面的源列表不包括源代码站点，如需完整站点可自行取消注释对应行）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">备份已有源列表</span><br>sudo cp /etc/apt/sources.list /etc/apt/sources.list.old<br>distrib=$(lsb_release -is | awk &#x27;&#123;print tolower($1)&#125;&#x27;)<br>codename=$(lsb_release -cs)<br>apt_src=&quot;https://mirrors.aliyun.com&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">↑阿里云源 ↓TUNA源</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">apt_src=<span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn&quot;</span></span><br>cat &gt;sources.list&lt;&lt;EOF<br>deb $apt_src/$distrib/ $codename main restricted universe multiverse<br>deb $apt_src/$distrib/ $codename-security main restricted universe multiverse<br>deb $apt_src/$distrib/ $codename-updates main restricted universe multiverse<br>deb $apt_src/$distrib/ $codename-backports main restricted universe multiverse<br><span class="hljs-meta prompt_">#</span><span class="language-bash">deb-src <span class="hljs-variable">$apt_src</span>/<span class="hljs-variable">$distrib</span>/ <span class="hljs-variable">$codename</span> main restricted universe multiverse</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">deb-src <span class="hljs-variable">$apt_src</span>/<span class="hljs-variable">$distrib</span>/ <span class="hljs-variable">$codename</span>-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">deb-src <span class="hljs-variable">$apt_src</span>/<span class="hljs-variable">$distrib</span>/ <span class="hljs-variable">$codename</span>-updates main restricted universe multiverse</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">deb-src <span class="hljs-variable">$apt_src</span>/<span class="hljs-variable">$distrib</span>/ <span class="hljs-variable">$codename</span>-backports main restricted universe multiverse</span><br>EOF<br>sudo mv sources.list /etc/apt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新软件包列表</span><br>sudo apt-get update<br></code></pre></td></tr></table></figure><h2 id="手动添加Ubuntu-PPA源"><a href="#手动添加Ubuntu-PPA源" class="headerlink" title="手动添加Ubuntu PPA源"></a>手动添加Ubuntu PPA源</h2><p>PPA（Personal Package Archives）作为APT源的补充能让Ubuntu用户在第一时间体验到最新发布的软件。但在笔者的实际体验中，默认的PPA源添加命令（<code>add-apt-repository</code>）往往需要极长的时间才能添加完成。经过一段时间摸索，笔者发现可以通过简单的方式手动添加Ubuntu PPA源，在此分享给读者。<br><img src="/images/2019-12-17.01.webp"></p><p>以上图（<a href="https://launchpad.net/~starws-box/+archive/ubuntu/deadbeef-player">deadbeef-player : starws</a>）为例，点开图中的”Technical details about this PPA”，在下拉列表中选择系统版本后，将下方的PPA源链接保存至本地源列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;deb http://ppa.launchpad.net/starws-box/deadbeef-player/ubuntu bionic main&quot; &gt; ppa-deadbeef.list<br>sudo mv ppa-deadbeef.list /etc/apt/sources.list.d/<br></code></pre></td></tr></table></figure><p>然后再点击上图中<code>Signing key</code>下方的链接，在出现的新页面（如下图所示）中复制<code>sig</code>公钥文件的地址。最后用<code>apt-key</code>添加这个公钥，这个PPA源就添加完成了。</p><p><img src="/images/2019-12-17.02.webp"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget -qO - https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x446c82dc2dd154a1 | sudo apt-key add -</span><br>OK<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update &amp;&amp; sudo apt-get install deadbeef</span><br></code></pre></td></tr></table></figure><h1 id="安装Docker（Ubuntu-16-04-）"><a href="#安装Docker（Ubuntu-16-04-）" class="headerlink" title="安装Docker（Ubuntu 16.04+）"></a>安装Docker（Ubuntu 16.04+）</h1><p>Debian系统理论上可以兼容这些命令，不过笔者没有进行过测试。其它系统参见<a href="https://yeasy.gitbooks.io/docker_practice/install/">《Docker——从入门到实践》 安装Docker</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubuntu 16.04需要先安装这个依赖包，Ubuntu 18.04不用</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">wget http://launchpadlibrarian.net/344879847/libseccomp2_2.3.1-2.1ubuntu2~16.04.1_amd64.deb</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo dpkg -i libseccomp2_2.3.1-2.1ubuntu2~16.04.1_amd64.deb</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">rm</span> libseccomp2_2.3.1-2.1ubuntu2~16.04.1_amd64.deb</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载旧版本Docker</span><br>sudo apt-get remove docker docker-engine docker.io<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加Docker-ce源并安装Docker-ce</span><br>echo &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/$(lsb_release -is | awk &#x27;&#123;print tolower($1)&#125;&#x27;) $(lsb_release -cs) stable&quot; &gt; docker-ce.list<br>sudo mv docker-ce.list /etc/apt/sources.list.d/<br>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br>sudo apt-get update &amp;&amp; sudo apt-get install docker-ce<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动Docker服务并配置用户组</span><br>sudo systemctl enable docker<br>sudo systemctl start docker<br>sudo groupadd docker<br>sudo usermod -aG docker $USER<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出当前终端并重新登录，测试Docker是否正常运行</span><br>docker version<br></code></pre></td></tr></table></figure><h1 id="Docker镜像加速"><a href="#Docker镜像加速" class="headerlink" title="Docker镜像加速"></a>Docker镜像加速</h1><p>Docker在安装完成后默认从DockerHub源站拉取镜像，而将拉取目标站点从源站改为镜像站往往能获得更快的镜像拉取速度。详细流程参见<a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html">《Docker——从入门到实践》 镜像加速器</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt;daemon.json&lt;&lt;EOF<br>&#123;<br>  &quot;registry-mirrors&quot;: [<br>    &quot;https://dockerhub.azk8s.cn&quot;,<br>    &quot;https://hub-mirror.c.163.com&quot;<br>  ]<br>&#125;<br>EOF<br>sudo mv daemon.json /etc/docker/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>此时可以通过<code>docker info</code>命令查看镜像加速设置是否生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info -f <span class="hljs-string">&#x27;&#123;&#123;json .RegistryConfig.Mirrors&#125;&#125;&#x27;</span></span><br>[&quot;https://dockerhub.azk8s.cn/&quot;,&quot;https://hub-mirror.c.163.com/&quot;]<br></code></pre></td></tr></table></figure><h1 id="PyPI镜像加速"><a href="#PyPI镜像加速" class="headerlink" title="PyPI镜像加速"></a>PyPI镜像加速</h1><p>详细说明参见<a href="https://mirror.tuna.tsinghua.edu.cn/help/pypi/">TUNA pypi 镜像使用帮助</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">mirror=&quot;https://mirrors.aliyun.com/pypi/simple/&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">↑阿里云源 ↓TUNA源</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mirror=<span class="hljs-string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">临时安装</span><br>pip install -i $mirror requests<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设为默认，需要升级pip到最新版本（&gt;=10.0.0）</span><br>pip install -i $mirror pip -U<br>pip config set global.index-url $mirror<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>网络优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker快速部署ownCloud并配置HTTPS</title>
    <link href="/2019/12/16/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ownCloud%E5%B9%B6%E9%85%8D%E7%BD%AEHTTPS/"/>
    <url>/2019/12/16/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ownCloud%E5%B9%B6%E9%85%8D%E7%BD%AEHTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2019-12-16.01.webp"><br>ownCloud一直是市场上最受欢迎的个人云存储解决方案之一，有着使用广泛、客户端兼容性好、自由开源等优点。但ownCloud的部署涉及LAMP环境，部署过程较为繁琐。这篇文章介绍如何用docker-compose快速部署ownCloud，并配置Nginx转发+HTTPS提高服务器安全性。</p><h1 id="配置docker-compose"><a href="#配置docker-compose" class="headerlink" title="配置docker-compose"></a>配置docker-compose</h1><blockquote><p>以下部分内容来自<a href="https://doc.owncloud.com/server/latest/admin_manual/installation/docker/">ownCloud官方安装文档</a></p></blockquote><p>首先，下载官方docker-compose文件，并创环境变量文件用以指定ownCloud版本、账户密码和HTTP端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> owncloud-docker-server</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> owncloud-docker-server</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://raw.githubusercontent.com/owncloud/docs/master/modules/admin_manual/examples/installation/docker/docker-compose.yml</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; .env</span></span><br>OWNCLOUD_VERSION=10.3<br>OWNCLOUD_DOMAIN=localhost<br>ADMIN_USERNAME=admin<br>ADMIN_PASSWORD=admin<br>HTTP_PORT=8080<br>EOF<br></code></pre></td></tr></table></figure><p>从下载下来的<code>docker-compose.yml</code>文件里可以看出，ownCloud共有三个docker服务：<code>owncloud</code>、<code>db</code>、<code>redis</code>，这三个docker服务都将创建独立的docker数据卷，将各自的数据文件持久化到数据卷里。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.1&#x27;</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">files:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">local</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">owncloud:</span><br><span class="hljs-string">...</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">files:/mnt/data</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>我个人更习惯将ownCloud的数据保存目录指定为某个具体文件夹，方便我进行管理。所以我对<code>docker-compose.yml</code>做如下改动：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.1&#x27;</span><br><br><span class="hljs-attr">volumes:</span><br><span class="hljs-comment">#  files:</span><br><span class="hljs-comment">#    driver: local</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">owncloud:</span><br><span class="hljs-string">...</span><br>    <span class="hljs-attr">volumes:</span><br><span class="hljs-comment">#      - files:/mnt/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/path/to/my/data/owncloud:/mnt/data</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><h1 id="用docker-compose启动ownCloud"><a href="#用docker-compose启动ownCloud" class="headerlink" title="用docker-compose启动ownCloud"></a>用docker-compose启动ownCloud</h1><p>启动ownCloud的命令很简单，只需让docker-compose按照配置好的<code>docker-compose.yml</code>启动容器。第一次运行需要拉取镜像，只需耐心等待即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>命令执行完成后可以通过docker-compose命令查看拉取的镜像和服务运行状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose images</span><br>     Container           Repository        Tag       Image Id      Size<br>-------------------------------------------------------------------------<br>owncloud_db_1         webhippie/mariadb   latest   3f6237885724   626 MB<br>owncloud_owncloud_1   owncloud/server     10.3     b7c82576c651   785 MB<br>owncloud_redis_1      webhippie/redis     latest   42ab00c664c2   56.4 MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose ps</span><br>       Name                      Command                  State               Ports<br>--------------------------------------------------------------------------------------------<br>owncloud_db_1         /usr/bin/entrypoint /bin/s ...   Up (healthy)   3306/tcp<br>owncloud_owncloud_1   /usr/bin/entrypoint /usr/b ...   Up (healthy)   0.0.0.0:8080-&gt;8080/tcp<br>owncloud_redis_1      /usr/bin/entrypoint /bin/s ...   Up (healthy)   6379/tcp<br></code></pre></td></tr></table></figure><p>此时也可以用curl来验证服务是否启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:8080 -I</span><br>HTTP/1.1 302 Found<br>Date: Mon, 16 Dec 2019 03:14:55 GMT<br>Server: Apache<br>...<br></code></pre></td></tr></table></figure><h1 id="配置Nginx转发-HTTPS"><a href="#配置Nginx转发-HTTPS" class="headerlink" title="配置Nginx转发+HTTPS"></a>配置Nginx转发+HTTPS</h1><p>Nginx+HTTPS的配置不算麻烦，只要在Nginx的配置文件（比如<code>/etc/nginx/sites-available/default</code>）中添加一个server项即可。在这里的配置中，我让Nginx在8000端口上启动HTTPS服务，并将所有请求以HTTP方式转发至8080端口上的ownCloud。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8000</span> ssl;<br>    <span class="hljs-attribute">server_name</span> owncloud;<br><br>    <span class="hljs-attribute">ssl_certificate</span>     /etc/nginx/ssl/owncloud.crt;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /etc/nginx/ssl/owncloud.key;<br>    <span class="hljs-attribute">ssl_protocols</span>       TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span>         HIGH:!aNULL:!MD5;<br><br>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_set_header</span>   Host             <span class="hljs-variable">$host</span>:<span class="hljs-number">8000</span>;<br>        <span class="hljs-attribute">proxy_redirect</span>     http://          https://;<br>        <span class="hljs-attribute">proxy_pass</span>         http://127.0.0.1:8080/;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置时有一些需要注意的地方。</p><ul><li><code>client_max_body_size</code>项，其默认的值为<code>1m</code>，也就是说Nginx最大只能接受1M大小的HTTP请求，这对于ownCloud的文件上传功能来说是不可接受的。在这里我将其设为<code>0</code>，让Nginx不限制HTTP请求的大小。理论上来说这个参数应该限定在文件上传的<code>url</code>以提高安全性，但这里就图个方便。</li><li><code>location</code>中的<code>proxy_set_header</code>项，将请求转发头的Host设置为Nginx的Host（$host:8000）而不是ownCloud的Host（$host:8080），避免ownCloud在响应重定向时返回8080端口地址。</li><li><code>location</code>中的<code>proxy_redirect</code>项，将所有重定向响应中的HTTP地址转换为HTTPS地址。</li></ul><p>当然，在配置了以上转发规则后，ownCloud的响应还是存在一些问题：网页上的注销链接地址没有加上HTTPS前缀，导致点击后出现400错误，需要手动将地址前缀改成<code>https://</code>才能顺利注销。这个就属于ownCloud本身的BUG了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>个人云存储的优势在公共云存储商家不断倒闭之后逐渐显现出来了。如果有使用个人云存储服务的需求，ownCloud无疑是一个值得尝试的选择。不管是局域网内部使用、公网IP宽带+DDNS、内网穿透，还是VPS（包括低价大带宽的NAT VPS），HAVE FUN and ENJOY。</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>owncloud</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自用linux server性能测试</title>
    <link href="/2019/11/18/%E8%87%AA%E7%94%A8linux-server%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2019/11/18/%E8%87%AA%E7%94%A8linux-server%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用工具测试下手头用着的linux server，三个vps平台、一台物理机，测试结果看看就好，不用太较真。</p><h1 id="测试结果汇总"><a href="#测试结果汇总" class="headerlink" title="测试结果汇总"></a>测试结果汇总</h1><table><thead><tr><th>服务商</th><th>Google Cloud</th><th>Google Cloud</th><th>阿里云</th><th>某NAT VPS商家</th><th>个人PC</th></tr></thead><tbody><tr><td>机器型号</td><td>f1-micro 1vCPU 0.6GB 10GB</td><td>g1-small 1vCPU 1.7GB 40GB</td><td>ecs.n4.small 1vCPU 2GiB 40GB</td><td>1vCPU 1GB 20GB</td><td>4CPU 8GB 480GB(nvme)</td></tr><tr><td>参考价格</td><td>$6&#x2F;mo</td><td>$20&#x2F;mo</td><td>￥98&#x2F;mo</td><td>￥26&#x2F;mo</td><td></td></tr><tr><td>系统</td><td>Ubuntu 18.04 LTS</td><td>Ubuntu 18.04 LTS</td><td>CentOS 7</td><td>Ubuntu 18.04 LTS</td><td>Ubuntu 18.04 LTS</td></tr><tr><td>CPU信息</td><td>Xeon(R) CPU @ 2.00GHz</td><td>Xeon(R) CPU @ 2.00GHz</td><td>E5-2682 v4 @ 2.50GHz</td><td>E3-12xx v2 @ 2.50GHz</td><td>i3-8100 CPU @ 3.60GHz</td></tr><tr><td>sysbench(cpu)</td><td>9469 (v1.0.11)</td><td>9477 (v1.0.11)</td><td>7909 (v1.0.17)</td><td>6157 (v1.0.11)</td><td>12799 (v1.0.11)</td></tr><tr><td>4K W&#x2F;R</td><td>6.5 MB&#x2F;s 8.1 MB&#x2F;s</td><td>6.6 MB&#x2F;s 7.8 MB&#x2F;s</td><td>8.3 MB&#x2F;s 8.7 MB&#x2F;s</td><td>1.2 MB&#x2F;s 1.2 MB&#x2F;s</td><td>245 MB&#x2F;s 80 MB&#x2F;s</td></tr><tr><td>1M W&#x2F;R</td><td>37.7 MB&#x2F;s 128 MB&#x2F;s</td><td>37.7 MB&#x2F;s 128 MB&#x2F;s</td><td>109 MB&#x2F;s 111 MB&#x2F;s</td><td>101 MB&#x2F;s 103MB&#x2F;s</td><td>1 GB&#x2F;s 1 GB&#x2F;s</td></tr><tr><td>RAM 4K</td><td>975 MB&#x2F;s 1.5 GB&#x2F;s</td><td>1.2 GB&#x2F;s 2.3 GB&#x2F;s</td><td>1.2 GB&#x2F;s 2.1 GB&#x2F;s</td><td>89.1 MB&#x2F;s 94.2 MB&#x2F;s</td><td>2.2 GB&#x2F;s 2.9 GB&#x2F;s</td></tr><tr><td>MariaDB ENCODE</td><td></td><td>1.457s (19.03.5)</td><td>1.772s (18.06.1)</td><td>2.135s (19.03.5)</td><td>1.126s (19.03.4)</td></tr><tr><td>公网带宽</td><td>&gt;100Mb</td><td>&gt;100Mb</td><td>1Mb</td><td>共享50Mb</td><td>家宽</td></tr></tbody></table><h1 id="测试项说明"><a href="#测试项说明" class="headerlink" title="测试项说明"></a>测试项说明</h1><h2 id="sysbench-cpu"><a href="#sysbench-cpu" class="headerlink" title="sysbench(cpu)"></a>sysbench(cpu)</h2><p>直接运行如下shell命令，并取运行输出中的<code>Threads fairness avg events</code>作为测试结果（表中括号内为sysbench软件版本），数值越大越好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysbench --test=cpu --cpu-max-prime=10000 run<br></code></pre></td></tr></table></figure><h2 id="4K-W-x2F-R"><a href="#4K-W-x2F-R" class="headerlink" title="4K W&#x2F;R"></a>4K W&#x2F;R</h2><p>用如下dd命令以4K为块单位测试硬盘写读速度（测3次取平均值），数值越大越好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=/dev/zero of=tmpfile bs=4096 count=32768 oflag=direct<br>dd of=/dev/null if=tmpfile bs=4096 count=32768 iflag=direct<br></code></pre></td></tr></table></figure><h2 id="1M-W-x2F-R"><a href="#1M-W-x2F-R" class="headerlink" title="1M W&#x2F;R"></a>1M W&#x2F;R</h2><p>用如下dd命令以1M为块单位测试硬盘写读速度（测3次取平均值），数值越大越好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=/dev/zero of=tmpfile bs=1048576 count=1024 oflag=direct<br>dd of=/dev/null if=tmpfile bs=1048576 count=1024 iflag=direct<br></code></pre></td></tr></table></figure><h2 id="RAM-4K"><a href="#RAM-4K" class="headerlink" title="RAM 4K"></a>RAM 4K</h2><p>挂载出一块内存盘，用dd命令以4K为块单位测试内存写读速度（由于内存盘不支持direct io，第二次之后的测试结果有较大波动，故只取首次运行结果），数值越大越好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/ram<br>sudo mount -t tmpfs -o size=512m ramdisk ~/ram<br>sudo chown $USER:$USER ~/ram<br>cd ~/ram<br>dd if=/dev/zero of=tmpfile bs=4096 count=65536<br>dd of=/dev/null if=tmpfile bs=4096 count=65536<br></code></pre></td></tr></table></figure><h2 id="MariaDB-ENCODING"><a href="#MariaDB-ENCODING" class="headerlink" title="MariaDB ENCODING"></a>MariaDB ENCODING</h2><p>用Docker运行一个MariaDB实例，运行之后使用ENCODING命令测试MariaDB运行速度（表中括号内为Docker版本），数值越小越好：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/mariadb_vol<br>docker run -d -v ~/mariadb_vol:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=12345 --name mariadb_test --restart=always mariadb --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci<br>docker exec -it mariadb_test mysql -uroot -p12345<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> BENCHMARK(<span class="hljs-number">10000000</span>,ENCODE(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;goodbye&#x27;</span>));<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>便宜自有便宜的道理，NAT VPS有着大带宽（虽然是共享的）、低价格的优势，但换来的是老旧的硬件平台（2012年的Ivy Bridge + DDR3）和接近机械硬盘的4K读写速度。<br>阿里云、谷歌云等大型云平台的VPS虽然带宽或流量贵、价格也贵，但硬件平台往往是较新的（阿里云是2016年的Broadwell + DDR4，谷歌云则更新），硬盘性能也更有保障（不过谷歌云实在是贵啊……）。怎么取舍，还是要看个人需求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>性能分析</tag>
      
      <tag>vps</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改Kong官方Docker镜像</title>
    <link href="/2019/05/30/%E4%BF%AE%E6%94%B9Kong%E5%AE%98%E6%96%B9Docker%E9%95%9C%E5%83%8F/"/>
    <url>/2019/05/30/%E4%BF%AE%E6%94%B9Kong%E5%AE%98%E6%96%B9Docker%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2019-05-30.01.png"><br>开源项目<a href="https://konghq.com/">Kong</a>是当下最火的API Gateway项目之一，官方也在<a href="https://hub.docker.com/_/kong">Docker Hub</a>上提供了Kong的镜像。但我在使用官方镜像来部署Kong的过程中发现，我需要对官方镜像做一些改动来适应我的需求：</p><ul><li>在Docker启动时只需要给定镜像、启动命令即可完成部署（包括初次部署），方便迁移k8s；</li><li>方便Kong切换不同的配置文件；</li><li>将Kong所有的日志存放在指定目录，方便挂载存储。</li></ul><p>这篇文章记录的就是我改动的思路和过程。</p><blockquote><p>注：本文所使用的运行环境为<code>Ubuntu 18.04 LTS</code>+<code>Docker 18.09.6</code>，Kong使用的数据库均为<code>PostgreSQL</code>，使用的Kong镜像版本为<code>1.1.2-alpine</code></p></blockquote><h1 id="官方镜像分析"><a href="#官方镜像分析" class="headerlink" title="官方镜像分析"></a>官方镜像分析</h1><p>Kong的官方文档（<a href="https://docs.konghq.com/install/docker/">Docker Installation</a>）给出了一个简单的Kong部署教程，记录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建docker网络</span><br>docker network create kong-net<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建数据库</span><br>docker run -d --name kong-database \<br>               --network=kong-net \<br>               -p 5432:5432 \<br>               -e &quot;POSTGRES_USER=kong&quot; \<br>               -e &quot;POSTGRES_DB=kong&quot; \<br>               postgres:9.6<br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化数据库</span><br>docker run --rm \<br>     --network=kong-net \<br>     -e &quot;KONG_DATABASE=postgres&quot; \<br>     -e &quot;KONG_PG_HOST=kong-database&quot; \<br>     kong:latest kong migrations bootstrap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动Kong</span><br>docker run -d --name kong \<br>     --network=kong-net \<br>     -e &quot;KONG_DATABASE=postgres&quot; \<br>     -e &quot;KONG_PG_HOST=kong-database&quot; \<br>     -e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \<br>     -e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \<br>     -e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \<br>     -e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \<br>     -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \<br>     -p 8000:8000 \<br>     -p 8443:8443 \<br>     -p 8001:8001 \<br>     -p 8444:8444 \<br>     kong:latest<br></code></pre></td></tr></table></figure><p>从以上教程可以看出，我们可以通过为官方镜像设置环境变量来配置Kong；而且，该镜像还有一个默认的启动命令，可以直接启动Kong主进程。<br>然后，我们再来看看<code>kong:1.1.2-alpine</code>这个官方镜像的<a href="https://github.com/Kong/docker-kong/blob/bb4efafd0e2272be1c27b9aa2de60cd0022a3fad/alpine/Dockerfile">Dockerfile</a>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.6</span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;Kong Core Team &lt;team-core@konghq.com&gt;&quot;</span></span><br><br><span class="hljs-keyword">ENV</span> KONG_VERSION <span class="hljs-number">1.1</span>.<span class="hljs-number">2</span><br><span class="hljs-keyword">ENV</span> KONG_SHA256 <span class="hljs-number">0</span>d7509fa2ef653b4aba14a1a1fd20339bccb4f8d386429102c42b7af6d8b6bdb<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> adduser -Su 1337 kong \</span><br><span class="language-bash">... <span class="hljs-comment"># 省略</span></span><br>&amp;&amp; chmod -R g=u /usr/local/kong<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> docker-entrypoint.sh /docker-entrypoint.sh</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/docker-entrypoint.sh&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8000</span> <span class="hljs-number">8443</span> <span class="hljs-number">8001</span> <span class="hljs-number">8444</span><br><br><span class="hljs-keyword">STOPSIGNAL</span> SIGTERM<br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;kong&quot;</span>, <span class="hljs-string">&quot;docker-start&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>从Dockerfile可以看出，官方镜像默认的启动命令为<code>ENTRYPOINT</code>+<code>CMD</code>；再结合前文官方教程里初始化数据库的命令，我们可以知道：</p><ul><li>初始化数据库的容器内启动命令为：<code>/docker-entrypoint.sh kong migrations bootstrap</code></li><li>启动Kong主进程的容器内启动命令为：<code>/docker-entrypoint.sh kong docker-start</code></li></ul><p>有了这些信息，我们就可以对官方镜像进行修改了。</p><h1 id="自定义Dockerfile、启动脚本"><a href="#自定义Dockerfile、启动脚本" class="headerlink" title="自定义Dockerfile、启动脚本"></a>自定义Dockerfile、启动脚本</h1><p>考虑到我有多套Kong配置分别用于不同环境（本地调试、测试、实际应用等），而这些配置中有许多重复的内容，所以我选择将这些重复的配置项放入Dockerfile中，不重复的配置项放入自定义启动脚本中。Dockerfile如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> kong:<span class="hljs-number">1.1</span>.<span class="hljs-number">2</span>-alpine<br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;orange_wolf &lt;orange_wolf@163.com&gt;&quot;</span></span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /gateway</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /gateway</span><br><span class="hljs-comment"># KONG_PREFIX指定工作目录，Kong的日志默认存储在 KONG_PREFIX/logs/ 目录下</span><br><span class="hljs-keyword">ENV</span> KONG_PREFIX=/gateway KONG_ADMIN_LISTEN=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">8001</span> KONG_DATABASE=postgres<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8000</span> <span class="hljs-number">8001</span><br><span class="hljs-comment"># 自定义启动脚本</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;./run-kong.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>自定义启动脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/usr/bin/env sh</span><br>case $&#123;1&#125; in<br>&quot;local&quot;)<br>    export KONG_PG_HOST=192.168.0.100<br>    export KONG_PG_USER=xxxxxx<br>    export KONG_PG_PASSWORD=xxxxxx<br>    ... # 省略<br>    ;;<br>&quot;pro&quot;)<br>    export KONG_PG_HOST=xxx.xxx.xxx.xxx<br>    export KONG_PG_USER=xxxxxx<br>    export KONG_PG_PASSWORD=xxxxxx<br>    ... # 省略<br>    ;;<br>... # 省略<br>esac<br><br>/docker-entrypoint.sh kong migrations bootstrap  # 初始化数据库<br>/docker-entrypoint.sh kong docker-start  # 启动Kong<br></code></pre></td></tr></table></figure><p>于是，我用自定义的启动脚本代替了原有的启动脚本，这样就能让我通过在启动容器时输入不同指令来载入不同Kong配置，也能让Kong在连接到空数据库时自动实现初始化动作（而不是直接退出）。而这种部署方式也更灵活，更容易从Docker迁移到k8s等其它平台。实际部署流程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t my-kong-image<br>docker run -d --name kong -p 8000:8000 -p 8001:8001 my-kong-image local  # 载入本地调试配置<br>docker run -d --name kong -p 8000:8000 -p 8001:8001 my-kong-image test  # 载入测试配置<br>docker run -d --name kong -p 8000:8000 -p 8001:8001 my-kong-image pro  # 载入实际应用配置<br></code></pre></td></tr></table></figure><h1 id="以root命令启动Nginx"><a href="#以root命令启动Nginx" class="headerlink" title="以root命令启动Nginx"></a>以root命令启动Nginx</h1><p>在自定义了Dockerfile和启动脚本后，似乎一切都能满足我的需求了。但不幸的时，以这个镜像启动容器时我遇到了如下错误：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">nginx: [alert] could not <span class="hljs-keyword">open</span> <span class="hljs-keyword">error</span> <span class="hljs-keyword">log</span> <span class="hljs-keyword">file</span>: <span class="hljs-keyword">open</span>() <span class="hljs-string">&quot;/gateway/logs/error.log&quot;</span> failed (13: Permission denied)<br></code></pre></td></tr></table></figure><p>很明显，nginx没有足够的权限将日志写入我指定的日志文件夹中。由于在不指定<code>KONG_PREFIX</code>环境变量时，nginx和Kong能正常将日志文件写入默认的<code>/usr/local/kong/logs/</code>目录下，所以我尝试在启动脚本<code>run-kong.sh</code>中通过<code>chmod</code>、<code>chown</code>命令，将<code>/gateway/logs/</code>目录的权限与<code>/usr/local/kong/logs/</code>目录的权限同步，但还是出现了一样的错误提示。<br>上文提到，官方镜像的启动脚本为<code>/docker-entrypoint.sh</code>。我找到了这份和官方Dockerfile放在一起的<a href="https://github.com/Kong/docker-kong/blob/bb4efafd0e2272be1c27b9aa2de60cd0022a3fad/alpine/docker-entrypoint.sh">启动脚本</a>，发现nginx是以<code>kong</code>用户的身份运行的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>      ...  # 省略<br>      exec su-exec kong /usr/local/openresty/nginx/sbin/nginx \<br>        -p &quot;$PREFIX&quot; \<br>        -c nginx.conf<br>    fi<br>  fi<br>fi<br><br>exec &quot;$@&quot;<br></code></pre></td></tr></table></figure><p>既然是这样，那么我在自己的启动脚本内修改官方的启动脚本，让nginx以root权限运行就可以解决问题了。修改后的自定义启动脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">...  # 省略<br><br>sed -i &#x27;s/su-exec kong/su-exec root/g&#x27; /docker-entrypoint.sh  # 修改启动脚本，以root身份启动nginx<br>/docker-entrypoint.sh kong migrations bootstrap  # 初始化数据库<br>/docker-entrypoint.sh kong docker-start  # 启动Kong<br></code></pre></td></tr></table></figure><p>顺便一提，如果想在容器内让Kong的默认端口由<code>8000</code>变为<code>80</code>（<code>KONG_PROXY_LISTEN=0.0.0.0:80</code>）或其它低于<code>1024</code>的端口，同样需要让nginx以root身份运行。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>开源项目官方提供的Docker镜像，往往要比自己用<code>Alpine</code>、<code>CentOS</code>、<code>Debian</code>等基础镜像一步步安装项目构成的镜像来得方便、稳定、好用；但后者又往往拥有前者无可比拟的自由度。其实，通过分析并“<code>继承</code>”官方Dockerfile、编写自己的启动脚本，往往能够同时拥有前两种镜像的优点——既方便，又自由。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>API GATEWAY</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django视图函数捕捉异常</title>
    <link href="/2019/05/23/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8/"/>
    <url>/2019/05/23/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2019-05-23.01.png"><br>不存在没有BUG的代码，也不存在不会出现异常的视图函数。当Django视图函数中的代码出现异常时，访问这个URL的用户就会收到状态码为<code>500 Internal Server Error</code>的HTTP 响应。如何捕捉视图函数里出现的异常，这是本篇文章要讨论的问题。</p><blockquote><p>注：本文所使用的运行环境为<code>uWSGI 2.0.18</code>+<code>Python3.6</code>+<code>Django 2.2</code></p></blockquote><h1 id="在uWSGI的日志中显示Traceback"><a href="#在uWSGI的日志中显示Traceback" class="headerlink" title="在uWSGI的日志中显示Traceback"></a>在uWSGI的日志中显示Traceback</h1><p>这种方法算是一种比较消极的异常捕捉方式——仅将<code>Traceback</code>异常信息记录在uWSGI的日志中，不做进一步处理。日志可以用于日后分析，但用户收到的仍然是<code>500 Internal Server Error</code>响应。而这种捕捉方式也是默认启用的，只要所使用的Django版本高于或等于<code>1.9</code>就行。例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># django_test/urls.py</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> .views <span class="hljs-keyword">import</span> index<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;index&#x27;</span>, index),<br>]<br><br><span class="hljs-comment"># django_test/views.py</span><br><span class="hljs-keyword">from</span> django.http.response <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">b&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><p>配置好路由和视图函数并用<code>uWSGI</code>启动应用后，访问<code>/index</code>页面就会触发<code>ZeroDivisionError</code>异常，该异常的Traceback信息也会输出至<code>uWSGI</code>的日志中，效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">uwsgi --module django_test.wsgi --http 0.0.0.0:5000</span><br>*** Starting uWSGI 2.0.18 (64bit) on [Thu May 23 16:27:42 2019] ***<br>......<br>spawned uWSGI worker 1 (and the only) (pid: 13888, cores: 1)<br>Traceback (most recent call last):<br>  ......<br>  File &quot;./django_test/views.py&quot;, line 3, in index<br>    1 / 0<br>ZeroDivisionError: division by zero<br>[pid: 13888|app: 0|req: 1/1] 127.0.0.1 () &#123;40 vars in 964 bytes&#125; [Thu May 23 08:27:44 2019] GET /index =&gt; generated 55641 bytes in 47 msecs (HTTP/1.1 500) 1 headers in 63 bytes (1 switches on core 0)<br></code></pre></td></tr></table></figure><h1 id="用函数装饰器捕捉异常"><a href="#用函数装饰器捕捉异常" class="headerlink" title="用函数装饰器捕捉异常"></a>用函数装饰器捕捉异常</h1><p>Django中的视图函数只是一个普通的函数（废话），这就意味着我们可以用一个能够捕捉异常的函数装饰器来包裹这个视图函数，例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># django_test/views.py</span><br><span class="hljs-keyword">from</span> django.http.response <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">catch_exc</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:<br>            <span class="hljs-comment"># put your code here</span><br>            <span class="hljs-comment"># logger.error(traceback.format_exc())</span><br><br>            <span class="hljs-comment"># return Response or just raise</span><br>            <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-built_in">str</span>(ex))<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@catch_exc</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">b&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在例子第18行～第19行，我用<code>catch_exc</code>这个装饰器包裹了<code>index</code>这个视图函数。而在<code>catch_exc</code>这个装饰器内部，我用<code>except Exception</code>语句捕捉了<code>index</code>函数所有可能出现的异常。然后，我们就可以按照需要来进行各种操作了，比如：</p><ul><li>用<code>traceback.format_exc()</code>获取详细的<code>Traceback</code>信息；</li><li>将错误信息输出至日志；</li><li>通知某人；</li></ul><p>等等等等。对异常的处理完成后，我们既可以通过<code>raise</code>语句让用户仍然收到<code>500 Internal Server Error</code>响应，也可以像上面的例子中返回一个关于异常信息的<code>200 OK</code>响应，还可以渲染一个提示HTML页面返回给用户。总之，Everything is under control.</p><h1 id="用Django中间件捕捉异常"><a href="#用Django中间件捕捉异常" class="headerlink" title="用Django中间件捕捉异常"></a>用Django中间件捕捉异常</h1><p>函数装饰器很好用，但装饰器只能针对单个视图函数。有没有一种应用于所有视图函数之上的异常捕捉方法？有的，这就是Django的中间件。和我上一篇文章（<a href="/2019/03/11/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">使用中间件对视图函数进行性能分析</a>）不同的是，那篇文章里所使用的中间件hook为<code>process_request&amp;process_response</code>，而这里使用中间件hook为<code>process_exception</code>，因为前者无法捕捉异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># django_test/my_middleware.py</span><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatchExcMiddleware</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, get_response</span>):<br>        self.get_response = get_response<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, request</span>):<br>        <span class="hljs-keyword">return</span> self.get_response(request)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_exception</span>(<span class="hljs-params">self, request, exception</span>):<br>        <span class="hljs-comment"># put your code here</span><br>        <span class="hljs-comment"># logging.error(traceback.format_exc())</span><br><br>        <span class="hljs-comment"># return Response or None</span><br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-built_in">str</span>(exception))<br><br><span class="hljs-comment"># django_test/settings.py</span><br><span class="hljs-comment"># ......</span><br>MIDDLEWARE = [<br>    <span class="hljs-comment"># ......</span><br>    <span class="hljs-string">&#x27;django_test.my_middleware.CatchExcMiddleware&#x27;</span>,  <span class="hljs-comment"># 启用中间件</span><br>]<br><span class="hljs-comment"># ......</span><br></code></pre></td></tr></table></figure><p>和上一节的装饰器类似，当视图函数出现异常时，Django就会遍历所有中间件的<code>process_exception</code>hook，包括例子里的。在这个<code>process_exception</code>方法里，我们同样可以完成上一节提到的各种操作，操作完成后可以通过<code>return None</code>语句让用户仍然收到<code>500 Internal Server Error</code>响应，也可以像上面的例子中返回一个关于异常信息的<code>200 OK</code>响应……这里就不再重复了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实在非DEBUG模式（<code>settings.py</code>里<code>DEBUG = False</code>）下，Django可以将视图函数里出现的异常信息以电子邮件的形式发送给<code>ADMINS</code>里配置的邮箱地址。这个功能需要配置邮箱参数、LOGGING，这里就不详细展开了，有兴趣的话可以查看<a href="https://docs.djangoproject.com/en/2.2/howto/error-reporting/">Django2.2官方文档(Error reporting)</a>或搜索相关教程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django视图函数性能分析</title>
    <link href="/2019/03/11/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2019/03/11/Django%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽然根据经验来看，许多简单Django应用的性能问题都来源于数据库IO（而这可以通过聚合查询等手段进行优化），但<code>premature optimization is the root of all evil</code>，定位性能问题的具体位置仍然是最应该先做的事。<br>和其它相对独立的Python代码不同，Django的视图函数代码与Django框架的耦合度很高，这给对代码的性能分析带来了一些困难。但幸运的是，Django丰富的生态环境中有足够多的手段能让我们很方便地完成这件事。</p><blockquote><p>注：本文所使用的运行环境为<code>Python 3.6</code>+<code>Django 2.1.7</code></p></blockquote><h1 id="Django-Debug-Toolbar"><a href="#Django-Debug-Toolbar" class="headerlink" title="Django Debug Toolbar"></a>Django Debug Toolbar</h1><p>Django Debug Toolbar可能是Django生态环境中最知名、最强大的页面调试工具了（<a href="https://django-debug-toolbar.readthedocs.io/en/latest/">官方文档连接</a>）。这个工具可以很方便地将：页面耗时、设置、请求&#x2F;响应、模板、SQL操作等一系列信息以侧边栏的形式展示在网页右侧，官方宣传图如下。<br><img src="/images/2019-03-11.01.png"><br>由于该工具能够展示页面耗时、SQL操作耗时等信息（特别是后者），所以该工具在视图函数性能分析方面也能起到非常关键的作用。<br>其最小化的部署方式如下：</p><ol><li><p>通过<code>pip</code>安装该工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install django-debug-toolbar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过源代码安装开发版</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pip install -e git+https://github.com/jazzband/django-debug-toolbar.git<span class="hljs-comment">#egg=django-debug-toolbar</span></span><br></code></pre></td></tr></table></figure></li><li><p>修改Django配置文件（默认为<code>settings.py</code>），包括修改<code>INSTALLED_APPS</code>、<code>MIDDLEWARE</code>项，新增<code>INTERNAL_IPS</code>项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,  <span class="hljs-comment"># 确保已配置静态文件</span><br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-string">&#x27;debug_toolbar&#x27;</span>,<br>]<br><br>STATIC_URL = <span class="hljs-string">&#x27;/static/&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">MIDDLEWARE = [<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-string">&#x27;debug_toolbar.middleware.DebugToolbarMiddleware&#x27;</span>,<br>    <span class="hljs-comment"># ...</span><br>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">INTERNAL_IPS = [<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>]  <span class="hljs-comment"># 只对本机访问启用</span><br></code></pre></td></tr></table></figure></li><li><p>配置Django URL规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> include, path<br><br>urlpatterns = [<br>    <span class="hljs-comment"># ...</span><br>]<br><br><span class="hljs-keyword">if</span> settings.DEBUG:  <span class="hljs-comment"># 只在DEBUG模式下启用</span><br>    <span class="hljs-keyword">import</span> debug_toolbar<br><br>    urlpatterns.append(<br>        path(<span class="hljs-string">&#x27;__debug__/&#x27;</span>, include(debug_toolbar.urls))<br>    )<br></code></pre></td></tr></table></figure></li></ol><p>此时打开任意一个页面即可看到对应效果，如下图所示：<br><img src="/images/2019-03-11.02.png"><br>另外，对于返回JSON、XML等数据的接口型视图函数来说，默认情况下是没办法使用Django Debug Tool的。不过在本地调试时，我们可以通过返回一个空的HTML页面（只需包含一个闭合的<code>body</code>标签）来达到类似的效果，具体操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http.response <span class="hljs-keyword">import</span> HttpResponse, JsonResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view_func</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-comment"># return JsonResponse(&#123;&#x27;data&#x27;: &#x27;...&#x27;&#125;)  # 无法启用Django Debug Tool</span><br><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;&lt;body&gt;&lt;/body&gt;&#x27;</span>)  <span class="hljs-comment"># 可以启用Django Debug Tool</span><br></code></pre></td></tr></table></figure><h1 id="cProfile-Django中间件"><a href="#cProfile-Django中间件" class="headerlink" title="cProfile+Django中间件"></a>cProfile+Django中间件</h1><p>虽然Django Debug Toolbar是一个非常实用的性能分析工具，但它对于视图函数内部的代码具体执行耗时依然无能为力。如果想要进行更深层次的代码性能分析，就要使用我<a href="/2019/03/08/Python%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88%E5%90%8E%E7%AF%87%EF%BC%89/">上一篇文章</a>介绍的<code>cProfile</code>这类工具了。但与那篇文章中提到的使用方法不同，这次我们必须先编写Django中间件才能对Django视图函数进行性能分析。</p><blockquote><p>注：本节内容灵感来自博文：<a href="https://rock-it.pl/how-to-profile-django-views/">How to profile Django views</a></p></blockquote><ol><li><p>编写中间件代码主体（假设位于<code>django_profile/my_middleware.py</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">import</span> cProfile<br><span class="hljs-keyword">import</span> pstats<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><br><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<br><span class="hljs-keyword">from</span> django.core.exceptions <span class="hljs-keyword">import</span> MiddlewareNotUsed<br><span class="hljs-keyword">from</span> django.http.response <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProfileMiddleware</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, get_response</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> settings.DEBUG:<br>            <span class="hljs-keyword">raise</span> MiddlewareNotUsed  <span class="hljs-comment"># 只在DEBUG模式下启用该中间件</span><br><br>        self.get_response = get_response<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, request</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;profile&#x27;</span> <span class="hljs-keyword">in</span> request.GET:  <span class="hljs-comment"># 当请求URL中存在profile参数时进行性能分析</span><br>            profile = cProfile.Profile()<br>            profile.enable()<br>            self.get_response(request)<br>            profile.disable()<br>            ram_file = StringIO()<br>            sort_by = <span class="hljs-string">&#x27;tottime&#x27;</span><br>            stats = pstats.Stats(profile, stream=ram_file)<br>            stats.strip_dirs().sort_stats(sort_by).print_stats()<br>            response = HttpResponse(ram_file.getvalue().encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-string">&#x27;text/plain&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            response = self.get_response(request)<br><br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure></li><li><p>在Django配置文件中启用该中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">MIDDLEWARE = [<br>    <span class="hljs-comment"># ...</span><br>    <span class="hljs-string">&#x27;django_profile.my_middleware.ProfileMiddleware&#x27;</span>,<br>    <span class="hljs-comment"># ...</span><br>]<br></code></pre></td></tr></table></figure></li></ol><p>该中间件大概的思路为：在Django真正调用视图函数（23行，<code>self.get_response(request)</code>）时，使用<code>cProfile</code>对该视图函数进行性能分析，并用分析结果打包成的<code>HttpResponse</code>取代视图函数的<code>Response</code>返回给Django（或者说用户）。当然，由于我加了一系列的限制，该流程只会在DEBUG模式下、且URL中包含<code>profile</code>参数时才会启用。<br>此时在任何一个页面URL（<code>HTTP Parameters</code>）中增加<code>profile</code>参数时，即可看到对应效果，如下图所示：<br><img src="/images/2019-03-11.03.png"></p><p>这里介绍的只是<code>cPorfile</code>中间件的一个简单用例。实际上<code>cProfile</code>与Django中间件均具有比较强的可定制性，<a href="https://github.com/safarijv/yet-another-django-profiler">yet-another-django-profiler</a>就是一个思路类似但更加复杂和完善的项目，有兴趣的话可以自行了解。另外，从理论上来说，<code>cProfile</code>可以和任意一个有类似Django中间件模式的Python Web框架搭配来达成类似的效果，这里就不扩展来说了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Python</tag>
      
      <tag>性能分析</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python代码性能分析（后篇）</title>
    <link href="/2019/03/08/Python%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88%E5%90%8E%E7%AF%87%EF%BC%89/"/>
    <url>/2019/03/08/Python%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88%E5%90%8E%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前一篇文章中，我介绍了测量执行Python代码所需要的总体时间的几种方法。而在实际的性能分析场景中，目标代码的逻辑往往比较复杂，光靠总体执行耗时并不能帮助我们快速定位性能瓶颈。这个时候就需要请出Python的标准库：<code>cProfile</code>（<a href="https://docs.python.org/3.6/library/profile.html">官方文档</a>）来对代码进行细致的性能分析了。<br>和前一篇文章一样，本文所使用的测试平台为<code>Ubuntu 18.04</code>+<code>Python 3.6</code>，并使用代码文件<code>slow_func.py</code>作为样例进行性能分析，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>():<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 等待一秒</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">24</span>):<br>        random.random()  <span class="hljs-comment"># 生成1600万个随机数</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    func1()<br>    func2()<br></code></pre></td></tr></table></figure><h1 id="命令行使用cProfile"><a href="#命令行使用cProfile" class="headerlink" title="命令行使用cProfile"></a>命令行使用cProfile</h1><p>对于单独的Python代码文件来说，通过命令行使用cProfile无疑是最方便的选择。<br>执行如下shell命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m cProfile -s tottime slow_func.py<br></code></pre></td></tr></table></figure><blockquote><p>首先用<code>python3</code>的<code>-m</code>选项调用<code>cProfile</code>模块，然后用<code>cProfile</code>的<code>-s</code>选项让输出结果按<code>tottime</code>进行排序，最后执行<code>slow_func.py</code>文件。<br>完整调用格式为：<code>python -m cProfile [-o output_file] [-s sort_order] myscript.py</code></p></blockquote><p>得到如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">        16778563 function calls (16778520 primitive calls) in 3.176 seconds<br><br>  Ordered by: internal time<br><br>  ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br>       1    1.456    1.456    2.172    2.172 slow_func.py:8(func2)<br>       1    1.001    1.001    1.001    1.001 &#123;built-in method time.sleep&#125;<br>16777216    0.716    0.000    0.716    0.000 &#123;method &#x27;random&#x27; of &#x27;_random.Random&#x27; objects&#125;<br>       1    0.001    0.001    0.001    0.001 &#123;built-in method _imp.create_dynamic&#125;<br>       3    0.000    0.000    0.000    0.000 &#123;built-in method marshal.loads&#125;<br>       # ...省略后续100多行<br></code></pre></td></tr></table></figure><ul><li>输出的第1行表明，脚本文件执行中存在1600多万次的函数调用，共耗费3.268秒。<ul><li>而根据前一篇文章的测试结果，直接执行该脚本文件只需要2秒左右的时间，那多出来的1秒多花在了哪里？这是因为<code>cProfile</code>需要对每一次函数调用进行监控和记录，由于该文件存在较多的函数调用，所以总执行耗时也就增长了许多了。</li></ul></li><li>第3行表明，下表内容按照<code>internal time</code>（内部执行时间，<code>tottime</code>）排序，这是由执行命令中的<code>-s tottime</code>参数决定的。</li><li>第5行为分析结果表的表头，依次为<code>ncalls</code>：调用次数、<code>tottime</code>：内部执行耗时、<code>percall</code>：内部执行耗时&#x2F;调用次数、<code>cumtime</code>：累计执行耗时、<code>percall</code>：累计执行耗时&#x2F;调用次数，以及最后的<code>文件名+行号+函数名称</code>。<ul><li><code>tottime</code>和<code>cumtime</code>的区别在于，<code>tottime</code>不包括子函数执行所花费的时间，而<code>cumtime</code>是包括的。</li></ul></li><li>第6行表明，<code>slow_func.py</code>中第8行的<code>func2</code>函数共执行了1次，内部耗时1.456秒，累计耗时2.172秒。</li><li>第7行表明，Python内置的<code>sleep</code>函数共执行了一次，耗时1.001秒。</li><li>第8行表明，Python内置的<code>random</code>函数共执行了1600多万次，耗时0.716秒。<ul><li>由于<code>random</code>函数是被<code>func2</code>函数调用的，所以这0.716秒和<code>func2</code>函数的内部执行耗时1.456秒，共同组成了<code>func2</code>函数的累计执行耗时：2.172秒。</li></ul></li><li>由于是用<code>cProfile</code>分析整个脚本文件，所以许多Python自身所需的函数调用也被展示在了结果里，所以分析结果表才会有100多行的规模。这个问题可以在下一小节中解决。</li></ul><h1 id="代码里使用cProfile"><a href="#代码里使用cProfile" class="headerlink" title="代码里使用cProfile"></a>代码里使用cProfile</h1><p>从本质上来说，通过命令行使用<code>cProfile</code>相当于在代码里使用<code>cProfile</code>的一个简化操作。而在命令行里分析代码有着明显的局限性：目标代码必须独立成文件、输出格式固定等等。所以，在代码里使用<code>cProfile</code>往往是一个更优的选择。<br>执行如下Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cProfile<br><span class="hljs-keyword">import</span> pstats<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><br><span class="hljs-keyword">from</span> slow_func <span class="hljs-keyword">import</span> func1, func2<br><br>profile = cProfile.Profile()<br>profile.enable()  <span class="hljs-comment"># 分析开始</span><br>func1()<br>func2()<br>profile.disable()  <span class="hljs-comment"># 分析结束</span><br>ram_file = StringIO()<br>sort_by = <span class="hljs-string">&#x27;tottime&#x27;</span><br>stats = pstats.Stats(profile, stream=ram_file)  <span class="hljs-comment"># 读取结果</span><br>stats.strip_dirs().sort_stats(sort_by).print_stats()  <span class="hljs-comment"># 按格式输出至ram_file</span><br><br><span class="hljs-built_in">print</span>(ram_file.getvalue())<br></code></pre></td></tr></table></figure><blockquote><p>代码的核心逻辑是使用<code>cProfile</code>模块的<code>Profile</code>类对代码块进行性能分析，分析完成后使用<code>pstats</code>模块的<code>Stats</code>类将分析结果按一定格式写入至内存文件，最后输出该文件里写入的内容。<br>实际上这只是一个较为简单的样例，<code>pstats</code>模块还可以获得函数之间的调用关系、将结果持久化、显示文件路径等等，更完整的说明可以参考<a href="https://docs.python.org/3.6/library/profile.html">官方文档</a>。</p></blockquote><p>得到如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">        16777220 function calls in 3.225 seconds<br><br>  Ordered by: internal time<br><br>  ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br>       1    1.517    1.517    2.224    2.224 slow_func.py:8(func2)<br>       1    1.001    1.001    1.001    1.001 &#123;built-in method time.sleep&#125;<br>16777216    0.707    0.000    0.707    0.000 &#123;method &#x27;random&#x27; of &#x27;_random.Random&#x27; objects&#125;<br>       1    0.000    0.000    1.001    1.001 slow_func.py:5(func1)<br>       1    0.000    0.000    0.000    0.000 &#123;method &#x27;disable&#x27; of &#x27;_lsprof.Profiler&#x27; objects&#125;<br></code></pre></td></tr></table></figure><h1 id="cProfile结果可视化"><a href="#cProfile结果可视化" class="headerlink" title="cProfile结果可视化"></a>cProfile结果可视化</h1><p>一般来说，通过以上两个例子就可以获得完善的性能分析报告了。但通过一些可视化工具对<code>cProfile</code> 的报告进行二次处理，我们可以更清晰地观察函数之间的调用关系、更轻松地找出性能瓶颈，算是一个不错的辅助手段。在这里只介绍一种可视化工具：JetBrain PyCharm自带的<code>Profile</code>工具。</p><ul><li><p>点击Pycharm中<code>Run</code>菜单里的<code>Profile &#39;xxx&#39;项目</code>，即可对当前运行执行方案使用<code>cProfile</code>进行性能分析，如下图：<br><img src="/images/2019-03-08.01.png"></p></li><li><p>结果如下图所示。其中，<code>Time</code>对应<code>cProfile</code>中的<code>cumtime</code>，即累计执行耗时；<code>Own Time</code>对应<code>cProfile</code>中的<code>tottime</code>，即内部执行耗时。<br><img src="/images/2019-03-08.02.png"></p><p><img src="/images/2019-03-08.03.png"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python代码性能分析（前篇）</title>
    <link href="/2019/03/06/Python%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88%E5%89%8D%E7%AF%87%EF%BC%89/"/>
    <url>/2019/03/06/Python%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%EF%BC%88%E5%89%8D%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们怎样知道执行某个Python文件、某个函数、某段代码所耗费的总体时间？这是这篇文章尝试去回答的问题。<br>作为样例，本文使用<code>slow_func.py</code>来进行性能分析，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>():<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 等待一秒</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">24</span>):<br>        random.random()  <span class="hljs-comment"># 生成1600万个随机数</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    func1()<br>    func2()<br></code></pre></td></tr></table></figure><p>函数<code>func1</code>和<code>func2</code>的区别在于：CPU在执行<code>func1</code>时基本处在闲置状态，在执行<code>func2()</code>时基本处于忙碌状态。这点会在之后的测试中有所体现。<br>在笔者的测试平台（<code>Ubuntu 18.04</code>+<code>Python 3.6</code>）上，两个函数所耗费的时间均在<code>1s</code>左右。</p><h1 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h1><p>类UNIX平台提供了<code>time</code>命令以统计执行执行命令所花费的时间。当然，这是一个通用型的工具，而不局限于Python。<br>执行如下shell命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">time python3 slow_func.py<br></code></pre></td></tr></table></figure><p>获得如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">real0m1.960s  # 命令执行时间<br>user0m0.946s  # 用户态CPU时间<br>sys 0m0.008s<br></code></pre></td></tr></table></figure><p>根据前两行结果中我们可以得知，<code>slow_func.py</code>从开始到结束共消耗了2秒左右的时间，但实际消耗的用户态CPU时间只有1秒左右。这是因为CPU在执行<code>func1()</code>时处于等待状态（<code>sleep</code>），这段时间里是不消耗CPU时间的。</p><h1 id="time库"><a href="#time库" class="headerlink" title="time库"></a>time库</h1><p>Python提供了标准库<code>time</code>来进行关于时间的操作，我们可以通过这个库来测量代码执行所耗费的时间。<br>执行如下Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> slow_func <span class="hljs-keyword">import</span> func1, func2<br><br>start1, start2 = time.perf_counter(), time.process_time()<br>func1()<br>func2()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;perf_counter: &#123;:.4f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.perf_counter() - start1))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;process_time: &#123;:.4f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(time.process_time() - start2))<br></code></pre></td></tr></table></figure><p>获得如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">perf_counter: 2.1201s<br>process_time: 1.1119s<br></code></pre></td></tr></table></figure><p><code>time.perf_counter()</code>的时间差是代码开始与代码结束两个时间点的时间差，而<code>time.process_time()</code>的时间差是消耗的CPU时间长度，所以得出了不同的结果，这与先前的<code>time</code>命令的原因和结果相类似。</p><h1 id="time库-上下文管理器"><a href="#time库-上下文管理器" class="headerlink" title="time库+上下文管理器"></a>time库+上下文管理器</h1><p>上面提到的用time库来测量代码耗时用起来很方便，但如果经常要用到的话写起来也很繁琐。这时我们可以写一个自定义的上下文管理器来避免重复代码。<br>执行如下Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">time_block</span>(<span class="hljs-params">label</span>):  <span class="hljs-comment"># 代码块计时上下文管理器</span><br>    <span class="hljs-comment"># 进入上下文</span><br>    start = time.perf_counter()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span>  <span class="hljs-comment"># 执行代码块</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># 执行完成后输出代码块耗时</span><br>        used = time.perf_counter() - start<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125;: &#123;:.4f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(label, used))<br><br><span class="hljs-comment"># 用法</span><br><span class="hljs-keyword">with</span> time_block(<span class="hljs-string">&#x27;sleep&#x27;</span>):<br>    time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>获得如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sleep: 1.0011s<br></code></pre></td></tr></table></figure><h1 id="time库-函数装饰器"><a href="#time库-函数装饰器" class="headerlink" title="time库+函数装饰器"></a>time库+函数装饰器</h1><p>上下文管理器针对的是代码块，如果只想统计函数执行所消耗的时间，用函数装饰器更为方便和快捷。<br>执行如下Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">time_wrap</span>(<span class="hljs-params">func</span>):  <span class="hljs-comment"># 函数计时装饰器</span><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        start = time.perf_counter()<br>        r = func(*args, **kwargs)<br>        used = time.perf_counter() - start<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;f.__module__&#125;.&#123;f.__name__&#125;: &#123;t:.4f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(f=func, t=used))<br>        <span class="hljs-keyword">return</span> r<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@time_wrap  </span><span class="hljs-comment"># 函数定义时使用装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">slow_func</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 执行函数时自动调用装饰器</span><br>slow_func()<br></code></pre></td></tr></table></figure><p>获得如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">__main__.slow_func: 1.0008s<br></code></pre></td></tr></table></figure><h1 id="timeit库"><a href="#timeit库" class="headerlink" title="timeit库"></a>timeit库</h1><p>当需要多次重复测量Python代时以获取精确的耗时结果时，我们可以通过循环控制配合上文提到的方法来实现，也可以通过一个更便捷的、适合重复测试的标准库：<code>timeit</code>来实现。<br>执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> timeit<br><br>setup = <span class="hljs-string">&#x27;from slow_func import func1&#x27;</span><br><br>used = timeit.timeit(<span class="hljs-string">&#x27;func1()&#x27;</span>, setup=setup, number=<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(used))<br></code></pre></td></tr></table></figure><p>获得如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">5.0039<br></code></pre></td></tr></table></figure><p><code>timeit</code>库默认使用的计时器为<code>time.perf_counter()</code>，如果想换成测量CPU耗时的计时器，只需要附加上<code>timer</code>参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br><span class="hljs-keyword">import</span> time<br>timer = time.process_time<br><br>used = timeit.timeit(<span class="hljs-string">&#x27;func1()&#x27;</span>, timer=timer, setup=setup, number=<span class="hljs-number">5</span>)  <span class="hljs-comment"># 附加timer参数</span><br>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx&amp;uWSGI静态文件性能对比</title>
    <link href="/2019/02/20/Nginx-uWSGI%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <url>/2019/02/20/Nginx-uWSGI%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="/images/2019-02-20.01.png"><br>在实际部署Python Web应用时，我们往往会采用类似<code>Nginx-&gt;uWSGI/Gunicorn-&gt;Python</code>的三层架构。使用Nginx而不是直接使用uWSGI来处理HTTP请求的理由主要有以下几点：</p><ul><li>Nginx更安全；</li><li>需要实现负载均衡&#x2F;URL转发；</li><li>Nginx处理静态文件更快，缓存头更完善。</li></ul><p>但在某些诸如简单Web应用、外部统一网关、单机单容器、内网环境等部署场景，Nginx的优势并不一定那么明显。本文着重分析Nginx、uWSGI的静态文件性能问题，辅助判断是否需要使用Nginx。</p><h1 id="性能测试流程"><a href="#性能测试流程" class="headerlink" title="性能测试流程"></a>性能测试流程</h1><ol><li>创建测试文件<br>  生成大小为4k~512k的随机字符串文件作为测试样本</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">openssl rand -hex $(bc &lt;&lt;&lt; 2^11-1) &gt; 4k.hex<br>openssl rand -hex $(bc &lt;&lt;&lt; 2^12-1) &gt; 8k.hex<br>...<br>openssl rand -hex $(bc &lt;&lt;&lt; 2^18-1) &gt; 512k.hex<br></code></pre></td></tr></table></figure><ol start="2"><li><p>启动测试容器</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -v $(pwd):/static --name pytest python:3.6-jessie tail -f /dev/null<br>docker exec -it pytest bash<br></code></pre></td></tr></table></figure></li><li><p>配置并启动Nginx和uWSGI</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt update &amp;&amp; apt install -y nginx apache2-utils<br>pip install uwsgi<br><br>cat &gt;/etc/nginx/conf.d/default.conf&lt;&lt;EOF<br>server &#123;<br>    listen 81 default_server;<br><br>    location / &#123;<br>        root /static;<br>    &#125;<br>&#125;<br>EOF<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动nginx和uWSGI</span><br>service nginx start<br>uwsgi --master --http 0.0.0.0:82 --static-map /=/static<br></code></pre></td></tr></table></figure></li><li><p>开始测试<br>  使用<code>Apache Benchmark</code>对Nginx和uWSGI的静态文件进行测试，并发数为100，共请求20000次。提取测试结果中的关键参数：<code>Requests per second</code>。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /static<br>for fn in *.hex; do<br>  echo -e &quot;\n$fn&quot;<br>  echo &quot;nginx (keep alive)&quot;<br>  ab -q -k -c 100 -n 20000 127.0.0.1:81/$fn | grep -Po &#x27;Requests per second:[ \d]+&#x27;<br>  echo &quot;nginx&quot;<br>  ab -q -c 100 -n 20000 127.0.0.1:81/$fn | grep -Po &#x27;Requests per second:[ \d]+&#x27;<br>  echo &quot;uwsgi&quot;<br>  ab -q -c 100 -n 20000 127.0.0.1:82/$fn | grep -Po &#x27;Requests per second:[ \d]+&#x27;<br>done<br></code></pre></td></tr></table></figure></li></ol><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p><img src="/images/2019-02-20.02.png"></p><p>其中<code>nginx (keep-alive)</code>项为理论最好情况，实际应用中很难达到。uWSGI在处理静态文件时不支持<code>keep-alive</code>模式。</p><p>假设将未使用<code>keep-alive</code>的Nginx性能作为基准，可得出下表：</p><table><thead><tr><th align="center">文件大小</th><th align="center">nginx(keep-alive)</th><th align="center">nginx</th><th align="center">uwsgi</th></tr></thead><tbody><tr><td align="center">4k</td><td align="center">157%</td><td align="center">100%</td><td align="center">43%</td></tr><tr><td align="center">8k</td><td align="center">204%</td><td align="center">100%</td><td align="center">42%</td></tr><tr><td align="center">16k</td><td align="center">202%</td><td align="center">100%</td><td align="center">34%</td></tr><tr><td align="center">32k</td><td align="center">207%</td><td align="center">100%</td><td align="center">26%</td></tr><tr><td align="center">64k</td><td align="center">173%</td><td align="center">100%</td><td align="center">20%</td></tr><tr><td align="center">128k</td><td align="center">160%</td><td align="center">100%</td><td align="center">14%</td></tr><tr><td align="center">256k</td><td align="center">151%</td><td align="center">100%</td><td align="center">11%</td></tr><tr><td align="center">512k</td><td align="center">125%</td><td align="center">100%</td><td align="center">10%</td></tr></tbody></table><p>由此可以看出，uWSGI在处理小体积静态文件上的效率能达到Nginx的三、四成，但当静态文件体积增加到64k及以上时，其效率就远比不上Nginx了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>uWSGI</tag>
      
      <tag>性能测试</tag>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
